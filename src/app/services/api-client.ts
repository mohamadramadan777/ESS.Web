//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import { API_BASE_URL } from './tokens';

@Injectable()
export class Client {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    authenticate(body: AuthenticateRequest | undefined): Observable<AuthenticateResponseBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResponseBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResponseBaseResponse>;
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResponseBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResponseBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResponseBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    sendFeedback(body: ContactUs | undefined): Observable<Int32BaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/sendFeedback";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendFeedback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendFeedback(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int32BaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int32BaseResponse>;
        }));
    }

    protected processSendFeedback(response: HttpResponseBase): Observable<Int32BaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int32BaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int32BaseResponse>(null as any);
    }

    /**
     * @param userQACategoryID (optional) 
     * @return OK
     */
    getUserLoginQuestions(userQACategoryID: number | undefined): Observable<UserQuestionAnswersListBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/get-user-login-questions?";
        if (userQACategoryID === null)
            throw new Error("The parameter 'userQACategoryID' cannot be null.");
        else if (userQACategoryID !== undefined)
            url_ += "UserQACategoryID=" + encodeURIComponent("" + userQACategoryID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserLoginQuestions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserLoginQuestions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserQuestionAnswersListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserQuestionAnswersListBaseResponse>;
        }));
    }

    protected processGetUserLoginQuestions(response: HttpResponseBase): Observable<UserQuestionAnswersListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserQuestionAnswersListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserQuestionAnswersListBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    getUserQa(): Observable<UserQuestionAnswersListBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/get-user-qa";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserQa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserQa(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserQuestionAnswersListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserQuestionAnswersListBaseResponse>;
        }));
    }

    protected processGetUserQa(response: HttpResponseBase): Observable<UserQuestionAnswersListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserQuestionAnswersListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserQuestionAnswersListBaseResponse>(null as any);
    }

    /**
     * @param email (optional) 
     * @return OK
     */
    updateRegisteredEmail(email: string | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/update-registered-email?";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRegisteredEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRegisteredEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processUpdateRegisteredEmail(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @param text (optional) 
     * @return OK
     */
    resetPassword(text: string | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/reset-password?";
        if (text === null)
            throw new Error("The parameter 'text' cannot be null.");
        else if (text !== undefined)
            url_ += "text=" + encodeURIComponent("" + text) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    saveUserQuestionAnswer(body: UserQuestionAnswersDto[] | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/save-user-question-answer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserQuestionAnswer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserQuestionAnswer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processSaveUserQuestionAnswer(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    protected(): Observable<void> {
        let url_ = this.baseUrl + "/api/AccessRequest/protected";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProtected(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProtected(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processProtected(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return OK
     */
    getIndividualList(): Observable<WAccessRequestsListBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/get-individual-list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIndividualList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIndividualList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WAccessRequestsListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WAccessRequestsListBaseResponse>;
        }));
    }

    protected processGetIndividualList(response: HttpResponseBase): Observable<WAccessRequestsListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WAccessRequestsListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WAccessRequestsListBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    getSystemAccounts(): Observable<WAccessRequestsListBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/get-system-accounts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSystemAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSystemAccounts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WAccessRequestsListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WAccessRequestsListBaseResponse>;
        }));
    }

    protected processGetSystemAccounts(response: HttpResponseBase): Observable<WAccessRequestsListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WAccessRequestsListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WAccessRequestsListBaseResponse>(null as any);
    }

    /**
     * @param objectID (optional) 
     * @param objectInstanceID (optional) 
     * @param soStatusTypeID (optional) 
     * @return OK
     */
    getObjectSoTaskStatus(objectID: number | undefined, objectInstanceID: number | undefined, soStatusTypeID: number | undefined): Observable<ObjectSOTaskStatusListBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/get-object-so-task-status?";
        if (objectID === null)
            throw new Error("The parameter 'objectID' cannot be null.");
        else if (objectID !== undefined)
            url_ += "objectID=" + encodeURIComponent("" + objectID) + "&";
        if (objectInstanceID === null)
            throw new Error("The parameter 'objectInstanceID' cannot be null.");
        else if (objectInstanceID !== undefined)
            url_ += "objectInstanceID=" + encodeURIComponent("" + objectInstanceID) + "&";
        if (soStatusTypeID === null)
            throw new Error("The parameter 'soStatusTypeID' cannot be null.");
        else if (soStatusTypeID !== undefined)
            url_ += "soStatusTypeID=" + encodeURIComponent("" + soStatusTypeID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObjectSoTaskStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObjectSoTaskStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectSOTaskStatusListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectSOTaskStatusListBaseResponse>;
        }));
    }

    protected processGetObjectSoTaskStatus(response: HttpResponseBase): Observable<ObjectSOTaskStatusListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectSOTaskStatusListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectSOTaskStatusListBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    loadContacts(): Observable<StringStringDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/load-contacts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadContacts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringStringDictionaryBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringStringDictionaryBaseResponse>;
        }));
    }

    protected processLoadContacts(response: HttpResponseBase): Observable<StringStringDictionaryBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringStringDictionaryBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringStringDictionaryBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    loadRequiredIndividuals(): Observable<StringStringDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/load-required-individuals";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadRequiredIndividuals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadRequiredIndividuals(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringStringDictionaryBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringStringDictionaryBaseResponse>;
        }));
    }

    protected processLoadRequiredIndividuals(response: HttpResponseBase): Observable<StringStringDictionaryBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringStringDictionaryBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringStringDictionaryBaseResponse>(null as any);
    }

    /**
     * @param firmType (optional) 
     * @return OK
     */
    getGeneralSubmissionForms(firmType: number | undefined): Observable<GeneralSubmissionFormListBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/get-general-submission-forms?";
        if (firmType === null)
            throw new Error("The parameter 'firmType' cannot be null.");
        else if (firmType !== undefined)
            url_ += "firmType=" + encodeURIComponent("" + firmType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralSubmissionForms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralSubmissionForms(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralSubmissionFormListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralSubmissionFormListBaseResponse>;
        }));
    }

    protected processGetGeneralSubmissionForms(response: HttpResponseBase): Observable<GeneralSubmissionFormListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralSubmissionFormListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GeneralSubmissionFormListBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    getReportDetails(): Observable<ReportSchDetailsListBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/get-report-details";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportSchDetailsListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportSchDetailsListBaseResponse>;
        }));
    }

    protected processGetReportDetails(response: HttpResponseBase): Observable<ReportSchDetailsListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportSchDetailsListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportSchDetailsListBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    getIndividualListForFirm(): Observable<WAccessRequestsListBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/get-individual-list-for-firm";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIndividualListForFirm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIndividualListForFirm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WAccessRequestsListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WAccessRequestsListBaseResponse>;
        }));
    }

    protected processGetIndividualListForFirm(response: HttpResponseBase): Observable<WAccessRequestsListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WAccessRequestsListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WAccessRequestsListBaseResponse>(null as any);
    }

    /**
     * @param senEmailOnUpdate (optional) 
     * @param objectID (optional) 
     * @param body (optional) 
     * @return OK
     */
    saveWaccessRequestDetails(senEmailOnUpdate: boolean | undefined, objectID: number | undefined, body: WAccessRequests | undefined): Observable<WAccessRequestsBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/save-waccess-request-details?";
        if (senEmailOnUpdate === null)
            throw new Error("The parameter 'senEmailOnUpdate' cannot be null.");
        else if (senEmailOnUpdate !== undefined)
            url_ += "senEmailOnUpdate=" + encodeURIComponent("" + senEmailOnUpdate) + "&";
        if (objectID === null)
            throw new Error("The parameter 'objectID' cannot be null.");
        else if (objectID !== undefined)
            url_ += "objectID=" + encodeURIComponent("" + objectID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveWaccessRequestDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveWaccessRequestDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WAccessRequestsBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WAccessRequestsBaseResponse>;
        }));
    }

    protected processSaveWaccessRequestDetails(response: HttpResponseBase): Observable<WAccessRequestsBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WAccessRequestsBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WAccessRequestsBaseResponse>(null as any);
    }

    /**
     * @param objectID (optional) 
     * @param objectInstanceID (optional) 
     * @param body (optional) 
     * @return OK
     */
    sendEmailToWebsiteUser(objectID: number | undefined, objectInstanceID: number | undefined, body: WAccessRequests | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/AccessRequest/send-email-to-website-user?";
        if (objectID === null)
            throw new Error("The parameter 'objectID' cannot be null.");
        else if (objectID !== undefined)
            url_ += "objectID=" + encodeURIComponent("" + objectID) + "&";
        if (objectInstanceID === null)
            throw new Error("The parameter 'objectInstanceID' cannot be null.");
        else if (objectInstanceID !== undefined)
            url_ += "objectInstanceID=" + encodeURIComponent("" + objectInstanceID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailToWebsiteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailToWebsiteUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendEmailToWebsiteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param wRoleIds (optional) 
     * @return OK
     */
    deactivateWuser(wRoleIds: string | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/deactivate-wuser?";
        if (wRoleIds === null)
            throw new Error("The parameter 'wRoleIds' cannot be null.");
        else if (wRoleIds !== undefined)
            url_ += "wRoleIds=" + encodeURIComponent("" + wRoleIds) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeactivateWuser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeactivateWuser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processDeactivateWuser(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    deleteIndividualDetailsPOST(): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/delete-individual-details";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteIndividualDetailsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteIndividualDetailsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processDeleteIndividualDetailsPOST(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    deleteIndividualDetailsGET(): Observable<StringStringDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/delete-individual-details";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteIndividualDetailsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteIndividualDetailsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringStringDictionaryBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringStringDictionaryBaseResponse>;
        }));
    }

    protected processDeleteIndividualDetailsGET(response: HttpResponseBase): Observable<StringStringDictionaryBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringStringDictionaryBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringStringDictionaryBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    checkAccountExists(body: WAccessRequests | undefined): Observable<WAccessRequestsBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/check-account-exists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckAccountExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckAccountExists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WAccessRequestsBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WAccessRequestsBaseResponse>;
        }));
    }

    protected processCheckAccountExists(response: HttpResponseBase): Observable<WAccessRequestsBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WAccessRequestsBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WAccessRequestsBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateUserRoles(body: WAccessRequests | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/update-user-roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processUpdateUserRoles(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    deactivateUserRoles(body: WAccessRequests | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/deactivate-user-roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeactivateUserRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeactivateUserRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processDeactivateUserRoles(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @param contactID (optional) 
     * @param contactAssnID (optional) 
     * @param isESSAccessRequest (optional) 
     * @return OK
     */
    updateContactIsEssAccess(contactID: number | undefined, contactAssnID: number | undefined, isESSAccessRequest: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/AccessRequest/update-contact-is-ess-access?";
        if (contactID === null)
            throw new Error("The parameter 'contactID' cannot be null.");
        else if (contactID !== undefined)
            url_ += "contactID=" + encodeURIComponent("" + contactID) + "&";
        if (contactAssnID === null)
            throw new Error("The parameter 'contactAssnID' cannot be null.");
        else if (contactAssnID !== undefined)
            url_ += "contactAssnID=" + encodeURIComponent("" + contactAssnID) + "&";
        if (isESSAccessRequest === null)
            throw new Error("The parameter 'isESSAccessRequest' cannot be null.");
        else if (isESSAccessRequest !== undefined)
            url_ += "isESSAccessRequest=" + encodeURIComponent("" + isESSAccessRequest) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactIsEssAccess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactIsEssAccess(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateContactIsEssAccess(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return OK
     */
    checkUserActive(): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/check-user-active";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckUserActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckUserActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processCheckUserActive(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    insertUserRoleDetail(body: WAccessRequests | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/insert-user-role-detail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertUserRoleDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertUserRoleDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processInsertUserRoleDetail(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    activateUserRoles(body: WAccessRequests | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/AccessRequest/activate-user-roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateUserRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateUserRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActivateUserRoles(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    checkAccountExistsById(body: WAccessRequests | undefined): Observable<WAccessRequestsBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/check-account-exists-by-id";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckAccountExistsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckAccountExistsById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WAccessRequestsBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WAccessRequestsBaseResponse>;
        }));
    }

    protected processCheckAccountExistsById(response: HttpResponseBase): Observable<WAccessRequestsBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WAccessRequestsBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WAccessRequestsBaseResponse>(null as any);
    }

    /**
     * @param contactID (optional) 
     * @param contactAssnID (optional) 
     * @param isESSAccessRequest (optional) 
     * @return OK
     */
    getXmlDocument(contactID: number | undefined, contactAssnID: number | undefined, isESSAccessRequest: boolean | undefined): Observable<XmlDocumentBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/get-xml-document?";
        if (contactID === null)
            throw new Error("The parameter 'contactID' cannot be null.");
        else if (contactID !== undefined)
            url_ += "contactID=" + encodeURIComponent("" + contactID) + "&";
        if (contactAssnID === null)
            throw new Error("The parameter 'contactAssnID' cannot be null.");
        else if (contactAssnID !== undefined)
            url_ += "contactAssnID=" + encodeURIComponent("" + contactAssnID) + "&";
        if (isESSAccessRequest === null)
            throw new Error("The parameter 'isESSAccessRequest' cannot be null.");
        else if (isESSAccessRequest !== undefined)
            url_ += "isESSAccessRequest=" + encodeURIComponent("" + isESSAccessRequest) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetXmlDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetXmlDocument(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<XmlDocumentBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<XmlDocumentBaseResponse>;
        }));
    }

    protected processGetXmlDocument(response: HttpResponseBase): Observable<XmlDocumentBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = XmlDocumentBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<XmlDocumentBaseResponse>(null as any);
    }

    /**
     * @param doctypeId (optional) 
     * @param firmTypeDesc (optional) 
     * @param objectId (optional) 
     * @return OK
     */
    getDocSignatories(doctypeId: number | undefined, firmTypeDesc: string | undefined, objectId: number | undefined): Observable<DocSignatoriesBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/get-doc-signatories?";
        if (doctypeId === null)
            throw new Error("The parameter 'doctypeId' cannot be null.");
        else if (doctypeId !== undefined)
            url_ += "doctypeId=" + encodeURIComponent("" + doctypeId) + "&";
        if (firmTypeDesc === null)
            throw new Error("The parameter 'firmTypeDesc' cannot be null.");
        else if (firmTypeDesc !== undefined)
            url_ += "firmTypeDesc=" + encodeURIComponent("" + firmTypeDesc) + "&";
        if (objectId === null)
            throw new Error("The parameter 'objectId' cannot be null.");
        else if (objectId !== undefined)
            url_ += "objectId=" + encodeURIComponent("" + objectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocSignatories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocSignatories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocSignatoriesBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocSignatoriesBaseResponse>;
        }));
    }

    protected processGetDocSignatories(response: HttpResponseBase): Observable<DocSignatoriesBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocSignatoriesBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocSignatoriesBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    insertUpdateFeedbackDetails(body: ContactUs | undefined): Observable<Int32BaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/insert-update-feedback-details";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertUpdateFeedbackDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertUpdateFeedbackDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int32BaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int32BaseResponse>;
        }));
    }

    protected processInsertUpdateFeedbackDetails(response: HttpResponseBase): Observable<Int32BaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int32BaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int32BaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    saveEmailDetails(body: EmailRequisites | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/AccessRequest/save-email-details";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveEmailDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveEmailDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveEmailDetails(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param qfcNumber (optional) 
     * @param formName (optional) 
     * @param docTypeID (optional) 
     * @param applicationID (optional) 
     * @param userID (optional) 
     * @return OK
     */
    submitAiApplicationEmail(qfcNumber: string | undefined, formName: string | undefined, docTypeID: number | undefined, applicationID: number | undefined, userID: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/AccessRequest/submit-ai-application-email?";
        if (qfcNumber === null)
            throw new Error("The parameter 'qfcNumber' cannot be null.");
        else if (qfcNumber !== undefined)
            url_ += "qfcNumber=" + encodeURIComponent("" + qfcNumber) + "&";
        if (formName === null)
            throw new Error("The parameter 'formName' cannot be null.");
        else if (formName !== undefined)
            url_ += "formName=" + encodeURIComponent("" + formName) + "&";
        if (docTypeID === null)
            throw new Error("The parameter 'docTypeID' cannot be null.");
        else if (docTypeID !== undefined)
            url_ += "docTypeID=" + encodeURIComponent("" + docTypeID) + "&";
        if (applicationID === null)
            throw new Error("The parameter 'applicationID' cannot be null.");
        else if (applicationID !== undefined)
            url_ += "applicationID=" + encodeURIComponent("" + applicationID) + "&";
        if (userID === null)
            throw new Error("The parameter 'userID' cannot be null.");
        else if (userID !== undefined)
            url_ += "userID=" + encodeURIComponent("" + userID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitAiApplicationEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitAiApplicationEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSubmitAiApplicationEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param roleList (optional) 
     * @param objectID (optional) 
     * @return OK
     */
    getRoleAccess(roleList: string | undefined, objectID: number | undefined): Observable<AppControlsListBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/get-role-access?";
        if (roleList === null)
            throw new Error("The parameter 'roleList' cannot be null.");
        else if (roleList !== undefined)
            url_ += "roleList=" + encodeURIComponent("" + roleList) + "&";
        if (objectID === null)
            throw new Error("The parameter 'objectID' cannot be null.");
        else if (objectID !== undefined)
            url_ += "objectID=" + encodeURIComponent("" + objectID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleAccess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleAccess(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppControlsListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppControlsListBaseResponse>;
        }));
    }

    protected processGetRoleAccess(response: HttpResponseBase): Observable<AppControlsListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppControlsListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppControlsListBaseResponse>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return OK
     */
    getUserRoles(userId: number | undefined): Observable<AppRolesListBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/get-user-roles?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppRolesListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppRolesListBaseResponse>;
        }));
    }

    protected processGetUserRoles(response: HttpResponseBase): Observable<AppRolesListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppRolesListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppRolesListBaseResponse>(null as any);
    }

    /**
     * @param docTypeID (optional) 
     * @param freqTypeDesc (optional) 
     * @param objectID (optional) 
     * @param firmTypeID (optional) 
     * @return OK
     */
    getDocumentAccessRoles(docTypeID: number | undefined, freqTypeDesc: string | undefined, objectID: number | undefined, firmTypeID: number | undefined): Observable<StringListBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/get-document-access-roles?";
        if (docTypeID === null)
            throw new Error("The parameter 'docTypeID' cannot be null.");
        else if (docTypeID !== undefined)
            url_ += "docTypeID=" + encodeURIComponent("" + docTypeID) + "&";
        if (freqTypeDesc === null)
            throw new Error("The parameter 'freqTypeDesc' cannot be null.");
        else if (freqTypeDesc !== undefined)
            url_ += "freqTypeDesc=" + encodeURIComponent("" + freqTypeDesc) + "&";
        if (objectID === null)
            throw new Error("The parameter 'objectID' cannot be null.");
        else if (objectID !== undefined)
            url_ += "objectID=" + encodeURIComponent("" + objectID) + "&";
        if (firmTypeID === null)
            throw new Error("The parameter 'firmTypeID' cannot be null.");
        else if (firmTypeID !== undefined)
            url_ += "firmTypeID=" + encodeURIComponent("" + firmTypeID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentAccessRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentAccessRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringListBaseResponse>;
        }));
    }

    protected processGetDocumentAccessRoles(response: HttpResponseBase): Observable<StringListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringListBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    checkAccess(body: AccessRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/AccessRequest/check-access";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckAccess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckAccess(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCheckAccess(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    checkWappAccessRequestDetails(body: WAccessRequests | undefined): Observable<WAccessRequestsBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/check-wapp-access-request-details";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckWappAccessRequestDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckWappAccessRequestDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WAccessRequestsBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WAccessRequestsBaseResponse>;
        }));
    }

    protected processCheckWappAccessRequestDetails(response: HttpResponseBase): Observable<WAccessRequestsBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WAccessRequestsBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WAccessRequestsBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    checkWuserDetails(body: WUsers | undefined): Observable<WAccessRequestsBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/check-wuser-details";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckWuserDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckWuserDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WAccessRequestsBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WAccessRequestsBaseResponse>;
        }));
    }

    protected processCheckWuserDetails(response: HttpResponseBase): Observable<WAccessRequestsBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WAccessRequestsBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WAccessRequestsBaseResponse>(null as any);
    }

    /**
     * @param wUserLoginID (optional) 
     * @param sessionEndTimeFlag (optional) 
     * @param sessionTimeOutFlag (optional) 
     * @return OK
     */
    updateUserLoginDetails(wUserLoginID: number | undefined, sessionEndTimeFlag: boolean | undefined, sessionTimeOutFlag: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/AccessRequest/update-user-login-details?";
        if (wUserLoginID === null)
            throw new Error("The parameter 'wUserLoginID' cannot be null.");
        else if (wUserLoginID !== undefined)
            url_ += "wUserLoginID=" + encodeURIComponent("" + wUserLoginID) + "&";
        if (sessionEndTimeFlag === null)
            throw new Error("The parameter 'sessionEndTimeFlag' cannot be null.");
        else if (sessionEndTimeFlag !== undefined)
            url_ += "sessionEndTimeFlag=" + encodeURIComponent("" + sessionEndTimeFlag) + "&";
        if (sessionTimeOutFlag === null)
            throw new Error("The parameter 'sessionTimeOutFlag' cannot be null.");
        else if (sessionTimeOutFlag !== undefined)
            url_ += "sessionTimeOutFlag=" + encodeURIComponent("" + sessionTimeOutFlag) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserLoginDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserLoginDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateUserLoginDetails(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param wAccessRequestID (optional) 
     * @return OK
     */
    getWaccessRequestDetails(wAccessRequestID: number | undefined): Observable<WAccessRequestsBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/get-waccess-request-details?";
        if (wAccessRequestID === null)
            throw new Error("The parameter 'wAccessRequestID' cannot be null.");
        else if (wAccessRequestID !== undefined)
            url_ += "wAccessRequestID=" + encodeURIComponent("" + wAccessRequestID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWaccessRequestDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWaccessRequestDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WAccessRequestsBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WAccessRequestsBaseResponse>;
        }));
    }

    protected processGetWaccessRequestDetails(response: HttpResponseBase): Observable<WAccessRequestsBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WAccessRequestsBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WAccessRequestsBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    checkUserAnswerForResetPassword(body: UserQuestionAnswers | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/check-user-answer-for-reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckUserAnswerForResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckUserAnswerForResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processCheckUserAnswerForResetPassword(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    resetsPassword(body: string | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/resets-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetsPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetsPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processResetsPassword(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @param wAccessRequestID (optional) 
     * @param body (optional) 
     * @return OK
     */
    checkOldPassword(wAccessRequestID: number | undefined, body: string | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/check-old-password?";
        if (wAccessRequestID === null)
            throw new Error("The parameter 'wAccessRequestID' cannot be null.");
        else if (wAccessRequestID !== undefined)
            url_ += "wAccessRequestID=" + encodeURIComponent("" + wAccessRequestID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckOldPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckOldPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processCheckOldPassword(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @param roleId (optional) 
     * @return OK
     */
    getUserDetailByRole(roleId: number | undefined): Observable<WUsersDtoBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/get-user-detail-by-role?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDetailByRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDetailByRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WUsersDtoBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WUsersDtoBaseResponse>;
        }));
    }

    protected processGetUserDetailByRole(response: HttpResponseBase): Observable<WUsersDtoBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WUsersDtoBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WUsersDtoBaseResponse>(null as any);
    }

    /**
     * @param roleId (optional) 
     * @return OK
     */
    activateUserByRole(roleId: number | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/activate-user-by-role?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateUserByRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateUserByRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processActivateUserByRole(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @param wUserLoginID (optional) 
     * @return OK
     */
    isSessionTerminated(wUserLoginID: number | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/is-session-terminated?";
        if (wUserLoginID === null)
            throw new Error("The parameter 'wUserLoginID' cannot be null.");
        else if (wUserLoginID !== undefined)
            url_ += "wUserLoginID=" + encodeURIComponent("" + wUserLoginID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsSessionTerminated(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsSessionTerminated(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processIsSessionTerminated(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @param sessionID (optional) 
     * @return OK
     */
    isSessionActive(sessionID: number | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/is-session-active?";
        if (sessionID === null)
            throw new Error("The parameter 'sessionID' cannot be null.");
        else if (sessionID !== undefined)
            url_ += "sessionID=" + encodeURIComponent("" + sessionID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsSessionActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsSessionActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processIsSessionActive(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    isUserRegistered(body: WUsers | undefined): Observable<WAccessRequestsBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/is-user-registered";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUserRegistered(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUserRegistered(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WAccessRequestsBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WAccessRequestsBaseResponse>;
        }));
    }

    protected processIsUserRegistered(response: HttpResponseBase): Observable<WAccessRequestsBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WAccessRequestsBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WAccessRequestsBaseResponse>(null as any);
    }

    /**
     * @param emailAddress (optional) 
     * @param iPaddress (optional) 
     * @param requestToken (optional) 
     * @return OK
     */
    insertResetPasswordAudit(emailAddress: string | undefined, iPaddress: string | undefined, requestToken: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/AccessRequest/insert-reset-password-audit?";
        if (emailAddress === null)
            throw new Error("The parameter 'emailAddress' cannot be null.");
        else if (emailAddress !== undefined)
            url_ += "emailAddress=" + encodeURIComponent("" + emailAddress) + "&";
        if (iPaddress === null)
            throw new Error("The parameter 'iPaddress' cannot be null.");
        else if (iPaddress !== undefined)
            url_ += "IPaddress=" + encodeURIComponent("" + iPaddress) + "&";
        if (requestToken === null)
            throw new Error("The parameter 'requestToken' cannot be null.");
        else if (requestToken !== undefined)
            url_ += "requestToken=" + encodeURIComponent("" + requestToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertResetPasswordAudit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertResetPasswordAudit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processInsertResetPasswordAudit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param emailAddress (optional) 
     * @param requestToken (optional) 
     * @return OK
     */
    checkResetPasswordToken(emailAddress: string | undefined, requestToken: string | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/check-reset-password-token?";
        if (emailAddress === null)
            throw new Error("The parameter 'emailAddress' cannot be null.");
        else if (emailAddress !== undefined)
            url_ += "emailAddress=" + encodeURIComponent("" + emailAddress) + "&";
        if (requestToken === null)
            throw new Error("The parameter 'requestToken' cannot be null.");
        else if (requestToken !== undefined)
            url_ += "requestToken=" + encodeURIComponent("" + requestToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckResetPasswordToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckResetPasswordToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processCheckResetPasswordToken(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    getUsersNotLoggedInToSystem(): Observable<WUserLoginsListBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/get-users-not-logged-in-to-system";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersNotLoggedInToSystem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersNotLoggedInToSystem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WUserLoginsListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WUserLoginsListBaseResponse>;
        }));
    }

    protected processGetUsersNotLoggedInToSystem(response: HttpResponseBase): Observable<WUserLoginsListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WUserLoginsListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WUserLoginsListBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    getEmailAddress(): Observable<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/get-email-address";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringBaseResponse>;
        }));
    }

    protected processGetEmailAddress(response: HttpResponseBase): Observable<StringBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    getPendingItemForLoggedInUser(): Observable<UserPendingItemsListBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/get-pending-item-for-logged-in-User";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPendingItemForLoggedInUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPendingItemForLoggedInUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserPendingItemsListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserPendingItemsListBaseResponse>;
        }));
    }

    protected processGetPendingItemForLoggedInUser(response: HttpResponseBase): Observable<UserPendingItemsListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserPendingItemsListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserPendingItemsListBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    initiateSignOffTask(body: SignOffDetails | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/initiate-sign-off-task";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitiateSignOffTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitiateSignOffTask(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processInitiateSignOffTask(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @param userName (optional) 
     * @param password (optional) 
     * @return OK
     */
    validateSignOffLogin(userName: string | undefined, password: string | undefined): Observable<Int32BaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/validate-sign-off-login?";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        if (password === null)
            throw new Error("The parameter 'password' cannot be null.");
        else if (password !== undefined)
            url_ += "password=" + encodeURIComponent("" + password) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateSignOffLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateSignOffLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int32BaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int32BaseResponse>;
        }));
    }

    protected processValidateSignOffLogin(response: HttpResponseBase): Observable<Int32BaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int32BaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int32BaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateSignOffTask(body: SignOffDetails | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/update-sign-off-task";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSignOffTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSignOffTask(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processUpdateSignOffTask(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @param objectSOStatusID (optional) 
     * @return OK
     */
    finishSignOffTask(objectSOStatusID: number | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/finish-sign-off-task?";
        if (objectSOStatusID === null)
            throw new Error("The parameter 'objectSOStatusID' cannot be null.");
        else if (objectSOStatusID !== undefined)
            url_ += "objectSOStatusID=" + encodeURIComponent("" + objectSOStatusID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFinishSignOffTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFinishSignOffTask(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processFinishSignOffTask(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    insertUpdateObjectSoTaskStatus(body: ObjectSOTaskStatusDto | undefined): Observable<Int32BaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/insert-update-object-so-task-status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertUpdateObjectSoTaskStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertUpdateObjectSoTaskStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int32BaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int32BaseResponse>;
        }));
    }

    protected processInsertUpdateObjectSoTaskStatus(response: HttpResponseBase): Observable<Int32BaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int32BaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int32BaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    invalidateObjSoTaskstatus(body: ObjectSOTaskStatusDto | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/AccessRequest/invalidate-obj-so-taskstatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvalidateObjSoTaskstatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvalidateObjSoTaskstatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processInvalidateObjSoTaskstatus(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    getEssFirms(): Observable<FirmDtoListBaseResponse> {
        let url_ = this.baseUrl + "/api/AdminRequest/get-ess-firms";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEssFirms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEssFirms(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FirmDtoListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FirmDtoListBaseResponse>;
        }));
    }

    protected processGetEssFirms(response: HttpResponseBase): Observable<FirmDtoListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FirmDtoListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FirmDtoListBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateWfirmStatus(body: FirmDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/AdminRequest/update-wfirm-status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateWfirmStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateWfirmStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateWfirmStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAdminUserList(body: WAdminAccessRequestsDto | undefined): Observable<WUsersDtoListBaseResponse> {
        let url_ = this.baseUrl + "/api/AdminRequest/get-admin-user-list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdminUserList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdminUserList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WUsersDtoListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WUsersDtoListBaseResponse>;
        }));
    }

    protected processGetAdminUserList(response: HttpResponseBase): Observable<WUsersDtoListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WUsersDtoListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WUsersDtoListBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    insertUpdateApplicationData(body: ApplicationDataDto | undefined): Observable<Int32BaseResponse> {
        let url_ = this.baseUrl + "/api/AIApplications/insert-update-application-data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertUpdateApplicationData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertUpdateApplicationData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int32BaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int32BaseResponse>;
        }));
    }

    protected processInsertUpdateApplicationData(response: HttpResponseBase): Observable<Int32BaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int32BaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int32BaseResponse>(null as any);
    }

    /**
     * @param qfcNumber (optional) 
     * @param aiNumber (optional) 
     * @param formTypeID (optional) 
     * @param windApplicationID (optional) 
     * @param body (optional) 
     * @return OK
     */
    isDuplicateApplication(qfcNumber: string | undefined, aiNumber: string | undefined, formTypeID: number | undefined, windApplicationID: number | undefined, body: number[] | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/AIApplications/is-duplicate-application?";
        if (qfcNumber === null)
            throw new Error("The parameter 'qfcNumber' cannot be null.");
        else if (qfcNumber !== undefined)
            url_ += "qfcNumber=" + encodeURIComponent("" + qfcNumber) + "&";
        if (aiNumber === null)
            throw new Error("The parameter 'aiNumber' cannot be null.");
        else if (aiNumber !== undefined)
            url_ += "aiNumber=" + encodeURIComponent("" + aiNumber) + "&";
        if (formTypeID === null)
            throw new Error("The parameter 'formTypeID' cannot be null.");
        else if (formTypeID !== undefined)
            url_ += "formTypeID=" + encodeURIComponent("" + formTypeID) + "&";
        if (windApplicationID === null)
            throw new Error("The parameter 'windApplicationID' cannot be null.");
        else if (windApplicationID !== undefined)
            url_ += "windApplicationID=" + encodeURIComponent("" + windApplicationID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsDuplicateApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsDuplicateApplication(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processIsDuplicateApplication(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @param appID (optional) 
     * @return OK
     */
    getIndApplDetails(appID: number | undefined): Observable<WApplicationDetailDtoListBaseResponse> {
        let url_ = this.baseUrl + "/api/AIApplications/get-ind-appl-details?";
        if (appID === null)
            throw new Error("The parameter 'appID' cannot be null.");
        else if (appID !== undefined)
            url_ += "appID=" + encodeURIComponent("" + appID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIndApplDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIndApplDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WApplicationDetailDtoListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WApplicationDetailDtoListBaseResponse>;
        }));
    }

    protected processGetIndApplDetails(response: HttpResponseBase): Observable<WApplicationDetailDtoListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WApplicationDetailDtoListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WApplicationDetailDtoListBaseResponse>(null as any);
    }

    /**
     * @param appID (optional) 
     * @return OK
     */
    getIndContactDetail(appID: number | undefined): Observable<IndividualDetailsDtoBaseResponse> {
        let url_ = this.baseUrl + "/api/AIApplications/get-ind-contact-detail?";
        if (appID === null)
            throw new Error("The parameter 'appID' cannot be null.");
        else if (appID !== undefined)
            url_ += "appID=" + encodeURIComponent("" + appID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIndContactDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIndContactDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IndividualDetailsDtoBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IndividualDetailsDtoBaseResponse>;
        }));
    }

    protected processGetIndContactDetail(response: HttpResponseBase): Observable<IndividualDetailsDtoBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IndividualDetailsDtoBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IndividualDetailsDtoBaseResponse>(null as any);
    }

    /**
     * @param applicationID (optional) 
     * @return OK
     */
    getIndividualDetails(applicationID: number | undefined): Observable<IndividualDetailsDtoBaseResponse> {
        let url_ = this.baseUrl + "/api/AIApplications/get-individual-details?";
        if (applicationID === null)
            throw new Error("The parameter 'applicationID' cannot be null.");
        else if (applicationID !== undefined)
            url_ += "ApplicationID=" + encodeURIComponent("" + applicationID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIndividualDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIndividualDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IndividualDetailsDtoBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IndividualDetailsDtoBaseResponse>;
        }));
    }

    protected processGetIndividualDetails(response: HttpResponseBase): Observable<IndividualDetailsDtoBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IndividualDetailsDtoBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IndividualDetailsDtoBaseResponse>(null as any);
    }

    /**
     * @param allAIs (optional) 
     * @param applicationId (optional) 
     * @param qfcNumebr (optional) 
     * @return OK
     */
    getOpenAis(allAIs: string | undefined, applicationId: number | undefined, qfcNumebr: number | undefined): Observable<IndividualDetailsDtoListBaseResponse> {
        let url_ = this.baseUrl + "/api/AIApplications/get-open-ais?";
        if (allAIs === null)
            throw new Error("The parameter 'allAIs' cannot be null.");
        else if (allAIs !== undefined)
            url_ += "allAIs=" + encodeURIComponent("" + allAIs) + "&";
        if (applicationId === null)
            throw new Error("The parameter 'applicationId' cannot be null.");
        else if (applicationId !== undefined)
            url_ += "applicationId=" + encodeURIComponent("" + applicationId) + "&";
        if (qfcNumebr === null)
            throw new Error("The parameter 'qfcNumebr' cannot be null.");
        else if (qfcNumebr !== undefined)
            url_ += "qfcNumebr=" + encodeURIComponent("" + qfcNumebr) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOpenAis(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOpenAis(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IndividualDetailsDtoListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IndividualDetailsDtoListBaseResponse>;
        }));
    }

    protected processGetOpenAis(response: HttpResponseBase): Observable<IndividualDetailsDtoListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IndividualDetailsDtoListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IndividualDetailsDtoListBaseResponse>(null as any);
    }

    /**
     * @param applicationID (optional) 
     * @return OK
     */
    getControlledFunctions(applicationID: number | undefined): Observable<ControlledFunctionDtoListBaseResponse> {
        let url_ = this.baseUrl + "/api/AIApplications/get-controlled-functions?";
        if (applicationID === null)
            throw new Error("The parameter 'applicationID' cannot be null.");
        else if (applicationID !== undefined)
            url_ += "ApplicationID=" + encodeURIComponent("" + applicationID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetControlledFunctions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetControlledFunctions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ControlledFunctionDtoListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ControlledFunctionDtoListBaseResponse>;
        }));
    }

    protected processGetControlledFunctions(response: HttpResponseBase): Observable<ControlledFunctionDtoListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ControlledFunctionDtoListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ControlledFunctionDtoListBaseResponse>(null as any);
    }

    /**
     * @param applicationID (optional) 
     * @return OK
     */
    getFunctionActivity(applicationID: number | undefined): Observable<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/AIApplications/get-function-activity?";
        if (applicationID === null)
            throw new Error("The parameter 'applicationID' cannot be null.");
        else if (applicationID !== undefined)
            url_ += "ApplicationID=" + encodeURIComponent("" + applicationID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFunctionActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFunctionActivity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringBaseResponse>;
        }));
    }

    protected processGetFunctionActivity(response: HttpResponseBase): Observable<StringBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringBaseResponse>(null as any);
    }

    /**
     * @param applicationId (optional) 
     * @return OK
     */
    deleteApplication(applicationId: number | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/AIApplications/delete-application?";
        if (applicationId === null)
            throw new Error("The parameter 'applicationId' cannot be null.");
        else if (applicationId !== undefined)
            url_ += "applicationId=" + encodeURIComponent("" + applicationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteApplication(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processDeleteApplication(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @param appId (optional) 
     * @param isPrimaryDocFlag (optional) 
     * @return OK
     */
    getAttachments(appId: number | undefined, isPrimaryDocFlag: boolean | undefined): Observable<AttachmentDtoListBaseResponse> {
        let url_ = this.baseUrl + "/api/Attachments/get-attachments?";
        if (appId === null)
            throw new Error("The parameter 'appId' cannot be null.");
        else if (appId !== undefined)
            url_ += "appId=" + encodeURIComponent("" + appId) + "&";
        if (isPrimaryDocFlag === null)
            throw new Error("The parameter 'isPrimaryDocFlag' cannot be null.");
        else if (isPrimaryDocFlag !== undefined)
            url_ += "isPrimaryDocFlag=" + encodeURIComponent("" + isPrimaryDocFlag) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAttachments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAttachments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentDtoListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentDtoListBaseResponse>;
        }));
    }

    protected processGetAttachments(response: HttpResponseBase): Observable<AttachmentDtoListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentDtoListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttachmentDtoListBaseResponse>(null as any);
    }

    /**
     * @param appId (optional) 
     * @param isPrimaryDocFlag (optional) 
     * @return OK
     */
    getAttachedFiles(appId: number | undefined, isPrimaryDocFlag: boolean | undefined): Observable<AttachmentDtoListBaseResponse> {
        let url_ = this.baseUrl + "/api/Attachments/get-attached-files?";
        if (appId === null)
            throw new Error("The parameter 'appId' cannot be null.");
        else if (appId !== undefined)
            url_ += "appId=" + encodeURIComponent("" + appId) + "&";
        if (isPrimaryDocFlag === null)
            throw new Error("The parameter 'isPrimaryDocFlag' cannot be null.");
        else if (isPrimaryDocFlag !== undefined)
            url_ += "isPrimaryDocFlag=" + encodeURIComponent("" + isPrimaryDocFlag) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAttachedFiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAttachedFiles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentDtoListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentDtoListBaseResponse>;
        }));
    }

    protected processGetAttachedFiles(response: HttpResponseBase): Observable<AttachmentDtoListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentDtoListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttachmentDtoListBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    getEmptyAttachment(): Observable<AttachmentDtoBaseResponse> {
        let url_ = this.baseUrl + "/api/Attachments/get-empty-attachment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmptyAttachment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmptyAttachment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentDtoBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentDtoBaseResponse>;
        }));
    }

    protected processGetEmptyAttachment(response: HttpResponseBase): Observable<AttachmentDtoBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentDtoBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttachmentDtoBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getRptSchAttachments(body: AttachmentDto | undefined): Observable<AttachmentDtoListBaseResponse> {
        let url_ = this.baseUrl + "/api/Attachments/get-rpt-sch-attachments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRptSchAttachments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRptSchAttachments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentDtoListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentDtoListBaseResponse>;
        }));
    }

    protected processGetRptSchAttachments(response: HttpResponseBase): Observable<AttachmentDtoListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentDtoListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttachmentDtoListBaseResponse>(null as any);
    }

    /**
     * @param wObjAttachementID (optional) 
     * @param wObjectID (optional) 
     * @param wObjectInstanceID (optional) 
     * @param wObjectInstanceRevNum (optional) 
     * @param isPrimaryAttachment (optional) 
     * @return OK
     */
    getObjAttachments(wObjAttachementID: number | undefined, wObjectID: number | undefined, wObjectInstanceID: number | undefined, wObjectInstanceRevNum: number | undefined, isPrimaryAttachment: boolean | undefined): Observable<AttachmentDtoListBaseResponse> {
        let url_ = this.baseUrl + "/api/Attachments/get-obj-attachments?";
        if (wObjAttachementID === null)
            throw new Error("The parameter 'wObjAttachementID' cannot be null.");
        else if (wObjAttachementID !== undefined)
            url_ += "WObjAttachementID=" + encodeURIComponent("" + wObjAttachementID) + "&";
        if (wObjectID === null)
            throw new Error("The parameter 'wObjectID' cannot be null.");
        else if (wObjectID !== undefined)
            url_ += "WObjectID=" + encodeURIComponent("" + wObjectID) + "&";
        if (wObjectInstanceID === null)
            throw new Error("The parameter 'wObjectInstanceID' cannot be null.");
        else if (wObjectInstanceID !== undefined)
            url_ += "WObjectInstanceID=" + encodeURIComponent("" + wObjectInstanceID) + "&";
        if (wObjectInstanceRevNum === null)
            throw new Error("The parameter 'wObjectInstanceRevNum' cannot be null.");
        else if (wObjectInstanceRevNum !== undefined)
            url_ += "WObjectInstanceRevNum=" + encodeURIComponent("" + wObjectInstanceRevNum) + "&";
        if (isPrimaryAttachment === null)
            throw new Error("The parameter 'isPrimaryAttachment' cannot be null.");
        else if (isPrimaryAttachment !== undefined)
            url_ += "isPrimaryAttachment=" + encodeURIComponent("" + isPrimaryAttachment) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObjAttachments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObjAttachments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentDtoListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentDtoListBaseResponse>;
        }));
    }

    protected processGetObjAttachments(response: HttpResponseBase): Observable<AttachmentDtoListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentDtoListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttachmentDtoListBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    saveObjAttachments(body: AttachmentDto[] | undefined): Observable<AttachmentDtoListBaseResponse> {
        let url_ = this.baseUrl + "/api/Attachments/save-obj-attachments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveObjAttachments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveObjAttachments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentDtoListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentDtoListBaseResponse>;
        }));
    }

    protected processSaveObjAttachments(response: HttpResponseBase): Observable<AttachmentDtoListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentDtoListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttachmentDtoListBaseResponse>(null as any);
    }

    /**
     * @param wIndAttID (optional) 
     * @return OK
     */
    deleteObjAttachment(wIndAttID: number | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/Attachments/delete-obj-attachment?";
        if (wIndAttID === null)
            throw new Error("The parameter 'wIndAttID' cannot be null.");
        else if (wIndAttID !== undefined)
            url_ += "WIndAttID=" + encodeURIComponent("" + wIndAttID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteObjAttachment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteObjAttachment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processDeleteObjAttachment(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @param pWObjectID (optional) 
     * @param pWObjInstanceID (optional) 
     * @param body (optional) 
     * @return OK
     */
    deleteAllObjAttachments(pWObjectID: number | undefined, pWObjInstanceID: number | undefined, body: AttachmentDto[] | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/Attachments/delete-all-obj-attachments?";
        if (pWObjectID === null)
            throw new Error("The parameter 'pWObjectID' cannot be null.");
        else if (pWObjectID !== undefined)
            url_ += "pWObjectID=" + encodeURIComponent("" + pWObjectID) + "&";
        if (pWObjInstanceID === null)
            throw new Error("The parameter 'pWObjInstanceID' cannot be null.");
        else if (pWObjInstanceID !== undefined)
            url_ += "pWObjInstanceID=" + encodeURIComponent("" + pWObjInstanceID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllObjAttachments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllObjAttachments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processDeleteAllObjAttachments(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    getEmptyObjAttachment(): Observable<AttachmentDtoBaseResponse> {
        let url_ = this.baseUrl + "/api/Attachments/get-empty-obj-attachment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmptyObjAttachment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmptyObjAttachment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentDtoBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentDtoBaseResponse>;
        }));
    }

    protected processGetEmptyObjAttachment(response: HttpResponseBase): Observable<AttachmentDtoBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentDtoBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttachmentDtoBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateObjAttachmentStatus(body: AttachmentDto[] | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/Attachments/update-obj-attachment-status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateObjAttachmentStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateObjAttachmentStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processUpdateObjAttachmentStatus(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @param pDocTypeID (optional) 
     * @return OK
     */
    getDocTypeDec(pDocTypeID: number | undefined): Observable<AttachmentDtoBaseResponse> {
        let url_ = this.baseUrl + "/api/Attachments/get-doc-type-dec?";
        if (pDocTypeID === null)
            throw new Error("The parameter 'pDocTypeID' cannot be null.");
        else if (pDocTypeID !== undefined)
            url_ += "pDocTypeID=" + encodeURIComponent("" + pDocTypeID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocTypeDec(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocTypeDec(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentDtoBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentDtoBaseResponse>;
        }));
    }

    protected processGetDocTypeDec(response: HttpResponseBase): Observable<AttachmentDtoBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentDtoBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttachmentDtoBaseResponse>(null as any);
    }

    /**
     * @param pAppID (optional) 
     * @return OK
     */
    getPrimaryAttachments(pAppID: number | undefined): Observable<AttachmentDtoBaseResponse> {
        let url_ = this.baseUrl + "/api/Attachments/get-primary-attachments?";
        if (pAppID === null)
            throw new Error("The parameter 'pAppID' cannot be null.");
        else if (pAppID !== undefined)
            url_ += "pAppID=" + encodeURIComponent("" + pAppID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrimaryAttachments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrimaryAttachments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentDtoBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentDtoBaseResponse>;
        }));
    }

    protected processGetPrimaryAttachments(response: HttpResponseBase): Observable<AttachmentDtoBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentDtoBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttachmentDtoBaseResponse>(null as any);
    }

    /**
     * @param attachmentID (optional) 
     * @param attachmentStatusTypeID (optional) 
     * @return OK
     */
    checkAttachmentStatus(attachmentID: number | undefined, attachmentStatusTypeID: number | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/Attachments/check-attachment-status?";
        if (attachmentID === null)
            throw new Error("The parameter 'attachmentID' cannot be null.");
        else if (attachmentID !== undefined)
            url_ += "attachmentID=" + encodeURIComponent("" + attachmentID) + "&";
        if (attachmentStatusTypeID === null)
            throw new Error("The parameter 'attachmentStatusTypeID' cannot be null.");
        else if (attachmentStatusTypeID !== undefined)
            url_ += "attachmentStatusTypeID=" + encodeURIComponent("" + attachmentStatusTypeID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckAttachmentStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckAttachmentStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processCheckAttachmentStatus(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getHistoryDetails(body: HistoryDetailsDto | undefined): Observable<AttachmentDtoListBaseResponse> {
        let url_ = this.baseUrl + "/api/Attachments/get-history-details";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHistoryDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHistoryDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentDtoListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentDtoListBaseResponse>;
        }));
    }

    protected processGetHistoryDetails(response: HttpResponseBase): Observable<AttachmentDtoListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentDtoListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttachmentDtoListBaseResponse>(null as any);
    }

    /**
     * @param file (optional) 
     * @param fileLoction (optional) 
     * @param pFileName (optional) 
     * @return OK
     */
    uploadToFolder(file: FileParameter | undefined, fileLoction: string | undefined, pFileName: string | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/Attachments/upload-to-folder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");
        if (fileLoction === null || fileLoction === undefined)
            throw new Error("The parameter 'fileLoction' cannot be null.");
        else
            content_.append("FileLoction", fileLoction.toString());
        if (pFileName === null || pFileName === undefined)
            throw new Error("The parameter 'pFileName' cannot be null.");
        else
            content_.append("pFileName", pFileName.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadToFolder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadToFolder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processUploadToFolder(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @param pFileName (optional) 
     * @param fileLocation (optional) 
     * @return OK
     */
    downloadFile(pFileName: string | undefined, fileLocation: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Attachments/download-file?";
        if (pFileName === null)
            throw new Error("The parameter 'pFileName' cannot be null.");
        else if (pFileName !== undefined)
            url_ += "pFileName=" + encodeURIComponent("" + pFileName) + "&";
        if (fileLocation === null)
            throw new Error("The parameter 'fileLocation' cannot be null.");
        else if (fileLocation !== undefined)
            url_ += "fileLocation=" + encodeURIComponent("" + fileLocation) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDownloadFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param pFileName (optional) 
     * @param fileLocation (optional) 
     * @return OK
     */
    deleteFile(pFileName: string | undefined, fileLocation: string | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/Attachments/delete-file?";
        if (pFileName === null)
            throw new Error("The parameter 'pFileName' cannot be null.");
        else if (pFileName !== undefined)
            url_ += "pFileName=" + encodeURIComponent("" + pFileName) + "&";
        if (fileLocation === null)
            throw new Error("The parameter 'fileLocation' cannot be null.");
        else if (fileLocation !== undefined)
            url_ += "FileLocation=" + encodeURIComponent("" + fileLocation) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processDeleteFile(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    getAllowedExtensions(): Observable<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/Attachments/get-allowed-extensions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllowedExtensions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllowedExtensions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringBaseResponse>;
        }));
    }

    protected processGetAllowedExtensions(response: HttpResponseBase): Observable<StringBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringBaseResponse>(null as any);
    }

    /**
     * @param objectID (optional) 
     * @param objectInstanceID (optional) 
     * @param docTypeID (optional) 
     * @return OK
     */
    getFileLocation(objectID: number | undefined, objectInstanceID: number | undefined, docTypeID: number | undefined): Observable<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/Attachments/get-file-location?";
        if (objectID === null)
            throw new Error("The parameter 'objectID' cannot be null.");
        else if (objectID !== undefined)
            url_ += "objectID=" + encodeURIComponent("" + objectID) + "&";
        if (objectInstanceID === null)
            throw new Error("The parameter 'objectInstanceID' cannot be null.");
        else if (objectInstanceID !== undefined)
            url_ += "objectInstanceID=" + encodeURIComponent("" + objectInstanceID) + "&";
        if (docTypeID === null)
            throw new Error("The parameter 'docTypeID' cannot be null.");
        else if (docTypeID !== undefined)
            url_ += "docTypeID=" + encodeURIComponent("" + docTypeID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFileLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFileLocation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringBaseResponse>;
        }));
    }

    protected processGetFileLocation(response: HttpResponseBase): Observable<StringBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringBaseResponse>(null as any);
    }

    /**
     * @param formTypeID (optional) 
     * @param docTypeID (optional) 
     * @param docType (optional) 
     * @param primaryDocStatusTypeID (optional) 
     * @param pFilePath (optional) 
     * @param pFileName (optional) 
     * @param pFileURI (optional) 
     * @param objectInstanceID (optional) 
     * @param objectID (optional) 
     * @param primaryDocWObjAttachementID (optional) 
     * @param objectInstanceRevNum (optional) 
     * @return OK
     */
    savePrimaryDocument(formTypeID: number | undefined, docTypeID: number | undefined, docType: boolean | undefined, primaryDocStatusTypeID: number | undefined, pFilePath: string | undefined, pFileName: string | undefined, pFileURI: string | undefined, objectInstanceID: number | undefined, objectID: number | undefined, primaryDocWObjAttachementID: number | undefined, objectInstanceRevNum: number | undefined): Observable<SavePrimaryDocumentResponseBaseResponse> {
        let url_ = this.baseUrl + "/api/Attachments/save-primary-document?";
        if (formTypeID === null)
            throw new Error("The parameter 'formTypeID' cannot be null.");
        else if (formTypeID !== undefined)
            url_ += "formTypeID=" + encodeURIComponent("" + formTypeID) + "&";
        if (docTypeID === null)
            throw new Error("The parameter 'docTypeID' cannot be null.");
        else if (docTypeID !== undefined)
            url_ += "docTypeID=" + encodeURIComponent("" + docTypeID) + "&";
        if (docType === null)
            throw new Error("The parameter 'docType' cannot be null.");
        else if (docType !== undefined)
            url_ += "DocType=" + encodeURIComponent("" + docType) + "&";
        if (primaryDocStatusTypeID === null)
            throw new Error("The parameter 'primaryDocStatusTypeID' cannot be null.");
        else if (primaryDocStatusTypeID !== undefined)
            url_ += "primaryDocStatusTypeID=" + encodeURIComponent("" + primaryDocStatusTypeID) + "&";
        if (pFilePath === null)
            throw new Error("The parameter 'pFilePath' cannot be null.");
        else if (pFilePath !== undefined)
            url_ += "pFilePath=" + encodeURIComponent("" + pFilePath) + "&";
        if (pFileName === null)
            throw new Error("The parameter 'pFileName' cannot be null.");
        else if (pFileName !== undefined)
            url_ += "pFileName=" + encodeURIComponent("" + pFileName) + "&";
        if (pFileURI === null)
            throw new Error("The parameter 'pFileURI' cannot be null.");
        else if (pFileURI !== undefined)
            url_ += "pFileURI=" + encodeURIComponent("" + pFileURI) + "&";
        if (objectInstanceID === null)
            throw new Error("The parameter 'objectInstanceID' cannot be null.");
        else if (objectInstanceID !== undefined)
            url_ += "objectInstanceID=" + encodeURIComponent("" + objectInstanceID) + "&";
        if (objectID === null)
            throw new Error("The parameter 'objectID' cannot be null.");
        else if (objectID !== undefined)
            url_ += "objectID=" + encodeURIComponent("" + objectID) + "&";
        if (primaryDocWObjAttachementID === null)
            throw new Error("The parameter 'primaryDocWObjAttachementID' cannot be null.");
        else if (primaryDocWObjAttachementID !== undefined)
            url_ += "primaryDocWObjAttachementID=" + encodeURIComponent("" + primaryDocWObjAttachementID) + "&";
        if (objectInstanceRevNum === null)
            throw new Error("The parameter 'objectInstanceRevNum' cannot be null.");
        else if (objectInstanceRevNum !== undefined)
            url_ += "objectInstanceRevNum=" + encodeURIComponent("" + objectInstanceRevNum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePrimaryDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePrimaryDocument(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SavePrimaryDocumentResponseBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SavePrimaryDocumentResponseBaseResponse>;
        }));
    }

    protected processSavePrimaryDocument(response: HttpResponseBase): Observable<SavePrimaryDocumentResponseBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SavePrimaryDocumentResponseBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SavePrimaryDocumentResponseBaseResponse>(null as any);
    }

    /**
     * @param formType (optional) 
     * @param objectId (optional) 
     * @return OK
     */
    getDocSubTypes(formType: number | undefined, objectId: string | undefined): Observable<AttachmentDtoListBaseResponse> {
        let url_ = this.baseUrl + "/api/Attachments/get-doc-sub-types?";
        if (formType === null)
            throw new Error("The parameter 'formType' cannot be null.");
        else if (formType !== undefined)
            url_ += "formType=" + encodeURIComponent("" + formType) + "&";
        if (objectId === null)
            throw new Error("The parameter 'objectId' cannot be null.");
        else if (objectId !== undefined)
            url_ += "ObjectId=" + encodeURIComponent("" + objectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocSubTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocSubTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentDtoListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentDtoListBaseResponse>;
        }));
    }

    protected processGetDocSubTypes(response: HttpResponseBase): Observable<AttachmentDtoListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentDtoListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttachmentDtoListBaseResponse>(null as any);
    }

    /**
     * @param wObjAttachementID (optional) 
     * @param fileName (optional) 
     * @param filePath (optional) 
     * @param docType (optional) 
     * @return OK
     */
    deleteAttachment(wObjAttachementID: number | undefined, fileName: string | undefined, filePath: string | undefined, docType: boolean | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/Attachments/delete-attachment?";
        if (wObjAttachementID === null)
            throw new Error("The parameter 'wObjAttachementID' cannot be null.");
        else if (wObjAttachementID !== undefined)
            url_ += "wObjAttachementID=" + encodeURIComponent("" + wObjAttachementID) + "&";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (filePath === null)
            throw new Error("The parameter 'filePath' cannot be null.");
        else if (filePath !== undefined)
            url_ += "filePath=" + encodeURIComponent("" + filePath) + "&";
        if (docType === null)
            throw new Error("The parameter 'docType' cannot be null.");
        else if (docType !== undefined)
            url_ += "docType=" + encodeURIComponent("" + docType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAttachment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAttachment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processDeleteAttachment(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    getObjectTaskStatus(): Observable<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/GetObjectTaskStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObjectTaskStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObjectTaskStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringObjectDictionaryListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringObjectDictionaryListBaseResponse>;
        }));
    }

    protected processGetObjectTaskStatus(response: HttpResponseBase): Observable<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    insertUpdateObjTaskStatus(body: ObjTasks | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/InsertUpdateObjTaskStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertUpdateObjTaskStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertUpdateObjTaskStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processInsertUpdateObjTaskStatus(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    getSubmittedApplications(): Observable<PendingItemsDtoListBaseResponse> {
        let url_ = this.baseUrl + "/api/GenSubmission/get-submitted-applications";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubmittedApplications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubmittedApplications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PendingItemsDtoListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PendingItemsDtoListBaseResponse>;
        }));
    }

    protected processGetSubmittedApplications(response: HttpResponseBase): Observable<PendingItemsDtoListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PendingItemsDtoListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PendingItemsDtoListBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    getCompletedApplications(): Observable<PendingItemsDtoListBaseResponse> {
        let url_ = this.baseUrl + "/api/GenSubmission/get-completed-applications";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompletedApplications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompletedApplications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PendingItemsDtoListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PendingItemsDtoListBaseResponse>;
        }));
    }

    protected processGetCompletedApplications(response: HttpResponseBase): Observable<PendingItemsDtoListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PendingItemsDtoListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PendingItemsDtoListBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    getPendingApplications(): Observable<PendingItemsDtoListBaseResponse> {
        let url_ = this.baseUrl + "/api/GenSubmission/get-pending-applications";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPendingApplications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPendingApplications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PendingItemsDtoListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PendingItemsDtoListBaseResponse>;
        }));
    }

    protected processGetPendingApplications(response: HttpResponseBase): Observable<PendingItemsDtoListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PendingItemsDtoListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PendingItemsDtoListBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    getPendingItems(): Observable<PendingItemsDtoListBaseResponse> {
        let url_ = this.baseUrl + "/api/GenSubmission/get-pending-items";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPendingItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPendingItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PendingItemsDtoListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PendingItemsDtoListBaseResponse>;
        }));
    }

    protected processGetPendingItems(response: HttpResponseBase): Observable<PendingItemsDtoListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PendingItemsDtoListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PendingItemsDtoListBaseResponse>(null as any);
    }

    /**
     * @param applicationID (optional) 
     * @return OK
     */
    getApplicationDetail(applicationID: number | undefined): Observable<ApplicationDetailDtoBaseResponse> {
        let url_ = this.baseUrl + "/api/GenSubmission/get-application-detail?";
        if (applicationID === null)
            throw new Error("The parameter 'applicationID' cannot be null.");
        else if (applicationID !== undefined)
            url_ += "ApplicationID=" + encodeURIComponent("" + applicationID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApplicationDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApplicationDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicationDetailDtoBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicationDetailDtoBaseResponse>;
        }));
    }

    protected processGetApplicationDetail(response: HttpResponseBase): Observable<ApplicationDetailDtoBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationDetailDtoBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationDetailDtoBaseResponse>(null as any);
    }

    /**
     * @param docCategoryTypeId (optional) 
     * @return OK
     */
    getXbrlDocTypes(docCategoryTypeId: number | undefined): Observable<Int32ListBaseResponse> {
        let url_ = this.baseUrl + "/api/GenSubmission/get-xbrl-doc-types?";
        if (docCategoryTypeId === null)
            throw new Error("The parameter 'docCategoryTypeId' cannot be null.");
        else if (docCategoryTypeId !== undefined)
            url_ += "docCategoryTypeId=" + encodeURIComponent("" + docCategoryTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetXbrlDocTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetXbrlDocTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int32ListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int32ListBaseResponse>;
        }));
    }

    protected processGetXbrlDocTypes(response: HttpResponseBase): Observable<Int32ListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int32ListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int32ListBaseResponse>(null as any);
    }

    /**
     * @param flag (optional) 
     * @param docTypeID (optional) 
     * @param genSubID (optional) 
     * @return OK
     */
    bCanStartSignOff(flag: number | undefined, docTypeID: number | undefined, genSubID: number | undefined): Observable<CanStartSignOffDtoBaseResponse> {
        let url_ = this.baseUrl + "/api/GenSubmission/b-can-start-sign-off?";
        if (flag === null)
            throw new Error("The parameter 'flag' cannot be null.");
        else if (flag !== undefined)
            url_ += "flag=" + encodeURIComponent("" + flag) + "&";
        if (docTypeID === null)
            throw new Error("The parameter 'docTypeID' cannot be null.");
        else if (docTypeID !== undefined)
            url_ += "docTypeID=" + encodeURIComponent("" + docTypeID) + "&";
        if (genSubID === null)
            throw new Error("The parameter 'genSubID' cannot be null.");
        else if (genSubID !== undefined)
            url_ += "genSubID=" + encodeURIComponent("" + genSubID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBCanStartSignOff(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBCanStartSignOff(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CanStartSignOffDtoBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CanStartSignOffDtoBaseResponse>;
        }));
    }

    protected processBCanStartSignOff(response: HttpResponseBase): Observable<CanStartSignOffDtoBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CanStartSignOffDtoBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CanStartSignOffDtoBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    saveGenSubDetails(body: GeneralSubmissionDto | undefined): Observable<GeneralSubmissionDtoBaseResponse> {
        let url_ = this.baseUrl + "/api/GenSubmission/save-gen-sub-details";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveGenSubDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveGenSubDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralSubmissionDtoBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralSubmissionDtoBaseResponse>;
        }));
    }

    protected processSaveGenSubDetails(response: HttpResponseBase): Observable<GeneralSubmissionDtoBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralSubmissionDtoBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GeneralSubmissionDtoBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    getIndividualDetailByRoleId(): Observable<IndividualDetailDtoBaseResponse> {
        let url_ = this.baseUrl + "/api/GenSubmission/get-individual-detail-by-role-id";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIndividualDetailByRoleId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIndividualDetailByRoleId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IndividualDetailDtoBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IndividualDetailDtoBaseResponse>;
        }));
    }

    protected processGetIndividualDetailByRoleId(response: HttpResponseBase): Observable<IndividualDetailDtoBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IndividualDetailDtoBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IndividualDetailDtoBaseResponse>(null as any);
    }

    /**
     * @param updateWobjectStatus (optional) 
     * @param body (optional) 
     * @return OK
     */
    updateApplStatus(updateWobjectStatus: boolean | undefined, body: ApplicationDetailDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/GenSubmission/update-appl-status?";
        if (updateWobjectStatus === null)
            throw new Error("The parameter 'updateWobjectStatus' cannot be null.");
        else if (updateWobjectStatus !== undefined)
            url_ += "updateWobjectStatus=" + encodeURIComponent("" + updateWobjectStatus) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateApplStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateApplStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateApplStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return OK
     */
    getPendingItemsGenSub(): Observable<PendingItemsDtoListBaseResponse> {
        let url_ = this.baseUrl + "/api/GenSubmission/get-pending-items-gen-sub";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPendingItemsGenSub(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPendingItemsGenSub(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PendingItemsDtoListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PendingItemsDtoListBaseResponse>;
        }));
    }

    protected processGetPendingItemsGenSub(response: HttpResponseBase): Observable<PendingItemsDtoListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PendingItemsDtoListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PendingItemsDtoListBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    getSubmittedNocApplications(): Observable<PendingItemsDtoListBaseResponse> {
        let url_ = this.baseUrl + "/api/GenSubmission/get-submitted-noc-applications";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubmittedNocApplications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubmittedNocApplications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PendingItemsDtoListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PendingItemsDtoListBaseResponse>;
        }));
    }

    protected processGetSubmittedNocApplications(response: HttpResponseBase): Observable<PendingItemsDtoListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PendingItemsDtoListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PendingItemsDtoListBaseResponse>(null as any);
    }

    /**
     * @param qFCNum (optional) 
     * @param userID (optional) 
     * @return OK
     */
    getSubmittedGenSubApplications(qFCNum: string | undefined, userID: number | undefined): Observable<PendingItemsDtoListBaseResponse> {
        let url_ = this.baseUrl + "/api/GenSubmission/get-submitted-gen-sub-applications?";
        if (qFCNum === null)
            throw new Error("The parameter 'qFCNum' cannot be null.");
        else if (qFCNum !== undefined)
            url_ += "QFCNum=" + encodeURIComponent("" + qFCNum) + "&";
        if (userID === null)
            throw new Error("The parameter 'userID' cannot be null.");
        else if (userID !== undefined)
            url_ += "userID=" + encodeURIComponent("" + userID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubmittedGenSubApplications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubmittedGenSubApplications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PendingItemsDtoListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PendingItemsDtoListBaseResponse>;
        }));
    }

    protected processGetSubmittedGenSubApplications(response: HttpResponseBase): Observable<PendingItemsDtoListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PendingItemsDtoListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PendingItemsDtoListBaseResponse>(null as any);
    }

    /**
     * @param wIndFormTypeID (optional) 
     * @param wDocTypeID (optional) 
     * @return OK
     */
    getFormTypeidOrDoctypeid(wIndFormTypeID: number | undefined, wDocTypeID: number | undefined): Observable<WIndFormTypeBaseResponse> {
        let url_ = this.baseUrl + "/api/GenSubmission/get-form-typeid-or-doctypeid?";
        if (wIndFormTypeID === null)
            throw new Error("The parameter 'wIndFormTypeID' cannot be null.");
        else if (wIndFormTypeID !== undefined)
            url_ += "wIndFormTypeID=" + encodeURIComponent("" + wIndFormTypeID) + "&";
        if (wDocTypeID === null)
            throw new Error("The parameter 'wDocTypeID' cannot be null.");
        else if (wDocTypeID !== undefined)
            url_ += "wDocTypeID=" + encodeURIComponent("" + wDocTypeID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFormTypeidOrDoctypeid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFormTypeidOrDoctypeid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WIndFormTypeBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WIndFormTypeBaseResponse>;
        }));
    }

    protected processGetFormTypeidOrDoctypeid(response: HttpResponseBase): Observable<WIndFormTypeBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WIndFormTypeBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WIndFormTypeBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    insertUpdateObjectSoStatusDetails(body: ObjectSOStatusDto | undefined): Observable<Int32BaseResponse> {
        let url_ = this.baseUrl + "/api/GenSubmission/insert-update-object-so-status-details";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertUpdateObjectSoStatusDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertUpdateObjectSoStatusDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int32BaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int32BaseResponse>;
        }));
    }

    protected processInsertUpdateObjectSoStatusDetails(response: HttpResponseBase): Observable<Int32BaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int32BaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int32BaseResponse>(null as any);
    }

    /**
     * @param blobId (optional) 
     * @param attachmentId (optional) 
     * @return OK
     */
    updateAttachmentUrl(blobId: number | undefined, attachmentId: number | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/GenSubmission/update-attachment-url?";
        if (blobId === null)
            throw new Error("The parameter 'blobId' cannot be null.");
        else if (blobId !== undefined)
            url_ += "blobId=" + encodeURIComponent("" + blobId) + "&";
        if (attachmentId === null)
            throw new Error("The parameter 'attachmentId' cannot be null.");
        else if (attachmentId !== undefined)
            url_ += "attachmentId=" + encodeURIComponent("" + attachmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAttachmentUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAttachmentUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processUpdateAttachmentUrl(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @param pGenSubId (optional) 
     * @return OK
     */
    getGenSubDetails(pGenSubId: number | undefined): Observable<GeneralSubmissionDtoBaseResponse> {
        let url_ = this.baseUrl + "/api/GenSubmission/get-gen-sub-details?";
        if (pGenSubId === null)
            throw new Error("The parameter 'pGenSubId' cannot be null.");
        else if (pGenSubId !== undefined)
            url_ += "pGenSubId=" + encodeURIComponent("" + pGenSubId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGenSubDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGenSubDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralSubmissionDtoBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralSubmissionDtoBaseResponse>;
        }));
    }

    protected processGetGenSubDetails(response: HttpResponseBase): Observable<GeneralSubmissionDtoBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralSubmissionDtoBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GeneralSubmissionDtoBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateGenSubDetails(body: GeneralSubmissionDto | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/GenSubmission/update-gen-sub-details";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGenSubDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGenSubDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processUpdateGenSubDetails(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @param pGenSubmissionId (optional) 
     * @return OK
     */
    deleteGenSub(pGenSubmissionId: number | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/GenSubmission/delete-gen-sub?";
        if (pGenSubmissionId === null)
            throw new Error("The parameter 'pGenSubmissionId' cannot be null.");
        else if (pGenSubmissionId !== undefined)
            url_ += "pGenSubmissionId=" + encodeURIComponent("" + pGenSubmissionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteGenSub(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteGenSub(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processDeleteGenSub(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @param docTypeId (optional) 
     * @param body (optional) 
     * @return OK
     */
    getDocType(docTypeId: number | undefined, body: number[] | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/GenSubmission/get-doc-type?";
        if (docTypeId === null)
            throw new Error("The parameter 'docTypeId' cannot be null.");
        else if (docTypeId !== undefined)
            url_ += "docTypeId=" + encodeURIComponent("" + docTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processGetDocType(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @param docType (optional) 
     * @param reportType (optional) 
     * @return OK
     */
    validateReportType(docType: string | undefined, reportType: string | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/GenSubmission/validate-report-type?";
        if (docType === null)
            throw new Error("The parameter 'docType' cannot be null.");
        else if (docType !== undefined)
            url_ += "DocType=" + encodeURIComponent("" + docType) + "&";
        if (reportType === null)
            throw new Error("The parameter 'reportType' cannot be null.");
        else if (reportType !== undefined)
            url_ += "reportType=" + encodeURIComponent("" + reportType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateReportType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateReportType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processValidateReportType(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @param tableName (optional) 
     * @return OK
     */
    getMastertableData(tableName: string | undefined): Observable<StringStringDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/MasterData/get-mastertable-data?";
        if (tableName === null)
            throw new Error("The parameter 'tableName' cannot be null.");
        else if (tableName !== undefined)
            url_ += "tableName=" + encodeURIComponent("" + tableName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMastertableData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMastertableData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringStringDictionaryBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringStringDictionaryBaseResponse>;
        }));
    }

    protected processGetMastertableData(response: HttpResponseBase): Observable<StringStringDictionaryBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringStringDictionaryBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringStringDictionaryBaseResponse>(null as any);
    }

    /**
     * @param wConfigMessageID (optional) 
     * @param configKey (optional) 
     * @param configDesc (optional) 
     * @param configValue (optional) 
     * @param isEditable (optional) 
     * @return OK
     */
    getConfigMessage(wConfigMessageID: number | undefined, configKey: string | undefined, configDesc: string | undefined, configValue: string | undefined, isEditable: boolean | undefined): Observable<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/MasterData/get-config-message?";
        if (wConfigMessageID === null)
            throw new Error("The parameter 'wConfigMessageID' cannot be null.");
        else if (wConfigMessageID !== undefined)
            url_ += "WConfigMessageID=" + encodeURIComponent("" + wConfigMessageID) + "&";
        if (configKey === null)
            throw new Error("The parameter 'configKey' cannot be null.");
        else if (configKey !== undefined)
            url_ += "ConfigKey=" + encodeURIComponent("" + configKey) + "&";
        if (configDesc === null)
            throw new Error("The parameter 'configDesc' cannot be null.");
        else if (configDesc !== undefined)
            url_ += "ConfigDesc=" + encodeURIComponent("" + configDesc) + "&";
        if (configValue === null)
            throw new Error("The parameter 'configValue' cannot be null.");
        else if (configValue !== undefined)
            url_ += "ConfigValue=" + encodeURIComponent("" + configValue) + "&";
        if (isEditable === null)
            throw new Error("The parameter 'isEditable' cannot be null.");
        else if (isEditable !== undefined)
            url_ += "IsEditable=" + encodeURIComponent("" + isEditable) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfigMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfigMessage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringBaseResponse>;
        }));
    }

    protected processGetConfigMessage(response: HttpResponseBase): Observable<StringBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    getWroleFunctionAssn(): Observable<WUserRolesListBaseResponse> {
        let url_ = this.baseUrl + "/api/MasterData/get-wrole-function-assn";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWroleFunctionAssn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWroleFunctionAssn(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WUserRolesListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WUserRolesListBaseResponse>;
        }));
    }

    protected processGetWroleFunctionAssn(response: HttpResponseBase): Observable<WUserRolesListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WUserRolesListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WUserRolesListBaseResponse>(null as any);
    }

    /**
     * @param objectID (optional) 
     * @param body (optional) 
     * @return OK
     */
    createRegistrationEmailBody(objectID: number | undefined, body: WAccessRequests | undefined): Observable<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/MasterData/create-registration-email-body?";
        if (objectID === null)
            throw new Error("The parameter 'objectID' cannot be null.");
        else if (objectID !== undefined)
            url_ += "objectID=" + encodeURIComponent("" + objectID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRegistrationEmailBody(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRegistrationEmailBody(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringBaseResponse>;
        }));
    }

    protected processCreateRegistrationEmailBody(response: HttpResponseBase): Observable<StringBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringBaseResponse>(null as any);
    }

    /**
     * @param key (optional) 
     * @return OK
     */
    getMessageProperty(key: string | undefined): Observable<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/MasterData/get-message-property?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMessageProperty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMessageProperty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringBaseResponse>;
        }));
    }

    protected processGetMessageProperty(response: HttpResponseBase): Observable<StringBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    byObjectPageSection(objectId: number, pageId: number, pageSectionId: number): Observable<ObjectTextDtoListBaseResponse> {
        let url_ = this.baseUrl + "/api/MasterData/get-object-text/by-object-page-section/{objectId}/{pageId}/{pageSectionId}";
        if (objectId === undefined || objectId === null)
            throw new Error("The parameter 'objectId' must be defined.");
        url_ = url_.replace("{objectId}", encodeURIComponent("" + objectId));
        if (pageId === undefined || pageId === null)
            throw new Error("The parameter 'pageId' must be defined.");
        url_ = url_.replace("{pageId}", encodeURIComponent("" + pageId));
        if (pageSectionId === undefined || pageSectionId === null)
            throw new Error("The parameter 'pageSectionId' must be defined.");
        url_ = url_.replace("{pageSectionId}", encodeURIComponent("" + pageSectionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processByObjectPageSection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processByObjectPageSection(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectTextDtoListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectTextDtoListBaseResponse>;
        }));
    }

    protected processByObjectPageSection(response: HttpResponseBase): Observable<ObjectTextDtoListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectTextDtoListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectTextDtoListBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    byObjectPage(objectId: number, pageId: number): Observable<ObjectTextDtoListBaseResponse> {
        let url_ = this.baseUrl + "/api/MasterData/get-object-text/by-object-page/{objectId}/{pageId}";
        if (objectId === undefined || objectId === null)
            throw new Error("The parameter 'objectId' must be defined.");
        url_ = url_.replace("{objectId}", encodeURIComponent("" + objectId));
        if (pageId === undefined || pageId === null)
            throw new Error("The parameter 'pageId' must be defined.");
        url_ = url_.replace("{pageId}", encodeURIComponent("" + pageId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processByObjectPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processByObjectPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectTextDtoListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectTextDtoListBaseResponse>;
        }));
    }

    protected processByObjectPage(response: HttpResponseBase): Observable<ObjectTextDtoListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectTextDtoListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectTextDtoListBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    byId(objTextID: number): Observable<ObjectTextDtoBaseResponse> {
        let url_ = this.baseUrl + "/api/MasterData/get-object-text/by-id/{objTextID}";
        if (objTextID === undefined || objTextID === null)
            throw new Error("The parameter 'objTextID' must be defined.");
        url_ = url_.replace("{objTextID}", encodeURIComponent("" + objTextID));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectTextDtoBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectTextDtoBaseResponse>;
        }));
    }

    protected processById(response: HttpResponseBase): Observable<ObjectTextDtoBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectTextDtoBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectTextDtoBaseResponse>(null as any);
    }

    /**
     * @param wTermID (optional) 
     * @return OK
     */
    getTerms(wTermID: number | undefined): Observable<TermsBaseResponse> {
        let url_ = this.baseUrl + "/api/MasterData/get-terms?";
        if (wTermID === null)
            throw new Error("The parameter 'wTermID' cannot be null.");
        else if (wTermID !== undefined)
            url_ += "wTermID=" + encodeURIComponent("" + wTermID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTerms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTerms(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TermsBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TermsBaseResponse>;
        }));
    }

    protected processGetTerms(response: HttpResponseBase): Observable<TermsBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TermsBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TermsBaseResponse>(null as any);
    }

    /**
     * @param objectTypeTable (optional) 
     * @return OK
     */
    getObjectTypeTable(objectTypeTable: string | undefined): Observable<Int32StringDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/MasterData/get-object-type-table?";
        if (objectTypeTable === null)
            throw new Error("The parameter 'objectTypeTable' cannot be null.");
        else if (objectTypeTable !== undefined)
            url_ += "objectTypeTable=" + encodeURIComponent("" + objectTypeTable) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObjectTypeTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObjectTypeTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int32StringDictionaryBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int32StringDictionaryBaseResponse>;
        }));
    }

    protected processGetObjectTypeTable(response: HttpResponseBase): Observable<Int32StringDictionaryBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int32StringDictionaryBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int32StringDictionaryBaseResponse>(null as any);
    }

    /**
     * @param objectTypeTable (optional) 
     * @return OK
     */
    getObjectTypeStable(objectTypeTable: string | undefined): Observable<StringStringDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/MasterData/get-object-type-stable?";
        if (objectTypeTable === null)
            throw new Error("The parameter 'objectTypeTable' cannot be null.");
        else if (objectTypeTable !== undefined)
            url_ += "objectTypeTable=" + encodeURIComponent("" + objectTypeTable) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObjectTypeStable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObjectTypeStable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringStringDictionaryBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringStringDictionaryBaseResponse>;
        }));
    }

    protected processGetObjectTypeStable(response: HttpResponseBase): Observable<StringStringDictionaryBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringStringDictionaryBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringStringDictionaryBaseResponse>(null as any);
    }

    /**
     * @param objectTypeTable (optional) 
     * @return OK
     */
    selectObjectTypeStableSvcwc(objectTypeTable: string | undefined): Observable<StringStringDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/MasterData/select-object-type-stable-svcwc?";
        if (objectTypeTable === null)
            throw new Error("The parameter 'objectTypeTable' cannot be null.");
        else if (objectTypeTable !== undefined)
            url_ += "objectTypeTable=" + encodeURIComponent("" + objectTypeTable) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelectObjectTypeStableSvcwc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelectObjectTypeStableSvcwc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringStringDictionaryBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringStringDictionaryBaseResponse>;
        }));
    }

    protected processSelectObjectTypeStableSvcwc(response: HttpResponseBase): Observable<StringStringDictionaryBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringStringDictionaryBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringStringDictionaryBaseResponse>(null as any);
    }

    /**
     * @param year (optional) 
     * @return OK
     */
    getWnoticeList(year: number | undefined): Observable<WNoticeListListBaseResponse> {
        let url_ = this.baseUrl + "/api/NoticeData/get-wnotice-list?";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWnoticeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWnoticeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WNoticeListListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WNoticeListListBaseResponse>;
        }));
    }

    protected processGetWnoticeList(response: HttpResponseBase): Observable<WNoticeListListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WNoticeListListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WNoticeListListBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    getWnoticeListForHome(): Observable<WNoticeListListBaseResponse> {
        let url_ = this.baseUrl + "/api/NoticeData/get-wnotice-list-for-Home";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWnoticeListForHome(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWnoticeListForHome(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WNoticeListListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WNoticeListListBaseResponse>;
        }));
    }

    protected processGetWnoticeListForHome(response: HttpResponseBase): Observable<WNoticeListListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WNoticeListListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WNoticeListListBaseResponse>(null as any);
    }

    /**
     * @param wListNameID (optional) 
     * @return OK
     */
    getListValues(wListNameID: number | undefined): Observable<Int32StringDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/NoticeData/get-list-values?";
        if (wListNameID === null)
            throw new Error("The parameter 'wListNameID' cannot be null.");
        else if (wListNameID !== undefined)
            url_ += "wListNameID=" + encodeURIComponent("" + wListNameID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListValues(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int32StringDictionaryBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int32StringDictionaryBaseResponse>;
        }));
    }

    protected processGetListValues(response: HttpResponseBase): Observable<Int32StringDictionaryBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int32StringDictionaryBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int32StringDictionaryBaseResponse>(null as any);
    }

    /**
     * @param wNoticeID (optional) 
     * @param wFirmNoticeID (optional) 
     * @return OK
     */
    getWnoticeDetails(wNoticeID: number | undefined, wFirmNoticeID: number | undefined): Observable<WNoticeBaseResponse> {
        let url_ = this.baseUrl + "/api/NoticeData/get-wnotice-details?";
        if (wNoticeID === null)
            throw new Error("The parameter 'wNoticeID' cannot be null.");
        else if (wNoticeID !== undefined)
            url_ += "wNoticeID=" + encodeURIComponent("" + wNoticeID) + "&";
        if (wFirmNoticeID === null)
            throw new Error("The parameter 'wFirmNoticeID' cannot be null.");
        else if (wFirmNoticeID !== undefined)
            url_ += "WFirmNoticeID=" + encodeURIComponent("" + wFirmNoticeID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWnoticeDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWnoticeDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WNoticeBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WNoticeBaseResponse>;
        }));
    }

    protected processGetWnoticeDetails(response: HttpResponseBase): Observable<WNoticeBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WNoticeBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WNoticeBaseResponse>(null as any);
    }

    /**
     * @param wNoticeID (optional) 
     * @param wFirmNoticeID (optional) 
     * @return OK
     */
    getNoticeQuestionnaireItems(wNoticeID: number | undefined, wFirmNoticeID: number | undefined): Observable<WNoticeQuestionnaireItemDtoListBaseResponse> {
        let url_ = this.baseUrl + "/api/NoticeData/get-notice-questionnaire-items?";
        if (wNoticeID === null)
            throw new Error("The parameter 'wNoticeID' cannot be null.");
        else if (wNoticeID !== undefined)
            url_ += "wNoticeID=" + encodeURIComponent("" + wNoticeID) + "&";
        if (wFirmNoticeID === null)
            throw new Error("The parameter 'wFirmNoticeID' cannot be null.");
        else if (wFirmNoticeID !== undefined)
            url_ += "WFirmNoticeID=" + encodeURIComponent("" + wFirmNoticeID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNoticeQuestionnaireItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNoticeQuestionnaireItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WNoticeQuestionnaireItemDtoListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WNoticeQuestionnaireItemDtoListBaseResponse>;
        }));
    }

    protected processGetNoticeQuestionnaireItems(response: HttpResponseBase): Observable<WNoticeQuestionnaireItemDtoListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WNoticeQuestionnaireItemDtoListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WNoticeQuestionnaireItemDtoListBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    insertUpdateReportSchDetails(body: InsertReportSchDetailsDto | undefined): Observable<Int32ListBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportSchedule/insert-update-report-sch-details";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertUpdateReportSchDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertUpdateReportSchDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int32ListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int32ListBaseResponse>;
        }));
    }

    protected processInsertUpdateReportSchDetails(response: HttpResponseBase): Observable<Int32ListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int32ListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int32ListBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    insertUpdateObjectSoStatusDetails2(body: InsertObjectSOStatusDetailsDto | undefined): Observable<Int32BaseResponse> {
        let url_ = this.baseUrl + "/api/ReportSchedule/insert-update-object-so-status-details";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertUpdateObjectSoStatusDetails2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertUpdateObjectSoStatusDetails2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int32BaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int32BaseResponse>;
        }));
    }

    protected processInsertUpdateObjectSoStatusDetails2(response: HttpResponseBase): Observable<Int32BaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int32BaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int32BaseResponse>(null as any);
    }

    /**
     * @param qFCNum (optional) 
     * @param rptSchFinYearFromDate (optional) 
     * @param rptSchFinYearToDate (optional) 
     * @param sOCompletionDate (optional) 
     * @param rptPeriodTypeDesc (optional) 
     * @param docTypeID (optional) 
     * @param userID (optional) 
     * @param firmsRptSchID (optional) 
     * @param rptSchAttachmentStatusId (optional) 
     * @param rptName (optional) 
     * @param rptDueDate (optional) 
     * @param fileUploadedOnDate (optional) 
     * @param rptSchAttachmentStatusDesc (optional) 
     * @param rptSubmissionTypeID (optional) 
     * @param rptPeriodFromDate (optional) 
     * @param rptSubmissionType (optional) 
     * @param rptPeriodToDate (optional) 
     * @param rptFreqTypeDesc (optional) 
     * @param rptSchID (optional) 
     * @param rptSchItemID (optional) 
     * @param rptSchItemAttachmentID (optional) 
     * @param fileName (optional) 
     * @param attachmentFileURI (optional) 
     * @param objectSOStatusID (optional) 
     * @param fileUploadedByName (optional) 
     * @param fileUploadedByEmailAdd (optional) 
     * @param submittedOn (optional) 
     * @param sOStatusTypeDesc (optional) 
     * @param attachmentFilePath (optional) 
     * @param sOStatusTypeID (optional) 
     * @param submittedBy (optional) 
     * @param rptNextStatus (optional) 
     * @param attachmentStatusTypeID (optional) 
     * @param objectID (optional) 
     * @param fileAttachedUserEmail (optional) 
     * @param rptAttachmentStatusDate (optional) 
     * @param fileStream (optional) 
     * @param reviewComments (optional) 
     * @param firmsRptSchItemID (optional) 
     * @param manuallyReceived (optional) 
     * @param allowReSubmit (optional) 
     * @param isFileRecieved (optional) 
     * @param lateFeeFlag (optional) 
     * @param isReportDue (optional) 
     * @param daysOverDue (optional) 
     * @param isReportReminderDue (optional) 
     * @param isResubmissionRequested (optional) 
     * @param resubmissionRequestedDate (optional) 
     * @param isResubmissionNotificationRequired (optional) 
     * @param docReceivedDate (optional) 
     * @param isAMLDocType (optional) 
     * @param rptFormsToBeSubmited (optional) 
     * @param submissionBeforeRptPeriodEnd (optional) 
     * @param resubmissionDueDate (optional) 
     * @return OK
     */
    getReportSchItemDetails(qFCNum: string | undefined, rptSchFinYearFromDate: string | undefined, rptSchFinYearToDate: string | undefined, sOCompletionDate: string | undefined, rptPeriodTypeDesc: string | undefined, docTypeID: number | undefined, userID: number | undefined, firmsRptSchID: number | undefined, rptSchAttachmentStatusId: number | undefined, rptName: string | undefined, rptDueDate: string | undefined, fileUploadedOnDate: string | undefined, rptSchAttachmentStatusDesc: string | undefined, rptSubmissionTypeID: number | undefined, rptPeriodFromDate: string | undefined, rptSubmissionType: string | undefined, rptPeriodToDate: string | undefined, rptFreqTypeDesc: string | undefined, rptSchID: number | undefined, rptSchItemID: number | undefined, rptSchItemAttachmentID: number | undefined, fileName: string | undefined, attachmentFileURI: string | undefined, objectSOStatusID: number | undefined, fileUploadedByName: string | undefined, fileUploadedByEmailAdd: string | undefined, submittedOn: string | undefined, sOStatusTypeDesc: string | undefined, attachmentFilePath: string | undefined, sOStatusTypeID: number | undefined, submittedBy: number | undefined, rptNextStatus: string | undefined, attachmentStatusTypeID: number | undefined, objectID: number | undefined, fileAttachedUserEmail: string | undefined, rptAttachmentStatusDate: string | undefined, fileStream: string | undefined, reviewComments: string | undefined, firmsRptSchItemID: number | undefined, manuallyReceived: boolean | undefined, allowReSubmit: boolean | undefined, isFileRecieved: boolean | undefined, lateFeeFlag: boolean | undefined, isReportDue: boolean | undefined, daysOverDue: number | undefined, isReportReminderDue: boolean | undefined, isResubmissionRequested: boolean | undefined, resubmissionRequestedDate: string | undefined, isResubmissionNotificationRequired: boolean | undefined, docReceivedDate: string | undefined, isAMLDocType: boolean | undefined, rptFormsToBeSubmited: string | undefined, submissionBeforeRptPeriodEnd: boolean | undefined, resubmissionDueDate: string | undefined): Observable<ReportSchDetailsDtoBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportSchedule/get-report-sch-item-details?";
        if (qFCNum === null)
            throw new Error("The parameter 'qFCNum' cannot be null.");
        else if (qFCNum !== undefined)
            url_ += "QFCNum=" + encodeURIComponent("" + qFCNum) + "&";
        if (rptSchFinYearFromDate === null)
            throw new Error("The parameter 'rptSchFinYearFromDate' cannot be null.");
        else if (rptSchFinYearFromDate !== undefined)
            url_ += "RptSchFinYearFromDate=" + encodeURIComponent("" + rptSchFinYearFromDate) + "&";
        if (rptSchFinYearToDate === null)
            throw new Error("The parameter 'rptSchFinYearToDate' cannot be null.");
        else if (rptSchFinYearToDate !== undefined)
            url_ += "RptSchFinYearToDate=" + encodeURIComponent("" + rptSchFinYearToDate) + "&";
        if (sOCompletionDate === null)
            throw new Error("The parameter 'sOCompletionDate' cannot be null.");
        else if (sOCompletionDate !== undefined)
            url_ += "SOCompletionDate=" + encodeURIComponent("" + sOCompletionDate) + "&";
        if (rptPeriodTypeDesc === null)
            throw new Error("The parameter 'rptPeriodTypeDesc' cannot be null.");
        else if (rptPeriodTypeDesc !== undefined)
            url_ += "RptPeriodTypeDesc=" + encodeURIComponent("" + rptPeriodTypeDesc) + "&";
        if (docTypeID === null)
            throw new Error("The parameter 'docTypeID' cannot be null.");
        else if (docTypeID !== undefined)
            url_ += "DocTypeID=" + encodeURIComponent("" + docTypeID) + "&";
        if (userID === null)
            throw new Error("The parameter 'userID' cannot be null.");
        else if (userID !== undefined)
            url_ += "UserID=" + encodeURIComponent("" + userID) + "&";
        if (firmsRptSchID === null)
            throw new Error("The parameter 'firmsRptSchID' cannot be null.");
        else if (firmsRptSchID !== undefined)
            url_ += "FirmsRptSchID=" + encodeURIComponent("" + firmsRptSchID) + "&";
        if (rptSchAttachmentStatusId === null)
            throw new Error("The parameter 'rptSchAttachmentStatusId' cannot be null.");
        else if (rptSchAttachmentStatusId !== undefined)
            url_ += "RptSchAttachmentStatusId=" + encodeURIComponent("" + rptSchAttachmentStatusId) + "&";
        if (rptName === null)
            throw new Error("The parameter 'rptName' cannot be null.");
        else if (rptName !== undefined)
            url_ += "RptName=" + encodeURIComponent("" + rptName) + "&";
        if (rptDueDate === null)
            throw new Error("The parameter 'rptDueDate' cannot be null.");
        else if (rptDueDate !== undefined)
            url_ += "RptDueDate=" + encodeURIComponent("" + rptDueDate) + "&";
        if (fileUploadedOnDate === null)
            throw new Error("The parameter 'fileUploadedOnDate' cannot be null.");
        else if (fileUploadedOnDate !== undefined)
            url_ += "FileUploadedOnDate=" + encodeURIComponent("" + fileUploadedOnDate) + "&";
        if (rptSchAttachmentStatusDesc === null)
            throw new Error("The parameter 'rptSchAttachmentStatusDesc' cannot be null.");
        else if (rptSchAttachmentStatusDesc !== undefined)
            url_ += "RptSchAttachmentStatusDesc=" + encodeURIComponent("" + rptSchAttachmentStatusDesc) + "&";
        if (rptSubmissionTypeID === null)
            throw new Error("The parameter 'rptSubmissionTypeID' cannot be null.");
        else if (rptSubmissionTypeID !== undefined)
            url_ += "RptSubmissionTypeID=" + encodeURIComponent("" + rptSubmissionTypeID) + "&";
        if (rptPeriodFromDate === null)
            throw new Error("The parameter 'rptPeriodFromDate' cannot be null.");
        else if (rptPeriodFromDate !== undefined)
            url_ += "RptPeriodFromDate=" + encodeURIComponent("" + rptPeriodFromDate) + "&";
        if (rptSubmissionType === null)
            throw new Error("The parameter 'rptSubmissionType' cannot be null.");
        else if (rptSubmissionType !== undefined)
            url_ += "RptSubmissionType=" + encodeURIComponent("" + rptSubmissionType) + "&";
        if (rptPeriodToDate === null)
            throw new Error("The parameter 'rptPeriodToDate' cannot be null.");
        else if (rptPeriodToDate !== undefined)
            url_ += "RptPeriodToDate=" + encodeURIComponent("" + rptPeriodToDate) + "&";
        if (rptFreqTypeDesc === null)
            throw new Error("The parameter 'rptFreqTypeDesc' cannot be null.");
        else if (rptFreqTypeDesc !== undefined)
            url_ += "RptFreqTypeDesc=" + encodeURIComponent("" + rptFreqTypeDesc) + "&";
        if (rptSchID === null)
            throw new Error("The parameter 'rptSchID' cannot be null.");
        else if (rptSchID !== undefined)
            url_ += "RptSchID=" + encodeURIComponent("" + rptSchID) + "&";
        if (rptSchItemID === null)
            throw new Error("The parameter 'rptSchItemID' cannot be null.");
        else if (rptSchItemID !== undefined)
            url_ += "RptSchItemID=" + encodeURIComponent("" + rptSchItemID) + "&";
        if (rptSchItemAttachmentID === null)
            throw new Error("The parameter 'rptSchItemAttachmentID' cannot be null.");
        else if (rptSchItemAttachmentID !== undefined)
            url_ += "RptSchItemAttachmentID=" + encodeURIComponent("" + rptSchItemAttachmentID) + "&";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "FileName=" + encodeURIComponent("" + fileName) + "&";
        if (attachmentFileURI === null)
            throw new Error("The parameter 'attachmentFileURI' cannot be null.");
        else if (attachmentFileURI !== undefined)
            url_ += "AttachmentFileURI=" + encodeURIComponent("" + attachmentFileURI) + "&";
        if (objectSOStatusID === null)
            throw new Error("The parameter 'objectSOStatusID' cannot be null.");
        else if (objectSOStatusID !== undefined)
            url_ += "ObjectSOStatusID=" + encodeURIComponent("" + objectSOStatusID) + "&";
        if (fileUploadedByName === null)
            throw new Error("The parameter 'fileUploadedByName' cannot be null.");
        else if (fileUploadedByName !== undefined)
            url_ += "FileUploadedByName=" + encodeURIComponent("" + fileUploadedByName) + "&";
        if (fileUploadedByEmailAdd === null)
            throw new Error("The parameter 'fileUploadedByEmailAdd' cannot be null.");
        else if (fileUploadedByEmailAdd !== undefined)
            url_ += "FileUploadedByEmailAdd=" + encodeURIComponent("" + fileUploadedByEmailAdd) + "&";
        if (submittedOn === null)
            throw new Error("The parameter 'submittedOn' cannot be null.");
        else if (submittedOn !== undefined)
            url_ += "SubmittedOn=" + encodeURIComponent("" + submittedOn) + "&";
        if (sOStatusTypeDesc === null)
            throw new Error("The parameter 'sOStatusTypeDesc' cannot be null.");
        else if (sOStatusTypeDesc !== undefined)
            url_ += "SOStatusTypeDesc=" + encodeURIComponent("" + sOStatusTypeDesc) + "&";
        if (attachmentFilePath === null)
            throw new Error("The parameter 'attachmentFilePath' cannot be null.");
        else if (attachmentFilePath !== undefined)
            url_ += "AttachmentFilePath=" + encodeURIComponent("" + attachmentFilePath) + "&";
        if (sOStatusTypeID === null)
            throw new Error("The parameter 'sOStatusTypeID' cannot be null.");
        else if (sOStatusTypeID !== undefined)
            url_ += "SOStatusTypeID=" + encodeURIComponent("" + sOStatusTypeID) + "&";
        if (submittedBy === null)
            throw new Error("The parameter 'submittedBy' cannot be null.");
        else if (submittedBy !== undefined)
            url_ += "SubmittedBy=" + encodeURIComponent("" + submittedBy) + "&";
        if (rptNextStatus === null)
            throw new Error("The parameter 'rptNextStatus' cannot be null.");
        else if (rptNextStatus !== undefined)
            url_ += "RptNextStatus=" + encodeURIComponent("" + rptNextStatus) + "&";
        if (attachmentStatusTypeID === null)
            throw new Error("The parameter 'attachmentStatusTypeID' cannot be null.");
        else if (attachmentStatusTypeID !== undefined)
            url_ += "AttachmentStatusTypeID=" + encodeURIComponent("" + attachmentStatusTypeID) + "&";
        if (objectID === null)
            throw new Error("The parameter 'objectID' cannot be null.");
        else if (objectID !== undefined)
            url_ += "ObjectID=" + encodeURIComponent("" + objectID) + "&";
        if (fileAttachedUserEmail === null)
            throw new Error("The parameter 'fileAttachedUserEmail' cannot be null.");
        else if (fileAttachedUserEmail !== undefined)
            url_ += "FileAttachedUserEmail=" + encodeURIComponent("" + fileAttachedUserEmail) + "&";
        if (rptAttachmentStatusDate === null)
            throw new Error("The parameter 'rptAttachmentStatusDate' cannot be null.");
        else if (rptAttachmentStatusDate !== undefined)
            url_ += "RptAttachmentStatusDate=" + encodeURIComponent("" + rptAttachmentStatusDate) + "&";
        if (fileStream === null)
            throw new Error("The parameter 'fileStream' cannot be null.");
        else if (fileStream !== undefined)
            url_ += "FileStream=" + encodeURIComponent("" + fileStream) + "&";
        if (reviewComments === null)
            throw new Error("The parameter 'reviewComments' cannot be null.");
        else if (reviewComments !== undefined)
            url_ += "ReviewComments=" + encodeURIComponent("" + reviewComments) + "&";
        if (firmsRptSchItemID === null)
            throw new Error("The parameter 'firmsRptSchItemID' cannot be null.");
        else if (firmsRptSchItemID !== undefined)
            url_ += "FirmsRptSchItemID=" + encodeURIComponent("" + firmsRptSchItemID) + "&";
        if (manuallyReceived === null)
            throw new Error("The parameter 'manuallyReceived' cannot be null.");
        else if (manuallyReceived !== undefined)
            url_ += "ManuallyReceived=" + encodeURIComponent("" + manuallyReceived) + "&";
        if (allowReSubmit === null)
            throw new Error("The parameter 'allowReSubmit' cannot be null.");
        else if (allowReSubmit !== undefined)
            url_ += "AllowReSubmit=" + encodeURIComponent("" + allowReSubmit) + "&";
        if (isFileRecieved === null)
            throw new Error("The parameter 'isFileRecieved' cannot be null.");
        else if (isFileRecieved !== undefined)
            url_ += "isFileRecieved=" + encodeURIComponent("" + isFileRecieved) + "&";
        if (lateFeeFlag === null)
            throw new Error("The parameter 'lateFeeFlag' cannot be null.");
        else if (lateFeeFlag !== undefined)
            url_ += "LateFeeFlag=" + encodeURIComponent("" + lateFeeFlag) + "&";
        if (isReportDue === null)
            throw new Error("The parameter 'isReportDue' cannot be null.");
        else if (isReportDue !== undefined)
            url_ += "isReportDue=" + encodeURIComponent("" + isReportDue) + "&";
        if (daysOverDue === null)
            throw new Error("The parameter 'daysOverDue' cannot be null.");
        else if (daysOverDue !== undefined)
            url_ += "DaysOverDue=" + encodeURIComponent("" + daysOverDue) + "&";
        if (isReportReminderDue === null)
            throw new Error("The parameter 'isReportReminderDue' cannot be null.");
        else if (isReportReminderDue !== undefined)
            url_ += "isReportReminderDue=" + encodeURIComponent("" + isReportReminderDue) + "&";
        if (isResubmissionRequested === null)
            throw new Error("The parameter 'isResubmissionRequested' cannot be null.");
        else if (isResubmissionRequested !== undefined)
            url_ += "isResubmissionRequested=" + encodeURIComponent("" + isResubmissionRequested) + "&";
        if (resubmissionRequestedDate === null)
            throw new Error("The parameter 'resubmissionRequestedDate' cannot be null.");
        else if (resubmissionRequestedDate !== undefined)
            url_ += "ResubmissionRequestedDate=" + encodeURIComponent("" + resubmissionRequestedDate) + "&";
        if (isResubmissionNotificationRequired === null)
            throw new Error("The parameter 'isResubmissionNotificationRequired' cannot be null.");
        else if (isResubmissionNotificationRequired !== undefined)
            url_ += "isResubmissionNotificationRequired=" + encodeURIComponent("" + isResubmissionNotificationRequired) + "&";
        if (docReceivedDate === null)
            throw new Error("The parameter 'docReceivedDate' cannot be null.");
        else if (docReceivedDate !== undefined)
            url_ += "DocReceivedDate=" + encodeURIComponent("" + docReceivedDate) + "&";
        if (isAMLDocType === null)
            throw new Error("The parameter 'isAMLDocType' cannot be null.");
        else if (isAMLDocType !== undefined)
            url_ += "IsAMLDocType=" + encodeURIComponent("" + isAMLDocType) + "&";
        if (rptFormsToBeSubmited === null)
            throw new Error("The parameter 'rptFormsToBeSubmited' cannot be null.");
        else if (rptFormsToBeSubmited !== undefined)
            url_ += "RptFormsToBeSubmited=" + encodeURIComponent("" + rptFormsToBeSubmited) + "&";
        if (submissionBeforeRptPeriodEnd === null)
            throw new Error("The parameter 'submissionBeforeRptPeriodEnd' cannot be null.");
        else if (submissionBeforeRptPeriodEnd !== undefined)
            url_ += "SubmissionBeforeRptPeriodEnd=" + encodeURIComponent("" + submissionBeforeRptPeriodEnd) + "&";
        if (resubmissionDueDate === null)
            throw new Error("The parameter 'resubmissionDueDate' cannot be null.");
        else if (resubmissionDueDate !== undefined)
            url_ += "ResubmissionDueDate=" + encodeURIComponent("" + resubmissionDueDate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportSchItemDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportSchItemDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportSchDetailsDtoBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportSchDetailsDtoBaseResponse>;
        }));
    }

    protected processGetReportSchItemDetails(response: HttpResponseBase): Observable<ReportSchDetailsDtoBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportSchDetailsDtoBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportSchDetailsDtoBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    getSubmissionDetailsForHomePage(): Observable<ReportSchDetailsDtoListBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportSchedule/get-submission-details-for-home-page";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubmissionDetailsForHomePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubmissionDetailsForHomePage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportSchDetailsDtoListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportSchDetailsDtoListBaseResponse>;
        }));
    }

    protected processGetSubmissionDetailsForHomePage(response: HttpResponseBase): Observable<ReportSchDetailsDtoListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportSchDetailsDtoListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportSchDetailsDtoListBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getFileUploadByUserDet(body: AttachmentDto | undefined): Observable<AttachmentDtoBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportSchedule/get-file-upload-by-user-det";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFileUploadByUserDet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFileUploadByUserDet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentDtoBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentDtoBaseResponse>;
        }));
    }

    protected processGetFileUploadByUserDet(response: HttpResponseBase): Observable<AttachmentDtoBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentDtoBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttachmentDtoBaseResponse>(null as any);
    }

    /**
     * @param qfcNum (optional) 
     * @param firmTypeID (optional) 
     * @return OK
     */
    getSefUsserDetails(qfcNum: string | undefined, firmTypeID: number | undefined): Observable<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportSchedule/get-sef-usser-details?";
        if (qfcNum === null)
            throw new Error("The parameter 'qfcNum' cannot be null.");
        else if (qfcNum !== undefined)
            url_ += "qfcNum=" + encodeURIComponent("" + qfcNum) + "&";
        if (firmTypeID === null)
            throw new Error("The parameter 'firmTypeID' cannot be null.");
        else if (firmTypeID !== undefined)
            url_ += "firmTypeID=" + encodeURIComponent("" + firmTypeID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSefUsserDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSefUsserDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringBaseResponse>;
        }));
    }

    protected processGetSefUsserDetails(response: HttpResponseBase): Observable<StringBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringBaseResponse>(null as any);
    }

    /**
     * @param wObjTaskID (optional) 
     * @param wObjectID (optional) 
     * @param wObjInstanceID (optional) 
     * @param wObjTaskSyncStatusTypeID (optional) 
     * @param wObjectEventTypeID (optional) 
     * @param dateCreated (optional) 
     * @param userCreated (optional) 
     * @param isFileStreamReq (optional) 
     * @param isXBRL (optional) 
     * @return OK
     */
    getReportSchDetails(wObjTaskID: number | undefined, wObjectID: number | undefined, wObjInstanceID: number | undefined, wObjTaskSyncStatusTypeID: number | undefined, wObjectEventTypeID: number | undefined, dateCreated: Date | undefined, userCreated: number | undefined, isFileStreamReq: boolean | undefined, isXBRL: boolean | undefined): Observable<ReportSchDetailsDtoBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportSchedule/get-report-sch-details?";
        if (wObjTaskID === null)
            throw new Error("The parameter 'wObjTaskID' cannot be null.");
        else if (wObjTaskID !== undefined)
            url_ += "WObjTaskID=" + encodeURIComponent("" + wObjTaskID) + "&";
        if (wObjectID === null)
            throw new Error("The parameter 'wObjectID' cannot be null.");
        else if (wObjectID !== undefined)
            url_ += "WObjectID=" + encodeURIComponent("" + wObjectID) + "&";
        if (wObjInstanceID === null)
            throw new Error("The parameter 'wObjInstanceID' cannot be null.");
        else if (wObjInstanceID !== undefined)
            url_ += "WObjInstanceID=" + encodeURIComponent("" + wObjInstanceID) + "&";
        if (wObjTaskSyncStatusTypeID === null)
            throw new Error("The parameter 'wObjTaskSyncStatusTypeID' cannot be null.");
        else if (wObjTaskSyncStatusTypeID !== undefined)
            url_ += "WObjTaskSyncStatusTypeID=" + encodeURIComponent("" + wObjTaskSyncStatusTypeID) + "&";
        if (wObjectEventTypeID === null)
            throw new Error("The parameter 'wObjectEventTypeID' cannot be null.");
        else if (wObjectEventTypeID !== undefined)
            url_ += "WObjectEventTypeID=" + encodeURIComponent("" + wObjectEventTypeID) + "&";
        if (dateCreated === null)
            throw new Error("The parameter 'dateCreated' cannot be null.");
        else if (dateCreated !== undefined)
            url_ += "DateCreated=" + encodeURIComponent(dateCreated ? "" + dateCreated.toISOString() : "") + "&";
        if (userCreated === null)
            throw new Error("The parameter 'userCreated' cannot be null.");
        else if (userCreated !== undefined)
            url_ += "UserCreated=" + encodeURIComponent("" + userCreated) + "&";
        if (isFileStreamReq === null)
            throw new Error("The parameter 'isFileStreamReq' cannot be null.");
        else if (isFileStreamReq !== undefined)
            url_ += "isFileStreamReq=" + encodeURIComponent("" + isFileStreamReq) + "&";
        if (isXBRL === null)
            throw new Error("The parameter 'isXBRL' cannot be null.");
        else if (isXBRL !== undefined)
            url_ += "isXBRL=" + encodeURIComponent("" + isXBRL) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportSchDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportSchDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportSchDetailsDtoBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportSchDetailsDtoBaseResponse>;
        }));
    }

    protected processGetReportSchDetails(response: HttpResponseBase): Observable<ReportSchDetailsDtoBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportSchDetailsDtoBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportSchDetailsDtoBaseResponse>(null as any);
    }

    /**
     * @param fileName (optional) 
     * @param attachmentFilePath (optional) 
     * @param isFileStreamReq (optional) 
     * @param isXBRL (optional) 
     * @return OK
     */
    getReportSchFileDetails(fileName: string | undefined, attachmentFilePath: string | undefined, isFileStreamReq: boolean | undefined, isXBRL: boolean | undefined): Observable<ReportSchDetailsDtoBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportSchedule/get-report-sch-file-details?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (attachmentFilePath === null)
            throw new Error("The parameter 'attachmentFilePath' cannot be null.");
        else if (attachmentFilePath !== undefined)
            url_ += "attachmentFilePath=" + encodeURIComponent("" + attachmentFilePath) + "&";
        if (isFileStreamReq === null)
            throw new Error("The parameter 'isFileStreamReq' cannot be null.");
        else if (isFileStreamReq !== undefined)
            url_ += "isFileStreamReq=" + encodeURIComponent("" + isFileStreamReq) + "&";
        if (isXBRL === null)
            throw new Error("The parameter 'isXBRL' cannot be null.");
        else if (isXBRL !== undefined)
            url_ += "isXBRL=" + encodeURIComponent("" + isXBRL) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportSchFileDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportSchFileDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportSchDetailsDtoBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportSchDetailsDtoBaseResponse>;
        }));
    }

    protected processGetReportSchFileDetails(response: HttpResponseBase): Observable<ReportSchDetailsDtoBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportSchDetailsDtoBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportSchDetailsDtoBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getReportSchDetailsSimple(body: ObjTasksDto | undefined): Observable<ReportSchDetailsDtoBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportSchedule/get-report-sch-details-simple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportSchDetailsSimple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportSchDetailsSimple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportSchDetailsDtoBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportSchDetailsDtoBaseResponse>;
        }));
    }

    protected processGetReportSchDetailsSimple(response: HttpResponseBase): Observable<ReportSchDetailsDtoBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportSchDetailsDtoBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportSchDetailsDtoBaseResponse>(null as any);
    }

    /**
     * @param wObjectID (optional) 
     * @param wObjInstanceID (optional) 
     * @return OK
     */
    getReportSchSignOffDetails(wObjectID: number | undefined, wObjInstanceID: number | undefined): Observable<ObjectSoTaskStatusDtoListBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportSchedule/get-report-sch-sign-off-details?";
        if (wObjectID === null)
            throw new Error("The parameter 'wObjectID' cannot be null.");
        else if (wObjectID !== undefined)
            url_ += "wObjectID=" + encodeURIComponent("" + wObjectID) + "&";
        if (wObjInstanceID === null)
            throw new Error("The parameter 'wObjInstanceID' cannot be null.");
        else if (wObjInstanceID !== undefined)
            url_ += "wObjInstanceID=" + encodeURIComponent("" + wObjInstanceID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportSchSignOffDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportSchSignOffDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectSoTaskStatusDtoListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectSoTaskStatusDtoListBaseResponse>;
        }));
    }

    protected processGetReportSchSignOffDetails(response: HttpResponseBase): Observable<ObjectSoTaskStatusDtoListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectSoTaskStatusDtoListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectSoTaskStatusDtoListBaseResponse>(null as any);
    }

    /**
     * @param attachmentID (optional) 
     * @return OK
     */
    updateItemAttachment(attachmentID: number | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportSchedule/update-item-attachment?";
        if (attachmentID === null)
            throw new Error("The parameter 'attachmentID' cannot be null.");
        else if (attachmentID !== undefined)
            url_ += "attachmentID=" + encodeURIComponent("" + attachmentID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateItemAttachment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateItemAttachment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processUpdateItemAttachment(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    insertUpdateObjectAttachmentStatus(body: WobjectAttachmentStatusDto | undefined): Observable<WobjectAttachmentStatusDtoBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportSchedule/insert-update-object-attachment-status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertUpdateObjectAttachmentStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertUpdateObjectAttachmentStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WobjectAttachmentStatusDtoBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WobjectAttachmentStatusDtoBaseResponse>;
        }));
    }

    protected processInsertUpdateObjectAttachmentStatus(response: HttpResponseBase): Observable<WobjectAttachmentStatusDtoBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WobjectAttachmentStatusDtoBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WobjectAttachmentStatusDtoBaseResponse>(null as any);
    }
}

@Injectable()
export class FromClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    firms(body: InsertUpdateNoticeDetailsFromFirmsRequest | undefined): Observable<WNoticeDtoBaseResponse> {
        let url_ = this.baseUrl + "/api/NoticeData/insert_update_notice_details_from_firms";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFirms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFirms(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WNoticeDtoBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WNoticeDtoBaseResponse>;
        }));
    }

    protected processFirms(response: HttpResponseBase): Observable<WNoticeDtoBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WNoticeDtoBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WNoticeDtoBaseResponse>(null as any);
    }
}

@Injectable()
export class NoticeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param wNoticeID (optional) 
     * @param body (optional) 
     * @return OK
     */
    attachments(wNoticeID: number | undefined, body: DataSet | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/NoticeData/save_notice_attachments?";
        if (wNoticeID === null)
            throw new Error("The parameter 'wNoticeID' cannot be null.");
        else if (wNoticeID !== undefined)
            url_ += "wNoticeID=" + encodeURIComponent("" + wNoticeID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAttachments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAttachments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processAttachments(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }
}

@Injectable()
export class FirmClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    notice(body: InsertFirmNoticeRequest | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/NoticeData/insert_firm_notice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNotice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processNotice(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }
}

@Injectable()
export class EmailClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    details(body: ProcessNoticeEmailDetailsRequest | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/NoticeData/process_notice_email_details";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processDetails(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    event(body: EmailEventRequest | undefined): Observable<ReportSchEmailDetBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportSchedule/email_event";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportSchEmailDetBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportSchEmailDetBaseResponse>;
        }));
    }

    protected processEvent(response: HttpResponseBase): Observable<ReportSchEmailDetBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportSchEmailDetBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportSchEmailDetBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    address(body: ReportSchEmailDet | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ReportSchedule/check_and_remove_duplicate_email_address";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddress(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ResponseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    details(body: WFirmNotices | undefined): Observable<FirmNoticesDtoBaseResponse> {
        let url_ = this.baseUrl + "/api/NoticeData/generate_notice_response_details";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FirmNoticesDtoBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FirmNoticesDtoBaseResponse>;
        }));
    }

    protected processDetails(response: HttpResponseBase): Observable<FirmNoticesDtoBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FirmNoticesDtoBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FirmNoticesDtoBaseResponse>(null as any);
    }
}

@Injectable()
export class ReportClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    validation(body: EmailEventForReportValidationRequest | undefined): Observable<ReportSchEmailDetBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportSchedule/email_event_for_report_validation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportSchEmailDetBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportSchEmailDetBaseResponse>;
        }));
    }

    protected processValidation(response: HttpResponseBase): Observable<ReportSchEmailDetBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportSchEmailDetBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportSchEmailDetBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    evaluations(): Observable<ReportEvaluationsListBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportValidation/get_report_evaluations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEvaluations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEvaluations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportEvaluationsListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportEvaluationsListBaseResponse>;
        }));
    }

    protected processEvaluations(response: HttpResponseBase): Observable<ReportEvaluationsListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportEvaluationsListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportEvaluationsListBaseResponse>(null as any);
    }
}

@Injectable()
export class ForClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param strQFCNumber (optional) 
     * @param body (optional) 
     * @return OK
     */
    home(strQFCNumber: string | undefined, body: ReportSchDetailsDto[] | undefined): Observable<ReportSchDetailsDtoListBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportSchedule/get_report_sch_item_details_for_home?";
        if (strQFCNumber === null)
            throw new Error("The parameter 'strQFCNumber' cannot be null.");
        else if (strQFCNumber !== undefined)
            url_ += "strQFCNumber=" + encodeURIComponent("" + strQFCNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHome(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHome(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportSchDetailsDtoListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportSchDetailsDtoListBaseResponse>;
        }));
    }

    protected processHome(response: HttpResponseBase): Observable<ReportSchDetailsDtoListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportSchDetailsDtoListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportSchDetailsDtoListBaseResponse>(null as any);
    }
}

@Injectable()
export class ByClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param roleID (optional) 
     * @param qFCNo (optional) 
     * @return OK
     */
    role(roleID: number | undefined, qFCNo: string | undefined): Observable<ReportSignatoriesListBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportSchedule/get_users_by_role?";
        if (roleID === null)
            throw new Error("The parameter 'roleID' cannot be null.");
        else if (roleID !== undefined)
            url_ += "roleID=" + encodeURIComponent("" + roleID) + "&";
        if (qFCNo === null)
            throw new Error("The parameter 'qFCNo' cannot be null.");
        else if (qFCNo !== undefined)
            url_ += "QFCNo=" + encodeURIComponent("" + qFCNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportSignatoriesListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportSignatoriesListBaseResponse>;
        }));
    }

    protected processRole(response: HttpResponseBase): Observable<ReportSignatoriesListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportSignatoriesListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportSignatoriesListBaseResponse>(null as any);
    }
}

@Injectable()
export class ScheduleClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param filePath (optional) 
     * @param strFrontSheet (optional) 
     * @param strFirmName (optional) 
     * @param strQFCNumber (optional) 
     * @param strRptFromDate (optional) 
     * @param strRptToDate (optional) 
     * @return OK
     */
    data(filePath: string | undefined, strFrontSheet: string | undefined, strFirmName: string | undefined, strQFCNumber: string | undefined, strRptFromDate: string | undefined, strRptToDate: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ReportValidation/validate_front_sheet_with_schedule_data?";
        if (filePath === null)
            throw new Error("The parameter 'filePath' cannot be null.");
        else if (filePath !== undefined)
            url_ += "filePath=" + encodeURIComponent("" + filePath) + "&";
        if (strFrontSheet === null)
            throw new Error("The parameter 'strFrontSheet' cannot be null.");
        else if (strFrontSheet !== undefined)
            url_ += "strFrontSheet=" + encodeURIComponent("" + strFrontSheet) + "&";
        if (strFirmName === null)
            throw new Error("The parameter 'strFirmName' cannot be null.");
        else if (strFirmName !== undefined)
            url_ += "strFirmName=" + encodeURIComponent("" + strFirmName) + "&";
        if (strQFCNumber === null)
            throw new Error("The parameter 'strQFCNumber' cannot be null.");
        else if (strQFCNumber !== undefined)
            url_ += "strQFCNumber=" + encodeURIComponent("" + strQFCNumber) + "&";
        if (strRptFromDate === null)
            throw new Error("The parameter 'strRptFromDate' cannot be null.");
        else if (strRptFromDate !== undefined)
            url_ += "strRptFromDate=" + encodeURIComponent("" + strRptFromDate) + "&";
        if (strRptToDate === null)
            throw new Error("The parameter 'strRptToDate' cannot be null.");
        else if (strRptToDate !== undefined)
            url_ += "strRptToDate=" + encodeURIComponent("" + strRptToDate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class TableClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param doctypeID (optional) 
     * @param natureofbusiness (optional) 
     * @return OK
     */
    elements(doctypeID: number | undefined, natureofbusiness: number | undefined): Observable<StringObjectIDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportValidation/get_sheet_table_elements?";
        if (doctypeID === null)
            throw new Error("The parameter 'doctypeID' cannot be null.");
        else if (doctypeID !== undefined)
            url_ += "doctypeID=" + encodeURIComponent("" + doctypeID) + "&";
        if (natureofbusiness === null)
            throw new Error("The parameter 'natureofbusiness' cannot be null.");
        else if (natureofbusiness !== undefined)
            url_ += "natureofbusiness=" + encodeURIComponent("" + natureofbusiness) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processElements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processElements(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringObjectIDictionaryListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringObjectIDictionaryListBaseResponse>;
        }));
    }

    protected processElements(response: HttpResponseBase): Observable<StringObjectIDictionaryListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectIDictionaryListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringObjectIDictionaryListBaseResponse>(null as any);
    }
}

@Injectable()
export class BusinessClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param listvalue (optional) 
     * @return OK
     */
    id(listvalue: string | undefined): Observable<Int32BaseResponse> {
        let url_ = this.baseUrl + "/api/ReportValidation/get_nature_of_business_id?";
        if (listvalue === null)
            throw new Error("The parameter 'listvalue' cannot be null.");
        else if (listvalue !== undefined)
            url_ += "listvalue=" + encodeURIComponent("" + listvalue) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int32BaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int32BaseResponse>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<Int32BaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int32BaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int32BaseResponse>(null as any);
    }
}

@Injectable()
export class ValidationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    result(body: FirmReportSchItemsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ReportValidation/save_validation_result";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResult(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResult(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param objectID (optional) 
     * @param objectInstanceID (optional) 
     * @param attachmentID (optional) 
     * @param fileName (optional) 
     * @return OK
     */
    result(objectID: number | undefined, objectInstanceID: number | undefined, attachmentID: number | undefined, fileName: string | undefined): Observable<ValidationFileDtoBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportValidation/get_validation_result?";
        if (objectID === null)
            throw new Error("The parameter 'objectID' cannot be null.");
        else if (objectID !== undefined)
            url_ += "objectID=" + encodeURIComponent("" + objectID) + "&";
        if (objectInstanceID === null)
            throw new Error("The parameter 'objectInstanceID' cannot be null.");
        else if (objectInstanceID !== undefined)
            url_ += "objectInstanceID=" + encodeURIComponent("" + objectInstanceID) + "&";
        if (attachmentID === null)
            throw new Error("The parameter 'attachmentID' cannot be null.");
        else if (attachmentID !== undefined)
            url_ += "attachmentID=" + encodeURIComponent("" + attachmentID) + "&";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResult(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValidationFileDtoBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValidationFileDtoBaseResponse>;
        }));
    }

    protected processResult(response: HttpResponseBase): Observable<ValidationFileDtoBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValidationFileDtoBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValidationFileDtoBaseResponse>(null as any);
    }
}

export class AccessRequest implements IAccessRequest {
    lstUserRoles?: string[] | undefined;
    lstDocAccessRoles?: string[] | undefined;

    constructor(data?: IAccessRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lstUserRoles"])) {
                this.lstUserRoles = [] as any;
                for (let item of _data["lstUserRoles"])
                    this.lstUserRoles!.push(item);
            }
            if (Array.isArray(_data["lstDocAccessRoles"])) {
                this.lstDocAccessRoles = [] as any;
                for (let item of _data["lstDocAccessRoles"])
                    this.lstDocAccessRoles!.push(item);
            }
        }
    }

    static fromJS(data: any): AccessRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AccessRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lstUserRoles)) {
            data["lstUserRoles"] = [];
            for (let item of this.lstUserRoles)
                data["lstUserRoles"].push(item);
        }
        if (Array.isArray(this.lstDocAccessRoles)) {
            data["lstDocAccessRoles"] = [];
            for (let item of this.lstDocAccessRoles)
                data["lstDocAccessRoles"].push(item);
        }
        return data;
    }
}

export interface IAccessRequest {
    lstUserRoles?: string[] | undefined;
    lstDocAccessRoles?: string[] | undefined;
}

export class Address implements IAddress {
    addressID?: number | undefined;
    addressGUID?: string | undefined;
    addressLine1?: string | undefined;
    addressLine2?: string | undefined;
    addressLine3?: string | undefined;
    addressLine4?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    country?: string | undefined;
    countryID?: number;
    postalCode?: string | undefined;
    startDateDay?: string | undefined;
    startDateMonth?: string | undefined;
    startDateYear?: string | undefined;
    endDateDay?: string | undefined;
    endDateMonth?: string | undefined;
    endDateYear?: string | undefined;
    addressTypID?: number;
    addressTypeDesc?: string | undefined;
    userId?: number;
    createdDate?: string | undefined;
    modifiedDate?: string | undefined;
    modifiedBy?: number;
    applicationID?: number;
    qfcNumber?: string | undefined;
    aiNumber?: string | undefined;
    fromDate?: Date | undefined;
    toDate?: Date | undefined;

    constructor(data?: IAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addressID = _data["addressID"];
            this.addressGUID = _data["addressGUID"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.addressLine3 = _data["addressLine3"];
            this.addressLine4 = _data["addressLine4"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.country = _data["country"];
            this.countryID = _data["countryID"];
            this.postalCode = _data["postalCode"];
            this.startDateDay = _data["startDateDay"];
            this.startDateMonth = _data["startDateMonth"];
            this.startDateYear = _data["startDateYear"];
            this.endDateDay = _data["endDateDay"];
            this.endDateMonth = _data["endDateMonth"];
            this.endDateYear = _data["endDateYear"];
            this.addressTypID = _data["addressTypID"];
            this.addressTypeDesc = _data["addressTypeDesc"];
            this.userId = _data["userId"];
            this.createdDate = _data["createdDate"];
            this.modifiedDate = _data["modifiedDate"];
            this.modifiedBy = _data["modifiedBy"];
            this.applicationID = _data["applicationID"];
            this.qfcNumber = _data["qfcNumber"];
            this.aiNumber = _data["aiNumber"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addressID"] = this.addressID;
        data["addressGUID"] = this.addressGUID;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["addressLine3"] = this.addressLine3;
        data["addressLine4"] = this.addressLine4;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["countryID"] = this.countryID;
        data["postalCode"] = this.postalCode;
        data["startDateDay"] = this.startDateDay;
        data["startDateMonth"] = this.startDateMonth;
        data["startDateYear"] = this.startDateYear;
        data["endDateDay"] = this.endDateDay;
        data["endDateMonth"] = this.endDateMonth;
        data["endDateYear"] = this.endDateYear;
        data["addressTypID"] = this.addressTypID;
        data["addressTypeDesc"] = this.addressTypeDesc;
        data["userId"] = this.userId;
        data["createdDate"] = this.createdDate;
        data["modifiedDate"] = this.modifiedDate;
        data["modifiedBy"] = this.modifiedBy;
        data["applicationID"] = this.applicationID;
        data["qfcNumber"] = this.qfcNumber;
        data["aiNumber"] = this.aiNumber;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAddress {
    addressID?: number | undefined;
    addressGUID?: string | undefined;
    addressLine1?: string | undefined;
    addressLine2?: string | undefined;
    addressLine3?: string | undefined;
    addressLine4?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    country?: string | undefined;
    countryID?: number;
    postalCode?: string | undefined;
    startDateDay?: string | undefined;
    startDateMonth?: string | undefined;
    startDateYear?: string | undefined;
    endDateDay?: string | undefined;
    endDateMonth?: string | undefined;
    endDateYear?: string | undefined;
    addressTypID?: number;
    addressTypeDesc?: string | undefined;
    userId?: number;
    createdDate?: string | undefined;
    modifiedDate?: string | undefined;
    modifiedBy?: number;
    applicationID?: number;
    qfcNumber?: string | undefined;
    aiNumber?: string | undefined;
    fromDate?: Date | undefined;
    toDate?: Date | undefined;
}

export class AppControls implements IAppControls {
    controlId?: number;
    controlTypeID?: number;
    controlName?: string | undefined;
    showProperty?: boolean;
    enableProperty?: boolean;

    constructor(data?: IAppControls) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.controlId = _data["controlId"];
            this.controlTypeID = _data["controlTypeID"];
            this.controlName = _data["controlName"];
            this.showProperty = _data["showProperty"];
            this.enableProperty = _data["enableProperty"];
        }
    }

    static fromJS(data: any): AppControls {
        data = typeof data === 'object' ? data : {};
        let result = new AppControls();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["controlId"] = this.controlId;
        data["controlTypeID"] = this.controlTypeID;
        data["controlName"] = this.controlName;
        data["showProperty"] = this.showProperty;
        data["enableProperty"] = this.enableProperty;
        return data;
    }
}

export interface IAppControls {
    controlId?: number;
    controlTypeID?: number;
    controlName?: string | undefined;
    showProperty?: boolean;
    enableProperty?: boolean;
}

export class AppControlsListBaseResponse implements IAppControlsListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: AppControls[] | undefined;

    constructor(data?: IAppControlsListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["response"])) {
                this.response = [] as any;
                for (let item of _data["response"])
                    this.response!.push(AppControls.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppControlsListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AppControlsListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.response)) {
            data["response"] = [];
            for (let item of this.response)
                data["response"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAppControlsListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: AppControls[] | undefined;
}

export class AppRoles implements IAppRoles {
    roleId?: number;
    roleDescription?: string | undefined;
    roleValid?: boolean;

    constructor(data?: IAppRoles) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleDescription = _data["roleDescription"];
            this.roleValid = _data["roleValid"];
        }
    }

    static fromJS(data: any): AppRoles {
        data = typeof data === 'object' ? data : {};
        let result = new AppRoles();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleDescription"] = this.roleDescription;
        data["roleValid"] = this.roleValid;
        return data;
    }
}

export interface IAppRoles {
    roleId?: number;
    roleDescription?: string | undefined;
    roleValid?: boolean;
}

export class AppRolesListBaseResponse implements IAppRolesListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: AppRoles[] | undefined;

    constructor(data?: IAppRolesListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["response"])) {
                this.response = [] as any;
                for (let item of _data["response"])
                    this.response!.push(AppRoles.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppRolesListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AppRolesListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.response)) {
            data["response"] = [];
            for (let item of this.response)
                data["response"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAppRolesListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: AppRoles[] | undefined;
}

export class ApplicationDataDto implements IApplicationDataDto {
    objIndividualDetails?: IndividualDetailsDto;
    lstControledFunctionIDs?: ControlledFunctionDto[] | undefined;

    constructor(data?: IApplicationDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objIndividualDetails = _data["objIndividualDetails"] ? IndividualDetailsDto.fromJS(_data["objIndividualDetails"]) : <any>undefined;
            if (Array.isArray(_data["lstControledFunctionIDs"])) {
                this.lstControledFunctionIDs = [] as any;
                for (let item of _data["lstControledFunctionIDs"])
                    this.lstControledFunctionIDs!.push(ControlledFunctionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApplicationDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objIndividualDetails"] = this.objIndividualDetails ? this.objIndividualDetails.toJSON() : <any>undefined;
        if (Array.isArray(this.lstControledFunctionIDs)) {
            data["lstControledFunctionIDs"] = [];
            for (let item of this.lstControledFunctionIDs)
                data["lstControledFunctionIDs"].push(item.toJSON());
        }
        return data;
    }
}

export interface IApplicationDataDto {
    objIndividualDetails?: IndividualDetailsDto;
    lstControledFunctionIDs?: ControlledFunctionDto[] | undefined;
}

export class ApplicationDetail implements IApplicationDetail {
    firmID?: number;
    fullName?: string | undefined;
    id?: number;
    userId?: number;
    value?: string | undefined;
    qfcNmuner?: string | undefined;
    applContactDetailID?: number;
    applicationStatusTypeID?: number;
    addressLine1?: string | undefined;
    addressLine2?: string | undefined;
    addressLine3?: string | undefined;
    addressLine4?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    countryID?: string | undefined;
    countryName?: string | undefined;
    postalCode?: string | undefined;
    firmName?: string | undefined;
    functionID?: number;
    positionOfMainContact?: string | undefined;
    contactID?: number;
    nameOfMainContact?: string | undefined;
    telephoneNumber?: string | undefined;
    faxNumber?: string | undefined;
    emailAddressOfMainAccount?: string | undefined;
    preferredMethodOfContact?: string | undefined;
    primarySupervisorEmailAddress?: string | undefined;
    secondarySupervisorEmailAddress?: string | undefined;
    additionalSupervisorEmailAddress?: string | undefined;
    amlPrimarySupervisorEmailAddress?: string | undefined;
    amlSecondarySupervisorEmailAddress?: string | undefined;
    additionalAMLSupervisorEmailAddress?: string | undefined;
    directorEmailAddress?: string | undefined;
    amlDirectorEmailAddress?: string | undefined;
    rsgEmailAddress?: string | undefined;
    firmTypeID?: number;
    qfcNumber?: string | undefined;
    aiNumber?: string | undefined;
    applicationID?: number;
    formTypeID?: number;
    applStatusTypeID?: number;
    arrangementTypeID?: number | undefined;
    arrangementTypeDesc?: string | undefined;
    arrangementTypeOtherDesc?: string | undefined;
    competenciesAndExp?: string | undefined;
    cfExcercisedDesc?: string | undefined;
    currentJobTitle?: string | undefined;
    jobTitleChangeFlag?: boolean | undefined;
    proposedJobTitle?: string | undefined;
    jobDesc?: string | undefined;
    pastPositionFlag?: boolean | undefined;
    pastPositionDesc?: string | undefined;
    fandPAddnlInfo?: string | undefined;
    fandPChangeDesc?: string | undefined;
    withdrawlReasonDesc?: string | undefined;
    altArrangementFlag?: boolean | undefined;
    altArrangementDesc?: string | undefined;
    wcfAddnlInfo?: string | undefined;
    cfApplicationDetail?: string | undefined;
    residencyNAFlag?: boolean | undefined;
    aliasesNAFlag?: boolean | undefined;
    careerHistoryNAFlag?: boolean | undefined;
    careerHistoryNAReason?: string | undefined;
    prevEmploymentFlag?: boolean | undefined;
    appUserID?: number;
    appCreatedBy?: number;
    modifiedDate?: string | undefined;
    userModified?: number;
    createdDate?: string | undefined;
    objFirmContactDetails?: FirmContactDetails;
    objIndividualDetails?: IndividualDetails;
    formTypeDesc?: string | undefined;
    applStatusTypeDesc?: string | undefined;
    reglsNAFlag?: boolean | undefined;
    nationalIdNAFlag?: boolean | undefined;
    qatarRelocationNAFlag?: boolean | undefined;
    profDevFalg?: boolean | undefined;
    profMembFlag?: boolean | undefined;
    higherEduFlag?: boolean | undefined;
    appStatusDate?: Date;
    appRecieveDate?: Date;
    coreApplicationID?: number;
    lstControledFunction?: ControledFunction[] | undefined;
    anyFileToAttachFlag?: boolean | undefined;
    additionalFileFlag?: boolean | undefined;
    applicationDate?: string | undefined;
    wObjectSOStatusID?: number | undefined;
    prevApplicationId?: number | undefined;
    additionalSupervisorFlag?: boolean | undefined;
    positionHeldFlag?: boolean | undefined;
    supervisingFlag?: boolean | undefined;
    resubmissionComments?: string | undefined;
    applicantName?: string | undefined;
    pageFlag?: string | undefined;
    reasonForDelayInFiling?: string | undefined;
    isOrdinarilyResidentFlag?: boolean | undefined;
    proposedRelocationDateDay?: number;
    proposedRelocationDateMonth?: number;
    proposedRelocationDateYear?: number;
    updateWobjectStatus?: boolean;

    constructor(data?: IApplicationDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmID = _data["firmID"];
            this.fullName = _data["fullName"];
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.value = _data["value"];
            this.qfcNmuner = _data["qfcNmuner"];
            this.applContactDetailID = _data["applContactDetailID"];
            this.applicationStatusTypeID = _data["applicationStatusTypeID"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.addressLine3 = _data["addressLine3"];
            this.addressLine4 = _data["addressLine4"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.countryID = _data["countryID"];
            this.countryName = _data["countryName"];
            this.postalCode = _data["postalCode"];
            this.firmName = _data["firmName"];
            this.functionID = _data["functionID"];
            this.positionOfMainContact = _data["positionOfMainContact"];
            this.contactID = _data["contactID"];
            this.nameOfMainContact = _data["nameOfMainContact"];
            this.telephoneNumber = _data["telephoneNumber"];
            this.faxNumber = _data["faxNumber"];
            this.emailAddressOfMainAccount = _data["emailAddressOfMainAccount"];
            this.preferredMethodOfContact = _data["preferredMethodOfContact"];
            this.primarySupervisorEmailAddress = _data["primarySupervisorEmailAddress"];
            this.secondarySupervisorEmailAddress = _data["secondarySupervisorEmailAddress"];
            this.additionalSupervisorEmailAddress = _data["additionalSupervisorEmailAddress"];
            this.amlPrimarySupervisorEmailAddress = _data["amlPrimarySupervisorEmailAddress"];
            this.amlSecondarySupervisorEmailAddress = _data["amlSecondarySupervisorEmailAddress"];
            this.additionalAMLSupervisorEmailAddress = _data["additionalAMLSupervisorEmailAddress"];
            this.directorEmailAddress = _data["directorEmailAddress"];
            this.amlDirectorEmailAddress = _data["amlDirectorEmailAddress"];
            this.rsgEmailAddress = _data["rsgEmailAddress"];
            this.firmTypeID = _data["firmTypeID"];
            this.qfcNumber = _data["qfcNumber"];
            this.aiNumber = _data["aiNumber"];
            this.applicationID = _data["applicationID"];
            this.formTypeID = _data["formTypeID"];
            this.applStatusTypeID = _data["applStatusTypeID"];
            this.arrangementTypeID = _data["arrangementTypeID"];
            this.arrangementTypeDesc = _data["arrangementTypeDesc"];
            this.arrangementTypeOtherDesc = _data["arrangementTypeOtherDesc"];
            this.competenciesAndExp = _data["competenciesAndExp"];
            this.cfExcercisedDesc = _data["cfExcercisedDesc"];
            this.currentJobTitle = _data["currentJobTitle"];
            this.jobTitleChangeFlag = _data["jobTitleChangeFlag"];
            this.proposedJobTitle = _data["proposedJobTitle"];
            this.jobDesc = _data["jobDesc"];
            this.pastPositionFlag = _data["pastPositionFlag"];
            this.pastPositionDesc = _data["pastPositionDesc"];
            this.fandPAddnlInfo = _data["fandPAddnlInfo"];
            this.fandPChangeDesc = _data["fandPChangeDesc"];
            this.withdrawlReasonDesc = _data["withdrawlReasonDesc"];
            this.altArrangementFlag = _data["altArrangementFlag"];
            this.altArrangementDesc = _data["altArrangementDesc"];
            this.wcfAddnlInfo = _data["wcfAddnlInfo"];
            this.cfApplicationDetail = _data["cfApplicationDetail"];
            this.residencyNAFlag = _data["residencyNAFlag"];
            this.aliasesNAFlag = _data["aliasesNAFlag"];
            this.careerHistoryNAFlag = _data["careerHistoryNAFlag"];
            this.careerHistoryNAReason = _data["careerHistoryNAReason"];
            this.prevEmploymentFlag = _data["prevEmploymentFlag"];
            this.appUserID = _data["appUserID"];
            this.appCreatedBy = _data["appCreatedBy"];
            this.modifiedDate = _data["modifiedDate"];
            this.userModified = _data["userModified"];
            this.createdDate = _data["createdDate"];
            this.objFirmContactDetails = _data["objFirmContactDetails"] ? FirmContactDetails.fromJS(_data["objFirmContactDetails"]) : <any>undefined;
            this.objIndividualDetails = _data["objIndividualDetails"] ? IndividualDetails.fromJS(_data["objIndividualDetails"]) : <any>undefined;
            this.formTypeDesc = _data["formTypeDesc"];
            this.applStatusTypeDesc = _data["applStatusTypeDesc"];
            this.reglsNAFlag = _data["reglsNAFlag"];
            this.nationalIdNAFlag = _data["nationalIdNAFlag"];
            this.qatarRelocationNAFlag = _data["qatarRelocationNAFlag"];
            this.profDevFalg = _data["profDevFalg"];
            this.profMembFlag = _data["profMembFlag"];
            this.higherEduFlag = _data["higherEduFlag"];
            this.appStatusDate = _data["appStatusDate"] ? new Date(_data["appStatusDate"].toString()) : <any>undefined;
            this.appRecieveDate = _data["appRecieveDate"] ? new Date(_data["appRecieveDate"].toString()) : <any>undefined;
            this.coreApplicationID = _data["coreApplicationID"];
            if (Array.isArray(_data["lstControledFunction"])) {
                this.lstControledFunction = [] as any;
                for (let item of _data["lstControledFunction"])
                    this.lstControledFunction!.push(ControledFunction.fromJS(item));
            }
            this.anyFileToAttachFlag = _data["anyFileToAttachFlag"];
            this.additionalFileFlag = _data["additionalFileFlag"];
            this.applicationDate = _data["applicationDate"];
            this.wObjectSOStatusID = _data["wObjectSOStatusID"];
            this.prevApplicationId = _data["prevApplicationId"];
            this.additionalSupervisorFlag = _data["additionalSupervisorFlag"];
            this.positionHeldFlag = _data["positionHeldFlag"];
            this.supervisingFlag = _data["supervisingFlag"];
            this.resubmissionComments = _data["resubmissionComments"];
            this.applicantName = _data["applicantName"];
            this.pageFlag = _data["pageFlag"];
            this.reasonForDelayInFiling = _data["reasonForDelayInFiling"];
            this.isOrdinarilyResidentFlag = _data["isOrdinarilyResidentFlag"];
            this.proposedRelocationDateDay = _data["proposedRelocationDateDay"];
            this.proposedRelocationDateMonth = _data["proposedRelocationDateMonth"];
            this.proposedRelocationDateYear = _data["proposedRelocationDateYear"];
            this.updateWobjectStatus = _data["updateWobjectStatus"];
        }
    }

    static fromJS(data: any): ApplicationDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmID"] = this.firmID;
        data["fullName"] = this.fullName;
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["value"] = this.value;
        data["qfcNmuner"] = this.qfcNmuner;
        data["applContactDetailID"] = this.applContactDetailID;
        data["applicationStatusTypeID"] = this.applicationStatusTypeID;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["addressLine3"] = this.addressLine3;
        data["addressLine4"] = this.addressLine4;
        data["city"] = this.city;
        data["state"] = this.state;
        data["countryID"] = this.countryID;
        data["countryName"] = this.countryName;
        data["postalCode"] = this.postalCode;
        data["firmName"] = this.firmName;
        data["functionID"] = this.functionID;
        data["positionOfMainContact"] = this.positionOfMainContact;
        data["contactID"] = this.contactID;
        data["nameOfMainContact"] = this.nameOfMainContact;
        data["telephoneNumber"] = this.telephoneNumber;
        data["faxNumber"] = this.faxNumber;
        data["emailAddressOfMainAccount"] = this.emailAddressOfMainAccount;
        data["preferredMethodOfContact"] = this.preferredMethodOfContact;
        data["primarySupervisorEmailAddress"] = this.primarySupervisorEmailAddress;
        data["secondarySupervisorEmailAddress"] = this.secondarySupervisorEmailAddress;
        data["additionalSupervisorEmailAddress"] = this.additionalSupervisorEmailAddress;
        data["amlPrimarySupervisorEmailAddress"] = this.amlPrimarySupervisorEmailAddress;
        data["amlSecondarySupervisorEmailAddress"] = this.amlSecondarySupervisorEmailAddress;
        data["additionalAMLSupervisorEmailAddress"] = this.additionalAMLSupervisorEmailAddress;
        data["directorEmailAddress"] = this.directorEmailAddress;
        data["amlDirectorEmailAddress"] = this.amlDirectorEmailAddress;
        data["rsgEmailAddress"] = this.rsgEmailAddress;
        data["firmTypeID"] = this.firmTypeID;
        data["qfcNumber"] = this.qfcNumber;
        data["aiNumber"] = this.aiNumber;
        data["applicationID"] = this.applicationID;
        data["formTypeID"] = this.formTypeID;
        data["applStatusTypeID"] = this.applStatusTypeID;
        data["arrangementTypeID"] = this.arrangementTypeID;
        data["arrangementTypeDesc"] = this.arrangementTypeDesc;
        data["arrangementTypeOtherDesc"] = this.arrangementTypeOtherDesc;
        data["competenciesAndExp"] = this.competenciesAndExp;
        data["cfExcercisedDesc"] = this.cfExcercisedDesc;
        data["currentJobTitle"] = this.currentJobTitle;
        data["jobTitleChangeFlag"] = this.jobTitleChangeFlag;
        data["proposedJobTitle"] = this.proposedJobTitle;
        data["jobDesc"] = this.jobDesc;
        data["pastPositionFlag"] = this.pastPositionFlag;
        data["pastPositionDesc"] = this.pastPositionDesc;
        data["fandPAddnlInfo"] = this.fandPAddnlInfo;
        data["fandPChangeDesc"] = this.fandPChangeDesc;
        data["withdrawlReasonDesc"] = this.withdrawlReasonDesc;
        data["altArrangementFlag"] = this.altArrangementFlag;
        data["altArrangementDesc"] = this.altArrangementDesc;
        data["wcfAddnlInfo"] = this.wcfAddnlInfo;
        data["cfApplicationDetail"] = this.cfApplicationDetail;
        data["residencyNAFlag"] = this.residencyNAFlag;
        data["aliasesNAFlag"] = this.aliasesNAFlag;
        data["careerHistoryNAFlag"] = this.careerHistoryNAFlag;
        data["careerHistoryNAReason"] = this.careerHistoryNAReason;
        data["prevEmploymentFlag"] = this.prevEmploymentFlag;
        data["appUserID"] = this.appUserID;
        data["appCreatedBy"] = this.appCreatedBy;
        data["modifiedDate"] = this.modifiedDate;
        data["userModified"] = this.userModified;
        data["createdDate"] = this.createdDate;
        data["objFirmContactDetails"] = this.objFirmContactDetails ? this.objFirmContactDetails.toJSON() : <any>undefined;
        data["objIndividualDetails"] = this.objIndividualDetails ? this.objIndividualDetails.toJSON() : <any>undefined;
        data["formTypeDesc"] = this.formTypeDesc;
        data["applStatusTypeDesc"] = this.applStatusTypeDesc;
        data["reglsNAFlag"] = this.reglsNAFlag;
        data["nationalIdNAFlag"] = this.nationalIdNAFlag;
        data["qatarRelocationNAFlag"] = this.qatarRelocationNAFlag;
        data["profDevFalg"] = this.profDevFalg;
        data["profMembFlag"] = this.profMembFlag;
        data["higherEduFlag"] = this.higherEduFlag;
        data["appStatusDate"] = this.appStatusDate ? this.appStatusDate.toISOString() : <any>undefined;
        data["appRecieveDate"] = this.appRecieveDate ? this.appRecieveDate.toISOString() : <any>undefined;
        data["coreApplicationID"] = this.coreApplicationID;
        if (Array.isArray(this.lstControledFunction)) {
            data["lstControledFunction"] = [];
            for (let item of this.lstControledFunction)
                data["lstControledFunction"].push(item.toJSON());
        }
        data["anyFileToAttachFlag"] = this.anyFileToAttachFlag;
        data["additionalFileFlag"] = this.additionalFileFlag;
        data["applicationDate"] = this.applicationDate;
        data["wObjectSOStatusID"] = this.wObjectSOStatusID;
        data["prevApplicationId"] = this.prevApplicationId;
        data["additionalSupervisorFlag"] = this.additionalSupervisorFlag;
        data["positionHeldFlag"] = this.positionHeldFlag;
        data["supervisingFlag"] = this.supervisingFlag;
        data["resubmissionComments"] = this.resubmissionComments;
        data["applicantName"] = this.applicantName;
        data["pageFlag"] = this.pageFlag;
        data["reasonForDelayInFiling"] = this.reasonForDelayInFiling;
        data["isOrdinarilyResidentFlag"] = this.isOrdinarilyResidentFlag;
        data["proposedRelocationDateDay"] = this.proposedRelocationDateDay;
        data["proposedRelocationDateMonth"] = this.proposedRelocationDateMonth;
        data["proposedRelocationDateYear"] = this.proposedRelocationDateYear;
        data["updateWobjectStatus"] = this.updateWobjectStatus;
        return data;
    }
}

export interface IApplicationDetail {
    firmID?: number;
    fullName?: string | undefined;
    id?: number;
    userId?: number;
    value?: string | undefined;
    qfcNmuner?: string | undefined;
    applContactDetailID?: number;
    applicationStatusTypeID?: number;
    addressLine1?: string | undefined;
    addressLine2?: string | undefined;
    addressLine3?: string | undefined;
    addressLine4?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    countryID?: string | undefined;
    countryName?: string | undefined;
    postalCode?: string | undefined;
    firmName?: string | undefined;
    functionID?: number;
    positionOfMainContact?: string | undefined;
    contactID?: number;
    nameOfMainContact?: string | undefined;
    telephoneNumber?: string | undefined;
    faxNumber?: string | undefined;
    emailAddressOfMainAccount?: string | undefined;
    preferredMethodOfContact?: string | undefined;
    primarySupervisorEmailAddress?: string | undefined;
    secondarySupervisorEmailAddress?: string | undefined;
    additionalSupervisorEmailAddress?: string | undefined;
    amlPrimarySupervisorEmailAddress?: string | undefined;
    amlSecondarySupervisorEmailAddress?: string | undefined;
    additionalAMLSupervisorEmailAddress?: string | undefined;
    directorEmailAddress?: string | undefined;
    amlDirectorEmailAddress?: string | undefined;
    rsgEmailAddress?: string | undefined;
    firmTypeID?: number;
    qfcNumber?: string | undefined;
    aiNumber?: string | undefined;
    applicationID?: number;
    formTypeID?: number;
    applStatusTypeID?: number;
    arrangementTypeID?: number | undefined;
    arrangementTypeDesc?: string | undefined;
    arrangementTypeOtherDesc?: string | undefined;
    competenciesAndExp?: string | undefined;
    cfExcercisedDesc?: string | undefined;
    currentJobTitle?: string | undefined;
    jobTitleChangeFlag?: boolean | undefined;
    proposedJobTitle?: string | undefined;
    jobDesc?: string | undefined;
    pastPositionFlag?: boolean | undefined;
    pastPositionDesc?: string | undefined;
    fandPAddnlInfo?: string | undefined;
    fandPChangeDesc?: string | undefined;
    withdrawlReasonDesc?: string | undefined;
    altArrangementFlag?: boolean | undefined;
    altArrangementDesc?: string | undefined;
    wcfAddnlInfo?: string | undefined;
    cfApplicationDetail?: string | undefined;
    residencyNAFlag?: boolean | undefined;
    aliasesNAFlag?: boolean | undefined;
    careerHistoryNAFlag?: boolean | undefined;
    careerHistoryNAReason?: string | undefined;
    prevEmploymentFlag?: boolean | undefined;
    appUserID?: number;
    appCreatedBy?: number;
    modifiedDate?: string | undefined;
    userModified?: number;
    createdDate?: string | undefined;
    objFirmContactDetails?: FirmContactDetails;
    objIndividualDetails?: IndividualDetails;
    formTypeDesc?: string | undefined;
    applStatusTypeDesc?: string | undefined;
    reglsNAFlag?: boolean | undefined;
    nationalIdNAFlag?: boolean | undefined;
    qatarRelocationNAFlag?: boolean | undefined;
    profDevFalg?: boolean | undefined;
    profMembFlag?: boolean | undefined;
    higherEduFlag?: boolean | undefined;
    appStatusDate?: Date;
    appRecieveDate?: Date;
    coreApplicationID?: number;
    lstControledFunction?: ControledFunction[] | undefined;
    anyFileToAttachFlag?: boolean | undefined;
    additionalFileFlag?: boolean | undefined;
    applicationDate?: string | undefined;
    wObjectSOStatusID?: number | undefined;
    prevApplicationId?: number | undefined;
    additionalSupervisorFlag?: boolean | undefined;
    positionHeldFlag?: boolean | undefined;
    supervisingFlag?: boolean | undefined;
    resubmissionComments?: string | undefined;
    applicantName?: string | undefined;
    pageFlag?: string | undefined;
    reasonForDelayInFiling?: string | undefined;
    isOrdinarilyResidentFlag?: boolean | undefined;
    proposedRelocationDateDay?: number;
    proposedRelocationDateMonth?: number;
    proposedRelocationDateYear?: number;
    updateWobjectStatus?: boolean;
}

export class ApplicationDetailDto implements IApplicationDetailDto {
    applicationID?: number;
    applStatusTypeID?: number;
    wObjectSOStatusID?: number | undefined;
    updateWobjectStatus?: boolean;
    resubmissionComments?: string | undefined;
    appUserID?: number;
    qfcNmuner?: string | undefined;
    aiNumber?: string | undefined;
    formTypeID?: number;
    arrangementTypeID?: number | undefined;
    arrangementTypeDesc?: string | undefined;
    arrangementTypeOtherDesc?: string | undefined;
    competenciesAndExp?: string | undefined;
    cfExcercisedDesc?: string | undefined;
    currentJobTitle?: string | undefined;
    jobTitleChangeFlag?: boolean | undefined;
    proposedJobTitle?: string | undefined;
    jobDesc?: string | undefined;
    pastPositionFlag?: boolean | undefined;
    pastPositionDesc?: string | undefined;
    fandPAddnlInfo?: string | undefined;
    fandPChangeDesc?: string | undefined;
    withdrawlReasonDesc?: string | undefined;
    altArrangementFlag?: boolean | undefined;
    altArrangementDesc?: string | undefined;
    wcfAddnlInfo?: string | undefined;
    cfApplicationDetail?: string | undefined;
    residencyNAFlag?: boolean | undefined;
    aliasesNAFlag?: boolean | undefined;
    careerHistoryNAFlag?: boolean | undefined;
    careerHistoryNAReason?: string | undefined;
    prevEmploymentFlag?: boolean | undefined;
    appCreatedBy?: number;
    reglsNAFlag?: boolean | undefined;
    nationalIdNAFlag?: boolean | undefined;
    qatarRelocationNAFlag?: boolean | undefined;
    profDevFalg?: boolean | undefined;
    profMembFlag?: boolean | undefined;
    higherEduFlag?: boolean | undefined;
    anyFileToAttachFlag?: boolean | undefined;
    additionalFileFlag?: boolean | undefined;
    applicationDate?: string | undefined;
    prevApplicationId?: number | undefined;
    additionalSupervisorFlag?: boolean | undefined;
    positionHeldFlag?: boolean | undefined;
    supervisingFlag?: boolean | undefined;
    applicantName?: string | undefined;
    reasonForDelayInFiling?: string | undefined;
    isOrdinarilyResidentFlag?: boolean | undefined;
    proposedRelocationDateDay?: number;
    proposedRelocationDateMonth?: number;
    proposedRelocationDateYear?: number;

    constructor(data?: IApplicationDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationID = _data["applicationID"];
            this.applStatusTypeID = _data["applStatusTypeID"];
            this.wObjectSOStatusID = _data["wObjectSOStatusID"];
            this.updateWobjectStatus = _data["updateWobjectStatus"];
            this.resubmissionComments = _data["resubmissionComments"];
            this.appUserID = _data["appUserID"];
            this.qfcNmuner = _data["qfcNmuner"];
            this.aiNumber = _data["aiNumber"];
            this.formTypeID = _data["formTypeID"];
            this.arrangementTypeID = _data["arrangementTypeID"];
            this.arrangementTypeDesc = _data["arrangementTypeDesc"];
            this.arrangementTypeOtherDesc = _data["arrangementTypeOtherDesc"];
            this.competenciesAndExp = _data["competenciesAndExp"];
            this.cfExcercisedDesc = _data["cfExcercisedDesc"];
            this.currentJobTitle = _data["currentJobTitle"];
            this.jobTitleChangeFlag = _data["jobTitleChangeFlag"];
            this.proposedJobTitle = _data["proposedJobTitle"];
            this.jobDesc = _data["jobDesc"];
            this.pastPositionFlag = _data["pastPositionFlag"];
            this.pastPositionDesc = _data["pastPositionDesc"];
            this.fandPAddnlInfo = _data["fandPAddnlInfo"];
            this.fandPChangeDesc = _data["fandPChangeDesc"];
            this.withdrawlReasonDesc = _data["withdrawlReasonDesc"];
            this.altArrangementFlag = _data["altArrangementFlag"];
            this.altArrangementDesc = _data["altArrangementDesc"];
            this.wcfAddnlInfo = _data["wcfAddnlInfo"];
            this.cfApplicationDetail = _data["cfApplicationDetail"];
            this.residencyNAFlag = _data["residencyNAFlag"];
            this.aliasesNAFlag = _data["aliasesNAFlag"];
            this.careerHistoryNAFlag = _data["careerHistoryNAFlag"];
            this.careerHistoryNAReason = _data["careerHistoryNAReason"];
            this.prevEmploymentFlag = _data["prevEmploymentFlag"];
            this.appCreatedBy = _data["appCreatedBy"];
            this.reglsNAFlag = _data["reglsNAFlag"];
            this.nationalIdNAFlag = _data["nationalIdNAFlag"];
            this.qatarRelocationNAFlag = _data["qatarRelocationNAFlag"];
            this.profDevFalg = _data["profDevFalg"];
            this.profMembFlag = _data["profMembFlag"];
            this.higherEduFlag = _data["higherEduFlag"];
            this.anyFileToAttachFlag = _data["anyFileToAttachFlag"];
            this.additionalFileFlag = _data["additionalFileFlag"];
            this.applicationDate = _data["applicationDate"];
            this.prevApplicationId = _data["prevApplicationId"];
            this.additionalSupervisorFlag = _data["additionalSupervisorFlag"];
            this.positionHeldFlag = _data["positionHeldFlag"];
            this.supervisingFlag = _data["supervisingFlag"];
            this.applicantName = _data["applicantName"];
            this.reasonForDelayInFiling = _data["reasonForDelayInFiling"];
            this.isOrdinarilyResidentFlag = _data["isOrdinarilyResidentFlag"];
            this.proposedRelocationDateDay = _data["proposedRelocationDateDay"];
            this.proposedRelocationDateMonth = _data["proposedRelocationDateMonth"];
            this.proposedRelocationDateYear = _data["proposedRelocationDateYear"];
        }
    }

    static fromJS(data: any): ApplicationDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicationID"] = this.applicationID;
        data["applStatusTypeID"] = this.applStatusTypeID;
        data["wObjectSOStatusID"] = this.wObjectSOStatusID;
        data["updateWobjectStatus"] = this.updateWobjectStatus;
        data["resubmissionComments"] = this.resubmissionComments;
        data["appUserID"] = this.appUserID;
        data["qfcNmuner"] = this.qfcNmuner;
        data["aiNumber"] = this.aiNumber;
        data["formTypeID"] = this.formTypeID;
        data["arrangementTypeID"] = this.arrangementTypeID;
        data["arrangementTypeDesc"] = this.arrangementTypeDesc;
        data["arrangementTypeOtherDesc"] = this.arrangementTypeOtherDesc;
        data["competenciesAndExp"] = this.competenciesAndExp;
        data["cfExcercisedDesc"] = this.cfExcercisedDesc;
        data["currentJobTitle"] = this.currentJobTitle;
        data["jobTitleChangeFlag"] = this.jobTitleChangeFlag;
        data["proposedJobTitle"] = this.proposedJobTitle;
        data["jobDesc"] = this.jobDesc;
        data["pastPositionFlag"] = this.pastPositionFlag;
        data["pastPositionDesc"] = this.pastPositionDesc;
        data["fandPAddnlInfo"] = this.fandPAddnlInfo;
        data["fandPChangeDesc"] = this.fandPChangeDesc;
        data["withdrawlReasonDesc"] = this.withdrawlReasonDesc;
        data["altArrangementFlag"] = this.altArrangementFlag;
        data["altArrangementDesc"] = this.altArrangementDesc;
        data["wcfAddnlInfo"] = this.wcfAddnlInfo;
        data["cfApplicationDetail"] = this.cfApplicationDetail;
        data["residencyNAFlag"] = this.residencyNAFlag;
        data["aliasesNAFlag"] = this.aliasesNAFlag;
        data["careerHistoryNAFlag"] = this.careerHistoryNAFlag;
        data["careerHistoryNAReason"] = this.careerHistoryNAReason;
        data["prevEmploymentFlag"] = this.prevEmploymentFlag;
        data["appCreatedBy"] = this.appCreatedBy;
        data["reglsNAFlag"] = this.reglsNAFlag;
        data["nationalIdNAFlag"] = this.nationalIdNAFlag;
        data["qatarRelocationNAFlag"] = this.qatarRelocationNAFlag;
        data["profDevFalg"] = this.profDevFalg;
        data["profMembFlag"] = this.profMembFlag;
        data["higherEduFlag"] = this.higherEduFlag;
        data["anyFileToAttachFlag"] = this.anyFileToAttachFlag;
        data["additionalFileFlag"] = this.additionalFileFlag;
        data["applicationDate"] = this.applicationDate;
        data["prevApplicationId"] = this.prevApplicationId;
        data["additionalSupervisorFlag"] = this.additionalSupervisorFlag;
        data["positionHeldFlag"] = this.positionHeldFlag;
        data["supervisingFlag"] = this.supervisingFlag;
        data["applicantName"] = this.applicantName;
        data["reasonForDelayInFiling"] = this.reasonForDelayInFiling;
        data["isOrdinarilyResidentFlag"] = this.isOrdinarilyResidentFlag;
        data["proposedRelocationDateDay"] = this.proposedRelocationDateDay;
        data["proposedRelocationDateMonth"] = this.proposedRelocationDateMonth;
        data["proposedRelocationDateYear"] = this.proposedRelocationDateYear;
        return data;
    }
}

export interface IApplicationDetailDto {
    applicationID?: number;
    applStatusTypeID?: number;
    wObjectSOStatusID?: number | undefined;
    updateWobjectStatus?: boolean;
    resubmissionComments?: string | undefined;
    appUserID?: number;
    qfcNmuner?: string | undefined;
    aiNumber?: string | undefined;
    formTypeID?: number;
    arrangementTypeID?: number | undefined;
    arrangementTypeDesc?: string | undefined;
    arrangementTypeOtherDesc?: string | undefined;
    competenciesAndExp?: string | undefined;
    cfExcercisedDesc?: string | undefined;
    currentJobTitle?: string | undefined;
    jobTitleChangeFlag?: boolean | undefined;
    proposedJobTitle?: string | undefined;
    jobDesc?: string | undefined;
    pastPositionFlag?: boolean | undefined;
    pastPositionDesc?: string | undefined;
    fandPAddnlInfo?: string | undefined;
    fandPChangeDesc?: string | undefined;
    withdrawlReasonDesc?: string | undefined;
    altArrangementFlag?: boolean | undefined;
    altArrangementDesc?: string | undefined;
    wcfAddnlInfo?: string | undefined;
    cfApplicationDetail?: string | undefined;
    residencyNAFlag?: boolean | undefined;
    aliasesNAFlag?: boolean | undefined;
    careerHistoryNAFlag?: boolean | undefined;
    careerHistoryNAReason?: string | undefined;
    prevEmploymentFlag?: boolean | undefined;
    appCreatedBy?: number;
    reglsNAFlag?: boolean | undefined;
    nationalIdNAFlag?: boolean | undefined;
    qatarRelocationNAFlag?: boolean | undefined;
    profDevFalg?: boolean | undefined;
    profMembFlag?: boolean | undefined;
    higherEduFlag?: boolean | undefined;
    anyFileToAttachFlag?: boolean | undefined;
    additionalFileFlag?: boolean | undefined;
    applicationDate?: string | undefined;
    prevApplicationId?: number | undefined;
    additionalSupervisorFlag?: boolean | undefined;
    positionHeldFlag?: boolean | undefined;
    supervisingFlag?: boolean | undefined;
    applicantName?: string | undefined;
    reasonForDelayInFiling?: string | undefined;
    isOrdinarilyResidentFlag?: boolean | undefined;
    proposedRelocationDateDay?: number;
    proposedRelocationDateMonth?: number;
    proposedRelocationDateYear?: number;
}

export class ApplicationDetailDtoBaseResponse implements IApplicationDetailDtoBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: ApplicationDetailDto;

    constructor(data?: IApplicationDetailDtoBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            this.response = _data["response"] ? ApplicationDetailDto.fromJS(_data["response"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApplicationDetailDtoBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationDetailDtoBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        return data;
    }
}

export interface IApplicationDetailDtoBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: ApplicationDetailDto;
}

export class AttachmentDto implements IAttachmentDto {
    wIndApplicationID?: number | undefined;
    wObjAttachementID?: number | undefined;
    wIndAttachementID?: number | undefined;
    wObjectInstanceID?: number | undefined;
    wObjectID?: number | undefined;
    wObjectInstanceRevNum?: number | undefined;
    docTypeId?: number | undefined;
    docSubTypeId?: number | undefined;
    docTypeDesc?: string | undefined;
    docSubTypeDesc?: string | undefined;
    isPrimaryDoc?: boolean | undefined;
    fileURI?: string | undefined;
    otherDocDesc?: string | undefined;
    filePath?: string | undefined;
    fileName?: string | undefined;
    fileUploadedByName?: string | undefined;
    fileUploadedByEmailAdd?: string | undefined;
    fileUploadedOnDate?: string | undefined;
    statusTypeID?: number | undefined;
    isValidAttachment?: boolean | undefined;
    isDocSupplied?: boolean | undefined;
    reasonforNotAttaching?: string | undefined;
    reasonForRequest?: string | undefined;
    userCreated?: number | undefined;
    wObjectAttachmentStatusID?: number | undefined;
    wObjectSOStatusID?: number | undefined;
    fileUploadedByID?: number | undefined;
    userId?: number | undefined;
    prevAttachmentID?: number | undefined;
    fileInvalidatedID?: number | undefined;
    fileContenct?: string | undefined;
    csV_DocSubTypeId?: string | undefined;
    anyFileToattachFlag?: boolean | undefined;
    additionalFileFlag?: boolean | undefined;
    wTermID?: number | undefined;
    agreedOnTerms?: boolean | undefined;
    termsAgreedDate?: Date | undefined;
    objectSOStatusID?: number | undefined;
    dateCreatedStr?: string | undefined;
    userModified?: number | undefined;
    dateModifiedStr?: string | undefined;
    isChecked?: boolean | undefined;
    userName?: string | undefined;
    attachmentStatusDate?: string | undefined;
    statusDesc?: string | undefined;
    isMandatory?: boolean | undefined;
    isNonSubmissionPermitted?: boolean | undefined;
    isFileSysGenerated?: boolean | undefined;
    isAllowMultiple?: boolean | undefined;
    isFileDescSysGenerated?: boolean | undefined;
    docTypeIdEffectivefromdate?: string | undefined;
    docTypeIdEffectivetodate?: string | undefined;

    constructor(data?: IAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wIndApplicationID = _data["wIndApplicationID"];
            this.wObjAttachementID = _data["wObjAttachementID"];
            this.wIndAttachementID = _data["wIndAttachementID"];
            this.wObjectInstanceID = _data["wObjectInstanceID"];
            this.wObjectID = _data["wObjectID"];
            this.wObjectInstanceRevNum = _data["wObjectInstanceRevNum"];
            this.docTypeId = _data["docTypeId"];
            this.docSubTypeId = _data["docSubTypeId"];
            this.docTypeDesc = _data["docTypeDesc"];
            this.docSubTypeDesc = _data["docSubTypeDesc"];
            this.isPrimaryDoc = _data["isPrimaryDoc"];
            this.fileURI = _data["fileURI"];
            this.otherDocDesc = _data["otherDocDesc"];
            this.filePath = _data["filePath"];
            this.fileName = _data["fileName"];
            this.fileUploadedByName = _data["fileUploadedByName"];
            this.fileUploadedByEmailAdd = _data["fileUploadedByEmailAdd"];
            this.fileUploadedOnDate = _data["fileUploadedOnDate"];
            this.statusTypeID = _data["statusTypeID"];
            this.isValidAttachment = _data["isValidAttachment"];
            this.isDocSupplied = _data["isDocSupplied"];
            this.reasonforNotAttaching = _data["reasonforNotAttaching"];
            this.reasonForRequest = _data["reasonForRequest"];
            this.userCreated = _data["userCreated"];
            this.wObjectAttachmentStatusID = _data["wObjectAttachmentStatusID"];
            this.wObjectSOStatusID = _data["wObjectSOStatusID"];
            this.fileUploadedByID = _data["fileUploadedByID"];
            this.userId = _data["userId"];
            this.prevAttachmentID = _data["prevAttachmentID"];
            this.fileInvalidatedID = _data["fileInvalidatedID"];
            this.fileContenct = _data["fileContenct"];
            this.csV_DocSubTypeId = _data["csV_DocSubTypeId"];
            this.anyFileToattachFlag = _data["anyFileToattachFlag"];
            this.additionalFileFlag = _data["additionalFileFlag"];
            this.wTermID = _data["wTermID"];
            this.agreedOnTerms = _data["agreedOnTerms"];
            this.termsAgreedDate = _data["termsAgreedDate"] ? new Date(_data["termsAgreedDate"].toString()) : <any>undefined;
            this.objectSOStatusID = _data["objectSOStatusID"];
            this.dateCreatedStr = _data["dateCreatedStr"];
            this.userModified = _data["userModified"];
            this.dateModifiedStr = _data["dateModifiedStr"];
            this.isChecked = _data["isChecked"];
            this.userName = _data["userName"];
            this.attachmentStatusDate = _data["attachmentStatusDate"];
            this.statusDesc = _data["statusDesc"];
            this.isMandatory = _data["isMandatory"];
            this.isNonSubmissionPermitted = _data["isNonSubmissionPermitted"];
            this.isFileSysGenerated = _data["isFileSysGenerated"];
            this.isAllowMultiple = _data["isAllowMultiple"];
            this.isFileDescSysGenerated = _data["isFileDescSysGenerated"];
            this.docTypeIdEffectivefromdate = _data["docTypeIdEffectivefromdate"];
            this.docTypeIdEffectivetodate = _data["docTypeIdEffectivetodate"];
        }
    }

    static fromJS(data: any): AttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wIndApplicationID"] = this.wIndApplicationID;
        data["wObjAttachementID"] = this.wObjAttachementID;
        data["wIndAttachementID"] = this.wIndAttachementID;
        data["wObjectInstanceID"] = this.wObjectInstanceID;
        data["wObjectID"] = this.wObjectID;
        data["wObjectInstanceRevNum"] = this.wObjectInstanceRevNum;
        data["docTypeId"] = this.docTypeId;
        data["docSubTypeId"] = this.docSubTypeId;
        data["docTypeDesc"] = this.docTypeDesc;
        data["docSubTypeDesc"] = this.docSubTypeDesc;
        data["isPrimaryDoc"] = this.isPrimaryDoc;
        data["fileURI"] = this.fileURI;
        data["otherDocDesc"] = this.otherDocDesc;
        data["filePath"] = this.filePath;
        data["fileName"] = this.fileName;
        data["fileUploadedByName"] = this.fileUploadedByName;
        data["fileUploadedByEmailAdd"] = this.fileUploadedByEmailAdd;
        data["fileUploadedOnDate"] = this.fileUploadedOnDate;
        data["statusTypeID"] = this.statusTypeID;
        data["isValidAttachment"] = this.isValidAttachment;
        data["isDocSupplied"] = this.isDocSupplied;
        data["reasonforNotAttaching"] = this.reasonforNotAttaching;
        data["reasonForRequest"] = this.reasonForRequest;
        data["userCreated"] = this.userCreated;
        data["wObjectAttachmentStatusID"] = this.wObjectAttachmentStatusID;
        data["wObjectSOStatusID"] = this.wObjectSOStatusID;
        data["fileUploadedByID"] = this.fileUploadedByID;
        data["userId"] = this.userId;
        data["prevAttachmentID"] = this.prevAttachmentID;
        data["fileInvalidatedID"] = this.fileInvalidatedID;
        data["fileContenct"] = this.fileContenct;
        data["csV_DocSubTypeId"] = this.csV_DocSubTypeId;
        data["anyFileToattachFlag"] = this.anyFileToattachFlag;
        data["additionalFileFlag"] = this.additionalFileFlag;
        data["wTermID"] = this.wTermID;
        data["agreedOnTerms"] = this.agreedOnTerms;
        data["termsAgreedDate"] = this.termsAgreedDate ? this.termsAgreedDate.toISOString() : <any>undefined;
        data["objectSOStatusID"] = this.objectSOStatusID;
        data["dateCreatedStr"] = this.dateCreatedStr;
        data["userModified"] = this.userModified;
        data["dateModifiedStr"] = this.dateModifiedStr;
        data["isChecked"] = this.isChecked;
        data["userName"] = this.userName;
        data["attachmentStatusDate"] = this.attachmentStatusDate;
        data["statusDesc"] = this.statusDesc;
        data["isMandatory"] = this.isMandatory;
        data["isNonSubmissionPermitted"] = this.isNonSubmissionPermitted;
        data["isFileSysGenerated"] = this.isFileSysGenerated;
        data["isAllowMultiple"] = this.isAllowMultiple;
        data["isFileDescSysGenerated"] = this.isFileDescSysGenerated;
        data["docTypeIdEffectivefromdate"] = this.docTypeIdEffectivefromdate;
        data["docTypeIdEffectivetodate"] = this.docTypeIdEffectivetodate;
        return data;
    }
}

export interface IAttachmentDto {
    wIndApplicationID?: number | undefined;
    wObjAttachementID?: number | undefined;
    wIndAttachementID?: number | undefined;
    wObjectInstanceID?: number | undefined;
    wObjectID?: number | undefined;
    wObjectInstanceRevNum?: number | undefined;
    docTypeId?: number | undefined;
    docSubTypeId?: number | undefined;
    docTypeDesc?: string | undefined;
    docSubTypeDesc?: string | undefined;
    isPrimaryDoc?: boolean | undefined;
    fileURI?: string | undefined;
    otherDocDesc?: string | undefined;
    filePath?: string | undefined;
    fileName?: string | undefined;
    fileUploadedByName?: string | undefined;
    fileUploadedByEmailAdd?: string | undefined;
    fileUploadedOnDate?: string | undefined;
    statusTypeID?: number | undefined;
    isValidAttachment?: boolean | undefined;
    isDocSupplied?: boolean | undefined;
    reasonforNotAttaching?: string | undefined;
    reasonForRequest?: string | undefined;
    userCreated?: number | undefined;
    wObjectAttachmentStatusID?: number | undefined;
    wObjectSOStatusID?: number | undefined;
    fileUploadedByID?: number | undefined;
    userId?: number | undefined;
    prevAttachmentID?: number | undefined;
    fileInvalidatedID?: number | undefined;
    fileContenct?: string | undefined;
    csV_DocSubTypeId?: string | undefined;
    anyFileToattachFlag?: boolean | undefined;
    additionalFileFlag?: boolean | undefined;
    wTermID?: number | undefined;
    agreedOnTerms?: boolean | undefined;
    termsAgreedDate?: Date | undefined;
    objectSOStatusID?: number | undefined;
    dateCreatedStr?: string | undefined;
    userModified?: number | undefined;
    dateModifiedStr?: string | undefined;
    isChecked?: boolean | undefined;
    userName?: string | undefined;
    attachmentStatusDate?: string | undefined;
    statusDesc?: string | undefined;
    isMandatory?: boolean | undefined;
    isNonSubmissionPermitted?: boolean | undefined;
    isFileSysGenerated?: boolean | undefined;
    isAllowMultiple?: boolean | undefined;
    isFileDescSysGenerated?: boolean | undefined;
    docTypeIdEffectivefromdate?: string | undefined;
    docTypeIdEffectivetodate?: string | undefined;
}

export class AttachmentDtoBaseResponse implements IAttachmentDtoBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: AttachmentDto;

    constructor(data?: IAttachmentDtoBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            this.response = _data["response"] ? AttachmentDto.fromJS(_data["response"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AttachmentDtoBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentDtoBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAttachmentDtoBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: AttachmentDto;
}

export class AttachmentDtoListBaseResponse implements IAttachmentDtoListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: AttachmentDto[] | undefined;

    constructor(data?: IAttachmentDtoListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["response"])) {
                this.response = [] as any;
                for (let item of _data["response"])
                    this.response!.push(AttachmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AttachmentDtoListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentDtoListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.response)) {
            data["response"] = [];
            for (let item of this.response)
                data["response"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAttachmentDtoListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: AttachmentDto[] | undefined;
}

export class AuthenticateRequest implements IAuthenticateRequest {
    userLoginName?: string | undefined;
    userPassword?: string | undefined;
    userIPAddress?: string | undefined;
    userSessionID?: string | undefined;
    termID?: number;
    qfcNumber?: string | undefined;

    constructor(data?: IAuthenticateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userLoginName = _data["userLoginName"];
            this.userPassword = _data["userPassword"];
            this.userIPAddress = _data["userIPAddress"];
            this.userSessionID = _data["userSessionID"];
            this.termID = _data["termID"];
            this.qfcNumber = _data["qfcNumber"];
        }
    }

    static fromJS(data: any): AuthenticateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userLoginName"] = this.userLoginName;
        data["userPassword"] = this.userPassword;
        data["userIPAddress"] = this.userIPAddress;
        data["userSessionID"] = this.userSessionID;
        data["termID"] = this.termID;
        data["qfcNumber"] = this.qfcNumber;
        return data;
    }
}

export interface IAuthenticateRequest {
    userLoginName?: string | undefined;
    userPassword?: string | undefined;
    userIPAddress?: string | undefined;
    userSessionID?: string | undefined;
    termID?: number;
    qfcNumber?: string | undefined;
}

export class AuthenticateResponse implements IAuthenticateResponse {
    userInfo?: WAccessRequests;
    token?: string | undefined;
    userRoles?: AppRoles[] | undefined;
    userRolesString?: string | undefined;
    refreshToken?: string | undefined;
    bIsRegistered?: boolean;
    bIsAuthenticated?: boolean;
    bIsPasswordReset?: boolean;
    wAccessReuestID?: number;
    resetPasswordFlag?: number;
    expiration?: Date;
    message?: string | undefined;

    constructor(data?: IAuthenticateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userInfo = _data["userInfo"] ? WAccessRequests.fromJS(_data["userInfo"]) : <any>undefined;
            this.token = _data["token"];
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles!.push(AppRoles.fromJS(item));
            }
            this.userRolesString = _data["userRolesString"];
            this.refreshToken = _data["refreshToken"];
            this.bIsRegistered = _data["bIsRegistered"];
            this.bIsAuthenticated = _data["bIsAuthenticated"];
            this.bIsPasswordReset = _data["bIsPasswordReset"];
            this.wAccessReuestID = _data["wAccessReuestID"];
            this.resetPasswordFlag = _data["resetPasswordFlag"];
            this.expiration = _data["expiration"] ? new Date(_data["expiration"].toString()) : <any>undefined;
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): AuthenticateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userInfo"] = this.userInfo ? this.userInfo.toJSON() : <any>undefined;
        data["token"] = this.token;
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        data["userRolesString"] = this.userRolesString;
        data["refreshToken"] = this.refreshToken;
        data["bIsRegistered"] = this.bIsRegistered;
        data["bIsAuthenticated"] = this.bIsAuthenticated;
        data["bIsPasswordReset"] = this.bIsPasswordReset;
        data["wAccessReuestID"] = this.wAccessReuestID;
        data["resetPasswordFlag"] = this.resetPasswordFlag;
        data["expiration"] = this.expiration ? this.expiration.toISOString() : <any>undefined;
        data["message"] = this.message;
        return data;
    }
}

export interface IAuthenticateResponse {
    userInfo?: WAccessRequests;
    token?: string | undefined;
    userRoles?: AppRoles[] | undefined;
    userRolesString?: string | undefined;
    refreshToken?: string | undefined;
    bIsRegistered?: boolean;
    bIsAuthenticated?: boolean;
    bIsPasswordReset?: boolean;
    wAccessReuestID?: number;
    resetPasswordFlag?: number;
    expiration?: Date;
    message?: string | undefined;
}

export class AuthenticateResponseBaseResponse implements IAuthenticateResponseBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: AuthenticateResponse;

    constructor(data?: IAuthenticateResponseBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            this.response = _data["response"] ? AuthenticateResponse.fromJS(_data["response"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AuthenticateResponseBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResponseBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAuthenticateResponseBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: AuthenticateResponse;
}

export class BooleanBaseResponse implements IBooleanBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: boolean;

    constructor(data?: IBooleanBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            this.response = _data["response"];
        }
    }

    static fromJS(data: any): BooleanBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BooleanBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        data["response"] = this.response;
        return data;
    }
}

export interface IBooleanBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: boolean;
}

export class Calendar implements ICalendar {
    readonly minSupportedDateTime?: Date;
    readonly maxSupportedDateTime?: Date;
    algorithmType?: CalendarAlgorithmType;
    readonly isReadOnly?: boolean;
    readonly eras?: number[] | undefined;
    twoDigitYearMax?: number;

    constructor(data?: ICalendar) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).minSupportedDateTime = _data["minSupportedDateTime"] ? new Date(_data["minSupportedDateTime"].toString()) : <any>undefined;
            (<any>this).maxSupportedDateTime = _data["maxSupportedDateTime"] ? new Date(_data["maxSupportedDateTime"].toString()) : <any>undefined;
            this.algorithmType = _data["algorithmType"];
            (<any>this).isReadOnly = _data["isReadOnly"];
            if (Array.isArray(_data["eras"])) {
                (<any>this).eras = [] as any;
                for (let item of _data["eras"])
                    (<any>this).eras!.push(item);
            }
            this.twoDigitYearMax = _data["twoDigitYearMax"];
        }
    }

    static fromJS(data: any): Calendar {
        data = typeof data === 'object' ? data : {};
        let result = new Calendar();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minSupportedDateTime"] = this.minSupportedDateTime ? this.minSupportedDateTime.toISOString() : <any>undefined;
        data["maxSupportedDateTime"] = this.maxSupportedDateTime ? this.maxSupportedDateTime.toISOString() : <any>undefined;
        data["algorithmType"] = this.algorithmType;
        data["isReadOnly"] = this.isReadOnly;
        if (Array.isArray(this.eras)) {
            data["eras"] = [];
            for (let item of this.eras)
                data["eras"].push(item);
        }
        data["twoDigitYearMax"] = this.twoDigitYearMax;
        return data;
    }
}

export interface ICalendar {
    minSupportedDateTime?: Date;
    maxSupportedDateTime?: Date;
    algorithmType?: CalendarAlgorithmType;
    isReadOnly?: boolean;
    eras?: number[] | undefined;
    twoDigitYearMax?: number;
}

export enum CalendarAlgorithmType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum CalendarWeekRule {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class CanStartSignOffDto implements ICanStartSignOffDto {
    canStartSignOff?: boolean;
    message?: string | undefined;

    constructor(data?: ICanStartSignOffDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canStartSignOff = _data["canStartSignOff"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): CanStartSignOffDto {
        data = typeof data === 'object' ? data : {};
        let result = new CanStartSignOffDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canStartSignOff"] = this.canStartSignOff;
        data["message"] = this.message;
        return data;
    }
}

export interface ICanStartSignOffDto {
    canStartSignOff?: boolean;
    message?: string | undefined;
}

export class CanStartSignOffDtoBaseResponse implements ICanStartSignOffDtoBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: CanStartSignOffDto;

    constructor(data?: ICanStartSignOffDtoBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            this.response = _data["response"] ? CanStartSignOffDto.fromJS(_data["response"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CanStartSignOffDtoBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CanStartSignOffDtoBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICanStartSignOffDtoBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: CanStartSignOffDto;
}

export class CompareInfo implements ICompareInfo {
    readonly name?: string | undefined;
    version?: SortVersion;
    readonly lcid?: number;

    constructor(data?: ICompareInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            this.version = _data["version"] ? SortVersion.fromJS(_data["version"]) : <any>undefined;
            (<any>this).lcid = _data["lcid"];
        }
    }

    static fromJS(data: any): CompareInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CompareInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["version"] = this.version ? this.version.toJSON() : <any>undefined;
        data["lcid"] = this.lcid;
        return data;
    }
}

export interface ICompareInfo {
    name?: string | undefined;
    version?: SortVersion;
    lcid?: number;
}

export class ContactUs implements IContactUs {
    wUserFeedbackID?: number | undefined;
    wUserID?: number | undefined;
    wFeedbackTypeID?: number | undefined;
    wFeedbackTypeText?: string | undefined;
    feedbackStatus?: number | undefined;
    userCreated?: number | undefined;
    userModified?: number | undefined;
    userName?: string | undefined;
    firmQFCNumber?: string | undefined;
    userEmailAddress?: string | undefined;
    feedbackDesc?: string | undefined;

    constructor(data?: IContactUs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wUserFeedbackID = _data["wUserFeedbackID"];
            this.wUserID = _data["wUserID"];
            this.wFeedbackTypeID = _data["wFeedbackTypeID"];
            this.wFeedbackTypeText = _data["wFeedbackTypeText"];
            this.feedbackStatus = _data["feedbackStatus"];
            this.userCreated = _data["userCreated"];
            this.userModified = _data["userModified"];
            this.userName = _data["userName"];
            this.firmQFCNumber = _data["firmQFCNumber"];
            this.userEmailAddress = _data["userEmailAddress"];
            this.feedbackDesc = _data["feedbackDesc"];
        }
    }

    static fromJS(data: any): ContactUs {
        data = typeof data === 'object' ? data : {};
        let result = new ContactUs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wUserFeedbackID"] = this.wUserFeedbackID;
        data["wUserID"] = this.wUserID;
        data["wFeedbackTypeID"] = this.wFeedbackTypeID;
        data["wFeedbackTypeText"] = this.wFeedbackTypeText;
        data["feedbackStatus"] = this.feedbackStatus;
        data["userCreated"] = this.userCreated;
        data["userModified"] = this.userModified;
        data["userName"] = this.userName;
        data["firmQFCNumber"] = this.firmQFCNumber;
        data["userEmailAddress"] = this.userEmailAddress;
        data["feedbackDesc"] = this.feedbackDesc;
        return data;
    }
}

export interface IContactUs {
    wUserFeedbackID?: number | undefined;
    wUserID?: number | undefined;
    wFeedbackTypeID?: number | undefined;
    wFeedbackTypeText?: string | undefined;
    feedbackStatus?: number | undefined;
    userCreated?: number | undefined;
    userModified?: number | undefined;
    userName?: string | undefined;
    firmQFCNumber?: string | undefined;
    userEmailAddress?: string | undefined;
    feedbackDesc?: string | undefined;
}

export class ControledFunction implements IControledFunction {
    firmID?: number;
    fullName?: string | undefined;
    id?: number;
    userId?: number;
    value?: string | undefined;
    qfcNmuner?: string | undefined;
    applContactDetailID?: number;
    applicationStatusTypeID?: number;
    addressLine1?: string | undefined;
    addressLine2?: string | undefined;
    addressLine3?: string | undefined;
    addressLine4?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    countryID?: string | undefined;
    countryName?: string | undefined;
    postalCode?: string | undefined;
    firmName?: string | undefined;
    functionID?: number;
    positionOfMainContact?: string | undefined;
    contactID?: number;
    nameOfMainContact?: string | undefined;
    telephoneNumber?: string | undefined;
    faxNumber?: string | undefined;
    emailAddressOfMainAccount?: string | undefined;
    preferredMethodOfContact?: string | undefined;
    primarySupervisorEmailAddress?: string | undefined;
    secondarySupervisorEmailAddress?: string | undefined;
    additionalSupervisorEmailAddress?: string | undefined;
    amlPrimarySupervisorEmailAddress?: string | undefined;
    amlSecondarySupervisorEmailAddress?: string | undefined;
    additionalAMLSupervisorEmailAddress?: string | undefined;
    directorEmailAddress?: string | undefined;
    amlDirectorEmailAddress?: string | undefined;
    rsgEmailAddress?: string | undefined;
    firmTypeID?: number;
    qfcNumber?: string | undefined;
    aiNumber?: string | undefined;
    applicationID?: number;
    formTypeID?: number;
    applStatusTypeID?: number;
    arrangementTypeID?: number | undefined;
    arrangementTypeDesc?: string | undefined;
    arrangementTypeOtherDesc?: string | undefined;
    competenciesAndExp?: string | undefined;
    cfExcercisedDesc?: string | undefined;
    currentJobTitle?: string | undefined;
    jobTitleChangeFlag?: boolean | undefined;
    proposedJobTitle?: string | undefined;
    jobDesc?: string | undefined;
    pastPositionFlag?: boolean | undefined;
    pastPositionDesc?: string | undefined;
    fandPAddnlInfo?: string | undefined;
    fandPChangeDesc?: string | undefined;
    withdrawlReasonDesc?: string | undefined;
    altArrangementFlag?: boolean | undefined;
    altArrangementDesc?: string | undefined;
    wcfAddnlInfo?: string | undefined;
    cfApplicationDetail?: string | undefined;
    residencyNAFlag?: boolean | undefined;
    aliasesNAFlag?: boolean | undefined;
    careerHistoryNAFlag?: boolean | undefined;
    careerHistoryNAReason?: string | undefined;
    prevEmploymentFlag?: boolean | undefined;
    appUserID?: number;
    appCreatedBy?: number;
    modifiedDate?: string | undefined;
    userModified?: number;
    createdDate?: string | undefined;
    objFirmContactDetails?: FirmContactDetails;
    objIndividualDetails?: IndividualDetails;
    formTypeDesc?: string | undefined;
    applStatusTypeDesc?: string | undefined;
    reglsNAFlag?: boolean | undefined;
    nationalIdNAFlag?: boolean | undefined;
    qatarRelocationNAFlag?: boolean | undefined;
    profDevFalg?: boolean | undefined;
    profMembFlag?: boolean | undefined;
    higherEduFlag?: boolean | undefined;
    appStatusDate?: Date;
    appRecieveDate?: Date;
    coreApplicationID?: number;
    lstControledFunction?: ControledFunction[] | undefined;
    anyFileToAttachFlag?: boolean | undefined;
    additionalFileFlag?: boolean | undefined;
    applicationDate?: string | undefined;
    wObjectSOStatusID?: number | undefined;
    prevApplicationId?: number | undefined;
    additionalSupervisorFlag?: boolean | undefined;
    positionHeldFlag?: boolean | undefined;
    supervisingFlag?: boolean | undefined;
    resubmissionComments?: string | undefined;
    applicantName?: string | undefined;
    pageFlag?: string | undefined;
    reasonForDelayInFiling?: string | undefined;
    isOrdinarilyResidentFlag?: boolean | undefined;
    proposedRelocationDateDay?: number;
    proposedRelocationDateMonth?: number;
    proposedRelocationDateYear?: number;
    updateWobjectStatus?: boolean;
    controlFunctionID?: number | undefined;
    controlFunctionGUID?: string | undefined;
    functionTypeID?: number;
    functionTypeDesc?: string | undefined;
    day?: number | undefined;
    month?: number | undefined;
    year?: number | undefined;
    actionTypeID?: number | undefined;
    uponApprovalFlag?: boolean | undefined;
    functionStatusID?: number;
    functionStatusDesc?: string | undefined;
    functionStatusDate?: string | undefined;
    addActionTypeDesc?: string | undefined;
    withdrawActionTypeDesc?: string | undefined;
    actionTypeDesc?: string | undefined;
    conditionalApprovalFlag?: boolean | undefined;
    activityTypeIDs?: string | undefined;
    productTypeIDs?: string | undefined;
    activityProductTypeDesc?: string | undefined;
    approvalProposedCommenceDate?: string | undefined;
    withdrawalProposedCommenceDate?: string | undefined;
    approvalCommenceUponApplApprovalFlag?: boolean;
    withdrawalCommenceUponApplApprovalFlag?: boolean;

    constructor(data?: IControledFunction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmID = _data["firmID"];
            this.fullName = _data["fullName"];
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.value = _data["value"];
            this.qfcNmuner = _data["qfcNmuner"];
            this.applContactDetailID = _data["applContactDetailID"];
            this.applicationStatusTypeID = _data["applicationStatusTypeID"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.addressLine3 = _data["addressLine3"];
            this.addressLine4 = _data["addressLine4"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.countryID = _data["countryID"];
            this.countryName = _data["countryName"];
            this.postalCode = _data["postalCode"];
            this.firmName = _data["firmName"];
            this.functionID = _data["functionID"];
            this.positionOfMainContact = _data["positionOfMainContact"];
            this.contactID = _data["contactID"];
            this.nameOfMainContact = _data["nameOfMainContact"];
            this.telephoneNumber = _data["telephoneNumber"];
            this.faxNumber = _data["faxNumber"];
            this.emailAddressOfMainAccount = _data["emailAddressOfMainAccount"];
            this.preferredMethodOfContact = _data["preferredMethodOfContact"];
            this.primarySupervisorEmailAddress = _data["primarySupervisorEmailAddress"];
            this.secondarySupervisorEmailAddress = _data["secondarySupervisorEmailAddress"];
            this.additionalSupervisorEmailAddress = _data["additionalSupervisorEmailAddress"];
            this.amlPrimarySupervisorEmailAddress = _data["amlPrimarySupervisorEmailAddress"];
            this.amlSecondarySupervisorEmailAddress = _data["amlSecondarySupervisorEmailAddress"];
            this.additionalAMLSupervisorEmailAddress = _data["additionalAMLSupervisorEmailAddress"];
            this.directorEmailAddress = _data["directorEmailAddress"];
            this.amlDirectorEmailAddress = _data["amlDirectorEmailAddress"];
            this.rsgEmailAddress = _data["rsgEmailAddress"];
            this.firmTypeID = _data["firmTypeID"];
            this.qfcNumber = _data["qfcNumber"];
            this.aiNumber = _data["aiNumber"];
            this.applicationID = _data["applicationID"];
            this.formTypeID = _data["formTypeID"];
            this.applStatusTypeID = _data["applStatusTypeID"];
            this.arrangementTypeID = _data["arrangementTypeID"];
            this.arrangementTypeDesc = _data["arrangementTypeDesc"];
            this.arrangementTypeOtherDesc = _data["arrangementTypeOtherDesc"];
            this.competenciesAndExp = _data["competenciesAndExp"];
            this.cfExcercisedDesc = _data["cfExcercisedDesc"];
            this.currentJobTitle = _data["currentJobTitle"];
            this.jobTitleChangeFlag = _data["jobTitleChangeFlag"];
            this.proposedJobTitle = _data["proposedJobTitle"];
            this.jobDesc = _data["jobDesc"];
            this.pastPositionFlag = _data["pastPositionFlag"];
            this.pastPositionDesc = _data["pastPositionDesc"];
            this.fandPAddnlInfo = _data["fandPAddnlInfo"];
            this.fandPChangeDesc = _data["fandPChangeDesc"];
            this.withdrawlReasonDesc = _data["withdrawlReasonDesc"];
            this.altArrangementFlag = _data["altArrangementFlag"];
            this.altArrangementDesc = _data["altArrangementDesc"];
            this.wcfAddnlInfo = _data["wcfAddnlInfo"];
            this.cfApplicationDetail = _data["cfApplicationDetail"];
            this.residencyNAFlag = _data["residencyNAFlag"];
            this.aliasesNAFlag = _data["aliasesNAFlag"];
            this.careerHistoryNAFlag = _data["careerHistoryNAFlag"];
            this.careerHistoryNAReason = _data["careerHistoryNAReason"];
            this.prevEmploymentFlag = _data["prevEmploymentFlag"];
            this.appUserID = _data["appUserID"];
            this.appCreatedBy = _data["appCreatedBy"];
            this.modifiedDate = _data["modifiedDate"];
            this.userModified = _data["userModified"];
            this.createdDate = _data["createdDate"];
            this.objFirmContactDetails = _data["objFirmContactDetails"] ? FirmContactDetails.fromJS(_data["objFirmContactDetails"]) : <any>undefined;
            this.objIndividualDetails = _data["objIndividualDetails"] ? IndividualDetails.fromJS(_data["objIndividualDetails"]) : <any>undefined;
            this.formTypeDesc = _data["formTypeDesc"];
            this.applStatusTypeDesc = _data["applStatusTypeDesc"];
            this.reglsNAFlag = _data["reglsNAFlag"];
            this.nationalIdNAFlag = _data["nationalIdNAFlag"];
            this.qatarRelocationNAFlag = _data["qatarRelocationNAFlag"];
            this.profDevFalg = _data["profDevFalg"];
            this.profMembFlag = _data["profMembFlag"];
            this.higherEduFlag = _data["higherEduFlag"];
            this.appStatusDate = _data["appStatusDate"] ? new Date(_data["appStatusDate"].toString()) : <any>undefined;
            this.appRecieveDate = _data["appRecieveDate"] ? new Date(_data["appRecieveDate"].toString()) : <any>undefined;
            this.coreApplicationID = _data["coreApplicationID"];
            if (Array.isArray(_data["lstControledFunction"])) {
                this.lstControledFunction = [] as any;
                for (let item of _data["lstControledFunction"])
                    this.lstControledFunction!.push(ControledFunction.fromJS(item));
            }
            this.anyFileToAttachFlag = _data["anyFileToAttachFlag"];
            this.additionalFileFlag = _data["additionalFileFlag"];
            this.applicationDate = _data["applicationDate"];
            this.wObjectSOStatusID = _data["wObjectSOStatusID"];
            this.prevApplicationId = _data["prevApplicationId"];
            this.additionalSupervisorFlag = _data["additionalSupervisorFlag"];
            this.positionHeldFlag = _data["positionHeldFlag"];
            this.supervisingFlag = _data["supervisingFlag"];
            this.resubmissionComments = _data["resubmissionComments"];
            this.applicantName = _data["applicantName"];
            this.pageFlag = _data["pageFlag"];
            this.reasonForDelayInFiling = _data["reasonForDelayInFiling"];
            this.isOrdinarilyResidentFlag = _data["isOrdinarilyResidentFlag"];
            this.proposedRelocationDateDay = _data["proposedRelocationDateDay"];
            this.proposedRelocationDateMonth = _data["proposedRelocationDateMonth"];
            this.proposedRelocationDateYear = _data["proposedRelocationDateYear"];
            this.updateWobjectStatus = _data["updateWobjectStatus"];
            this.controlFunctionID = _data["controlFunctionID"];
            this.controlFunctionGUID = _data["controlFunctionGUID"];
            this.functionTypeID = _data["functionTypeID"];
            this.functionTypeDesc = _data["functionTypeDesc"];
            this.day = _data["day"];
            this.month = _data["month"];
            this.year = _data["year"];
            this.actionTypeID = _data["actionTypeID"];
            this.uponApprovalFlag = _data["uponApprovalFlag"];
            this.functionStatusID = _data["functionStatusID"];
            this.functionStatusDesc = _data["functionStatusDesc"];
            this.functionStatusDate = _data["functionStatusDate"];
            this.addActionTypeDesc = _data["addActionTypeDesc"];
            this.withdrawActionTypeDesc = _data["withdrawActionTypeDesc"];
            this.actionTypeDesc = _data["actionTypeDesc"];
            this.conditionalApprovalFlag = _data["conditionalApprovalFlag"];
            this.activityTypeIDs = _data["activityTypeIDs"];
            this.productTypeIDs = _data["productTypeIDs"];
            this.activityProductTypeDesc = _data["activityProductTypeDesc"];
            this.approvalProposedCommenceDate = _data["approvalProposedCommenceDate"];
            this.withdrawalProposedCommenceDate = _data["withdrawalProposedCommenceDate"];
            this.approvalCommenceUponApplApprovalFlag = _data["approvalCommenceUponApplApprovalFlag"];
            this.withdrawalCommenceUponApplApprovalFlag = _data["withdrawalCommenceUponApplApprovalFlag"];
        }
    }

    static fromJS(data: any): ControledFunction {
        data = typeof data === 'object' ? data : {};
        let result = new ControledFunction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmID"] = this.firmID;
        data["fullName"] = this.fullName;
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["value"] = this.value;
        data["qfcNmuner"] = this.qfcNmuner;
        data["applContactDetailID"] = this.applContactDetailID;
        data["applicationStatusTypeID"] = this.applicationStatusTypeID;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["addressLine3"] = this.addressLine3;
        data["addressLine4"] = this.addressLine4;
        data["city"] = this.city;
        data["state"] = this.state;
        data["countryID"] = this.countryID;
        data["countryName"] = this.countryName;
        data["postalCode"] = this.postalCode;
        data["firmName"] = this.firmName;
        data["functionID"] = this.functionID;
        data["positionOfMainContact"] = this.positionOfMainContact;
        data["contactID"] = this.contactID;
        data["nameOfMainContact"] = this.nameOfMainContact;
        data["telephoneNumber"] = this.telephoneNumber;
        data["faxNumber"] = this.faxNumber;
        data["emailAddressOfMainAccount"] = this.emailAddressOfMainAccount;
        data["preferredMethodOfContact"] = this.preferredMethodOfContact;
        data["primarySupervisorEmailAddress"] = this.primarySupervisorEmailAddress;
        data["secondarySupervisorEmailAddress"] = this.secondarySupervisorEmailAddress;
        data["additionalSupervisorEmailAddress"] = this.additionalSupervisorEmailAddress;
        data["amlPrimarySupervisorEmailAddress"] = this.amlPrimarySupervisorEmailAddress;
        data["amlSecondarySupervisorEmailAddress"] = this.amlSecondarySupervisorEmailAddress;
        data["additionalAMLSupervisorEmailAddress"] = this.additionalAMLSupervisorEmailAddress;
        data["directorEmailAddress"] = this.directorEmailAddress;
        data["amlDirectorEmailAddress"] = this.amlDirectorEmailAddress;
        data["rsgEmailAddress"] = this.rsgEmailAddress;
        data["firmTypeID"] = this.firmTypeID;
        data["qfcNumber"] = this.qfcNumber;
        data["aiNumber"] = this.aiNumber;
        data["applicationID"] = this.applicationID;
        data["formTypeID"] = this.formTypeID;
        data["applStatusTypeID"] = this.applStatusTypeID;
        data["arrangementTypeID"] = this.arrangementTypeID;
        data["arrangementTypeDesc"] = this.arrangementTypeDesc;
        data["arrangementTypeOtherDesc"] = this.arrangementTypeOtherDesc;
        data["competenciesAndExp"] = this.competenciesAndExp;
        data["cfExcercisedDesc"] = this.cfExcercisedDesc;
        data["currentJobTitle"] = this.currentJobTitle;
        data["jobTitleChangeFlag"] = this.jobTitleChangeFlag;
        data["proposedJobTitle"] = this.proposedJobTitle;
        data["jobDesc"] = this.jobDesc;
        data["pastPositionFlag"] = this.pastPositionFlag;
        data["pastPositionDesc"] = this.pastPositionDesc;
        data["fandPAddnlInfo"] = this.fandPAddnlInfo;
        data["fandPChangeDesc"] = this.fandPChangeDesc;
        data["withdrawlReasonDesc"] = this.withdrawlReasonDesc;
        data["altArrangementFlag"] = this.altArrangementFlag;
        data["altArrangementDesc"] = this.altArrangementDesc;
        data["wcfAddnlInfo"] = this.wcfAddnlInfo;
        data["cfApplicationDetail"] = this.cfApplicationDetail;
        data["residencyNAFlag"] = this.residencyNAFlag;
        data["aliasesNAFlag"] = this.aliasesNAFlag;
        data["careerHistoryNAFlag"] = this.careerHistoryNAFlag;
        data["careerHistoryNAReason"] = this.careerHistoryNAReason;
        data["prevEmploymentFlag"] = this.prevEmploymentFlag;
        data["appUserID"] = this.appUserID;
        data["appCreatedBy"] = this.appCreatedBy;
        data["modifiedDate"] = this.modifiedDate;
        data["userModified"] = this.userModified;
        data["createdDate"] = this.createdDate;
        data["objFirmContactDetails"] = this.objFirmContactDetails ? this.objFirmContactDetails.toJSON() : <any>undefined;
        data["objIndividualDetails"] = this.objIndividualDetails ? this.objIndividualDetails.toJSON() : <any>undefined;
        data["formTypeDesc"] = this.formTypeDesc;
        data["applStatusTypeDesc"] = this.applStatusTypeDesc;
        data["reglsNAFlag"] = this.reglsNAFlag;
        data["nationalIdNAFlag"] = this.nationalIdNAFlag;
        data["qatarRelocationNAFlag"] = this.qatarRelocationNAFlag;
        data["profDevFalg"] = this.profDevFalg;
        data["profMembFlag"] = this.profMembFlag;
        data["higherEduFlag"] = this.higherEduFlag;
        data["appStatusDate"] = this.appStatusDate ? this.appStatusDate.toISOString() : <any>undefined;
        data["appRecieveDate"] = this.appRecieveDate ? this.appRecieveDate.toISOString() : <any>undefined;
        data["coreApplicationID"] = this.coreApplicationID;
        if (Array.isArray(this.lstControledFunction)) {
            data["lstControledFunction"] = [];
            for (let item of this.lstControledFunction)
                data["lstControledFunction"].push(item.toJSON());
        }
        data["anyFileToAttachFlag"] = this.anyFileToAttachFlag;
        data["additionalFileFlag"] = this.additionalFileFlag;
        data["applicationDate"] = this.applicationDate;
        data["wObjectSOStatusID"] = this.wObjectSOStatusID;
        data["prevApplicationId"] = this.prevApplicationId;
        data["additionalSupervisorFlag"] = this.additionalSupervisorFlag;
        data["positionHeldFlag"] = this.positionHeldFlag;
        data["supervisingFlag"] = this.supervisingFlag;
        data["resubmissionComments"] = this.resubmissionComments;
        data["applicantName"] = this.applicantName;
        data["pageFlag"] = this.pageFlag;
        data["reasonForDelayInFiling"] = this.reasonForDelayInFiling;
        data["isOrdinarilyResidentFlag"] = this.isOrdinarilyResidentFlag;
        data["proposedRelocationDateDay"] = this.proposedRelocationDateDay;
        data["proposedRelocationDateMonth"] = this.proposedRelocationDateMonth;
        data["proposedRelocationDateYear"] = this.proposedRelocationDateYear;
        data["updateWobjectStatus"] = this.updateWobjectStatus;
        data["controlFunctionID"] = this.controlFunctionID;
        data["controlFunctionGUID"] = this.controlFunctionGUID;
        data["functionTypeID"] = this.functionTypeID;
        data["functionTypeDesc"] = this.functionTypeDesc;
        data["day"] = this.day;
        data["month"] = this.month;
        data["year"] = this.year;
        data["actionTypeID"] = this.actionTypeID;
        data["uponApprovalFlag"] = this.uponApprovalFlag;
        data["functionStatusID"] = this.functionStatusID;
        data["functionStatusDesc"] = this.functionStatusDesc;
        data["functionStatusDate"] = this.functionStatusDate;
        data["addActionTypeDesc"] = this.addActionTypeDesc;
        data["withdrawActionTypeDesc"] = this.withdrawActionTypeDesc;
        data["actionTypeDesc"] = this.actionTypeDesc;
        data["conditionalApprovalFlag"] = this.conditionalApprovalFlag;
        data["activityTypeIDs"] = this.activityTypeIDs;
        data["productTypeIDs"] = this.productTypeIDs;
        data["activityProductTypeDesc"] = this.activityProductTypeDesc;
        data["approvalProposedCommenceDate"] = this.approvalProposedCommenceDate;
        data["withdrawalProposedCommenceDate"] = this.withdrawalProposedCommenceDate;
        data["approvalCommenceUponApplApprovalFlag"] = this.approvalCommenceUponApplApprovalFlag;
        data["withdrawalCommenceUponApplApprovalFlag"] = this.withdrawalCommenceUponApplApprovalFlag;
        return data;
    }
}

export interface IControledFunction {
    firmID?: number;
    fullName?: string | undefined;
    id?: number;
    userId?: number;
    value?: string | undefined;
    qfcNmuner?: string | undefined;
    applContactDetailID?: number;
    applicationStatusTypeID?: number;
    addressLine1?: string | undefined;
    addressLine2?: string | undefined;
    addressLine3?: string | undefined;
    addressLine4?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    countryID?: string | undefined;
    countryName?: string | undefined;
    postalCode?: string | undefined;
    firmName?: string | undefined;
    functionID?: number;
    positionOfMainContact?: string | undefined;
    contactID?: number;
    nameOfMainContact?: string | undefined;
    telephoneNumber?: string | undefined;
    faxNumber?: string | undefined;
    emailAddressOfMainAccount?: string | undefined;
    preferredMethodOfContact?: string | undefined;
    primarySupervisorEmailAddress?: string | undefined;
    secondarySupervisorEmailAddress?: string | undefined;
    additionalSupervisorEmailAddress?: string | undefined;
    amlPrimarySupervisorEmailAddress?: string | undefined;
    amlSecondarySupervisorEmailAddress?: string | undefined;
    additionalAMLSupervisorEmailAddress?: string | undefined;
    directorEmailAddress?: string | undefined;
    amlDirectorEmailAddress?: string | undefined;
    rsgEmailAddress?: string | undefined;
    firmTypeID?: number;
    qfcNumber?: string | undefined;
    aiNumber?: string | undefined;
    applicationID?: number;
    formTypeID?: number;
    applStatusTypeID?: number;
    arrangementTypeID?: number | undefined;
    arrangementTypeDesc?: string | undefined;
    arrangementTypeOtherDesc?: string | undefined;
    competenciesAndExp?: string | undefined;
    cfExcercisedDesc?: string | undefined;
    currentJobTitle?: string | undefined;
    jobTitleChangeFlag?: boolean | undefined;
    proposedJobTitle?: string | undefined;
    jobDesc?: string | undefined;
    pastPositionFlag?: boolean | undefined;
    pastPositionDesc?: string | undefined;
    fandPAddnlInfo?: string | undefined;
    fandPChangeDesc?: string | undefined;
    withdrawlReasonDesc?: string | undefined;
    altArrangementFlag?: boolean | undefined;
    altArrangementDesc?: string | undefined;
    wcfAddnlInfo?: string | undefined;
    cfApplicationDetail?: string | undefined;
    residencyNAFlag?: boolean | undefined;
    aliasesNAFlag?: boolean | undefined;
    careerHistoryNAFlag?: boolean | undefined;
    careerHistoryNAReason?: string | undefined;
    prevEmploymentFlag?: boolean | undefined;
    appUserID?: number;
    appCreatedBy?: number;
    modifiedDate?: string | undefined;
    userModified?: number;
    createdDate?: string | undefined;
    objFirmContactDetails?: FirmContactDetails;
    objIndividualDetails?: IndividualDetails;
    formTypeDesc?: string | undefined;
    applStatusTypeDesc?: string | undefined;
    reglsNAFlag?: boolean | undefined;
    nationalIdNAFlag?: boolean | undefined;
    qatarRelocationNAFlag?: boolean | undefined;
    profDevFalg?: boolean | undefined;
    profMembFlag?: boolean | undefined;
    higherEduFlag?: boolean | undefined;
    appStatusDate?: Date;
    appRecieveDate?: Date;
    coreApplicationID?: number;
    lstControledFunction?: ControledFunction[] | undefined;
    anyFileToAttachFlag?: boolean | undefined;
    additionalFileFlag?: boolean | undefined;
    applicationDate?: string | undefined;
    wObjectSOStatusID?: number | undefined;
    prevApplicationId?: number | undefined;
    additionalSupervisorFlag?: boolean | undefined;
    positionHeldFlag?: boolean | undefined;
    supervisingFlag?: boolean | undefined;
    resubmissionComments?: string | undefined;
    applicantName?: string | undefined;
    pageFlag?: string | undefined;
    reasonForDelayInFiling?: string | undefined;
    isOrdinarilyResidentFlag?: boolean | undefined;
    proposedRelocationDateDay?: number;
    proposedRelocationDateMonth?: number;
    proposedRelocationDateYear?: number;
    updateWobjectStatus?: boolean;
    controlFunctionID?: number | undefined;
    controlFunctionGUID?: string | undefined;
    functionTypeID?: number;
    functionTypeDesc?: string | undefined;
    day?: number | undefined;
    month?: number | undefined;
    year?: number | undefined;
    actionTypeID?: number | undefined;
    uponApprovalFlag?: boolean | undefined;
    functionStatusID?: number;
    functionStatusDesc?: string | undefined;
    functionStatusDate?: string | undefined;
    addActionTypeDesc?: string | undefined;
    withdrawActionTypeDesc?: string | undefined;
    actionTypeDesc?: string | undefined;
    conditionalApprovalFlag?: boolean | undefined;
    activityTypeIDs?: string | undefined;
    productTypeIDs?: string | undefined;
    activityProductTypeDesc?: string | undefined;
    approvalProposedCommenceDate?: string | undefined;
    withdrawalProposedCommenceDate?: string | undefined;
    approvalCommenceUponApplApprovalFlag?: boolean;
    withdrawalCommenceUponApplApprovalFlag?: boolean;
}

export class ControlledFunctionDto implements IControlledFunctionDto {
    controlFunctionID?: number | undefined;
    applicationID?: number | undefined;
    functionTypeID?: number | undefined;
    functionTypeDesc?: string | undefined;
    actionTypeID?: number | undefined;
    day?: number | undefined;
    month?: number | undefined;
    year?: number | undefined;
    uponApprovalFlag?: boolean | undefined;
    conditionalApprovalFlag?: boolean | undefined;
    userID?: number | undefined;
    pageFlag?: string | undefined;
    actionTypeDesc?: string | undefined;
    appRecieveDate?: Date | undefined;

    constructor(data?: IControlledFunctionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.controlFunctionID = _data["controlFunctionID"];
            this.applicationID = _data["applicationID"];
            this.functionTypeID = _data["functionTypeID"];
            this.functionTypeDesc = _data["functionTypeDesc"];
            this.actionTypeID = _data["actionTypeID"];
            this.day = _data["day"];
            this.month = _data["month"];
            this.year = _data["year"];
            this.uponApprovalFlag = _data["uponApprovalFlag"];
            this.conditionalApprovalFlag = _data["conditionalApprovalFlag"];
            this.userID = _data["userID"];
            this.pageFlag = _data["pageFlag"];
            this.actionTypeDesc = _data["actionTypeDesc"];
            this.appRecieveDate = _data["appRecieveDate"] ? new Date(_data["appRecieveDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ControlledFunctionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ControlledFunctionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["controlFunctionID"] = this.controlFunctionID;
        data["applicationID"] = this.applicationID;
        data["functionTypeID"] = this.functionTypeID;
        data["functionTypeDesc"] = this.functionTypeDesc;
        data["actionTypeID"] = this.actionTypeID;
        data["day"] = this.day;
        data["month"] = this.month;
        data["year"] = this.year;
        data["uponApprovalFlag"] = this.uponApprovalFlag;
        data["conditionalApprovalFlag"] = this.conditionalApprovalFlag;
        data["userID"] = this.userID;
        data["pageFlag"] = this.pageFlag;
        data["actionTypeDesc"] = this.actionTypeDesc;
        data["appRecieveDate"] = this.appRecieveDate ? this.appRecieveDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IControlledFunctionDto {
    controlFunctionID?: number | undefined;
    applicationID?: number | undefined;
    functionTypeID?: number | undefined;
    functionTypeDesc?: string | undefined;
    actionTypeID?: number | undefined;
    day?: number | undefined;
    month?: number | undefined;
    year?: number | undefined;
    uponApprovalFlag?: boolean | undefined;
    conditionalApprovalFlag?: boolean | undefined;
    userID?: number | undefined;
    pageFlag?: string | undefined;
    actionTypeDesc?: string | undefined;
    appRecieveDate?: Date | undefined;
}

export class ControlledFunctionDtoListBaseResponse implements IControlledFunctionDtoListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: ControlledFunctionDto[] | undefined;

    constructor(data?: IControlledFunctionDtoListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["response"])) {
                this.response = [] as any;
                for (let item of _data["response"])
                    this.response!.push(ControlledFunctionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ControlledFunctionDtoListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ControlledFunctionDtoListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.response)) {
            data["response"] = [];
            for (let item of this.response)
                data["response"].push(item.toJSON());
        }
        return data;
    }
}

export interface IControlledFunctionDtoListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: ControlledFunctionDto[] | undefined;
}

export class CultureInfo implements ICultureInfo {
    parent?: CultureInfo;
    readonly lcid?: number;
    readonly keyboardLayoutId?: number;
    name?: string | undefined;
    readonly ietfLanguageTag?: string | undefined;
    readonly displayName?: string | undefined;
    readonly nativeName?: string | undefined;
    readonly englishName?: string | undefined;
    readonly twoLetterISOLanguageName?: string | undefined;
    readonly threeLetterISOLanguageName?: string | undefined;
    readonly threeLetterWindowsLanguageName?: string | undefined;
    compareInfo?: CompareInfo;
    textInfo?: TextInfo;
    readonly isNeutralCulture?: boolean;
    cultureTypes?: CultureTypes;
    numberFormat?: NumberFormatInfo;
    dateTimeFormat?: DateTimeFormatInfo;
    calendar?: Calendar;
    readonly optionalCalendars?: Calendar[] | undefined;
    readonly useUserOverride?: boolean;
    readonly isReadOnly?: boolean;

    constructor(data?: ICultureInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parent = _data["parent"] ? CultureInfo.fromJS(_data["parent"]) : <any>undefined;
            (<any>this).lcid = _data["lcid"];
            (<any>this).keyboardLayoutId = _data["keyboardLayoutId"];
            this.name = _data["name"];
            (<any>this).ietfLanguageTag = _data["ietfLanguageTag"];
            (<any>this).displayName = _data["displayName"];
            (<any>this).nativeName = _data["nativeName"];
            (<any>this).englishName = _data["englishName"];
            (<any>this).twoLetterISOLanguageName = _data["twoLetterISOLanguageName"];
            (<any>this).threeLetterISOLanguageName = _data["threeLetterISOLanguageName"];
            (<any>this).threeLetterWindowsLanguageName = _data["threeLetterWindowsLanguageName"];
            this.compareInfo = _data["compareInfo"] ? CompareInfo.fromJS(_data["compareInfo"]) : <any>undefined;
            this.textInfo = _data["textInfo"] ? TextInfo.fromJS(_data["textInfo"]) : <any>undefined;
            (<any>this).isNeutralCulture = _data["isNeutralCulture"];
            this.cultureTypes = _data["cultureTypes"];
            this.numberFormat = _data["numberFormat"] ? NumberFormatInfo.fromJS(_data["numberFormat"]) : <any>undefined;
            this.dateTimeFormat = _data["dateTimeFormat"] ? DateTimeFormatInfo.fromJS(_data["dateTimeFormat"]) : <any>undefined;
            this.calendar = _data["calendar"] ? Calendar.fromJS(_data["calendar"]) : <any>undefined;
            if (Array.isArray(_data["optionalCalendars"])) {
                (<any>this).optionalCalendars = [] as any;
                for (let item of _data["optionalCalendars"])
                    (<any>this).optionalCalendars!.push(Calendar.fromJS(item));
            }
            (<any>this).useUserOverride = _data["useUserOverride"];
            (<any>this).isReadOnly = _data["isReadOnly"];
        }
    }

    static fromJS(data: any): CultureInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CultureInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["lcid"] = this.lcid;
        data["keyboardLayoutId"] = this.keyboardLayoutId;
        data["name"] = this.name;
        data["ietfLanguageTag"] = this.ietfLanguageTag;
        data["displayName"] = this.displayName;
        data["nativeName"] = this.nativeName;
        data["englishName"] = this.englishName;
        data["twoLetterISOLanguageName"] = this.twoLetterISOLanguageName;
        data["threeLetterISOLanguageName"] = this.threeLetterISOLanguageName;
        data["threeLetterWindowsLanguageName"] = this.threeLetterWindowsLanguageName;
        data["compareInfo"] = this.compareInfo ? this.compareInfo.toJSON() : <any>undefined;
        data["textInfo"] = this.textInfo ? this.textInfo.toJSON() : <any>undefined;
        data["isNeutralCulture"] = this.isNeutralCulture;
        data["cultureTypes"] = this.cultureTypes;
        data["numberFormat"] = this.numberFormat ? this.numberFormat.toJSON() : <any>undefined;
        data["dateTimeFormat"] = this.dateTimeFormat ? this.dateTimeFormat.toJSON() : <any>undefined;
        data["calendar"] = this.calendar ? this.calendar.toJSON() : <any>undefined;
        if (Array.isArray(this.optionalCalendars)) {
            data["optionalCalendars"] = [];
            for (let item of this.optionalCalendars)
                data["optionalCalendars"].push(item.toJSON());
        }
        data["useUserOverride"] = this.useUserOverride;
        data["isReadOnly"] = this.isReadOnly;
        return data;
    }
}

export interface ICultureInfo {
    parent?: CultureInfo;
    lcid?: number;
    keyboardLayoutId?: number;
    name?: string | undefined;
    ietfLanguageTag?: string | undefined;
    displayName?: string | undefined;
    nativeName?: string | undefined;
    englishName?: string | undefined;
    twoLetterISOLanguageName?: string | undefined;
    threeLetterISOLanguageName?: string | undefined;
    threeLetterWindowsLanguageName?: string | undefined;
    compareInfo?: CompareInfo;
    textInfo?: TextInfo;
    isNeutralCulture?: boolean;
    cultureTypes?: CultureTypes;
    numberFormat?: NumberFormatInfo;
    dateTimeFormat?: DateTimeFormatInfo;
    calendar?: Calendar;
    optionalCalendars?: Calendar[] | undefined;
    useUserOverride?: boolean;
    isReadOnly?: boolean;
}

export enum CultureTypes {
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _7 = 7,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
}

export class DataSet implements IDataSet {
    container?: IContainer;
    readonly designMode?: boolean;
    remotingFormat?: SerializationFormat;
    schemaSerializationMode?: SchemaSerializationMode;
    caseSensitive?: boolean;
    readonly defaultViewManager?: any[] | undefined;
    enforceConstraints?: boolean;
    dataSetName?: string | undefined;
    namespace?: string | undefined;
    prefix?: string | undefined;
    readonly extendedProperties?: { [key: string]: any; } | undefined;
    readonly hasErrors?: boolean;
    readonly isInitialized?: boolean;
    locale?: CultureInfo;
    site?: ISite;
    readonly relations?: any[] | undefined;
    readonly tables?: any[] | undefined;

    constructor(data?: IDataSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.caseSensitive = false;
            this.enforceConstraints = true;
            this.dataSetName = "";
            this.namespace = "";
            this.prefix = "";
        }
    }

    init(_data?: any) {
        if (_data) {
            this.container = _data["container"] ? IContainer.fromJS(_data["container"]) : <any>undefined;
            (<any>this).designMode = _data["designMode"];
            this.remotingFormat = _data["remotingFormat"];
            this.schemaSerializationMode = _data["schemaSerializationMode"];
            this.caseSensitive = _data["caseSensitive"] !== undefined ? _data["caseSensitive"] : false;
            if (Array.isArray(_data["defaultViewManager"])) {
                (<any>this).defaultViewManager = [] as any;
                for (let item of _data["defaultViewManager"])
                    (<any>this).defaultViewManager!.push(item);
            }
            this.enforceConstraints = _data["enforceConstraints"] !== undefined ? _data["enforceConstraints"] : true;
            this.dataSetName = _data["dataSetName"] !== undefined ? _data["dataSetName"] : "";
            this.namespace = _data["namespace"] !== undefined ? _data["namespace"] : "";
            this.prefix = _data["prefix"] !== undefined ? _data["prefix"] : "";
            if (_data["extendedProperties"]) {
                (<any>this).extendedProperties = {} as any;
                for (let key in _data["extendedProperties"]) {
                    if (_data["extendedProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extendedProperties)![key] = _data["extendedProperties"][key];
                }
            }
            (<any>this).hasErrors = _data["hasErrors"];
            (<any>this).isInitialized = _data["isInitialized"];
            this.locale = _data["locale"] ? CultureInfo.fromJS(_data["locale"]) : <any>undefined;
            this.site = _data["site"] ? ISite.fromJS(_data["site"]) : <any>undefined;
            if (Array.isArray(_data["relations"])) {
                (<any>this).relations = [] as any;
                for (let item of _data["relations"])
                    (<any>this).relations!.push(item);
            }
            if (Array.isArray(_data["tables"])) {
                (<any>this).tables = [] as any;
                for (let item of _data["tables"])
                    (<any>this).tables!.push(item);
            }
        }
    }

    static fromJS(data: any): DataSet {
        data = typeof data === 'object' ? data : {};
        let result = new DataSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["container"] = this.container ? this.container.toJSON() : <any>undefined;
        data["designMode"] = this.designMode;
        data["remotingFormat"] = this.remotingFormat;
        data["schemaSerializationMode"] = this.schemaSerializationMode;
        data["caseSensitive"] = this.caseSensitive;
        if (Array.isArray(this.defaultViewManager)) {
            data["defaultViewManager"] = [];
            for (let item of this.defaultViewManager)
                data["defaultViewManager"].push(item);
        }
        data["enforceConstraints"] = this.enforceConstraints;
        data["dataSetName"] = this.dataSetName;
        data["namespace"] = this.namespace;
        data["prefix"] = this.prefix;
        if (this.extendedProperties) {
            data["extendedProperties"] = {};
            for (let key in this.extendedProperties) {
                if (this.extendedProperties.hasOwnProperty(key))
                    (<any>data["extendedProperties"])[key] = (<any>this.extendedProperties)[key];
            }
        }
        data["hasErrors"] = this.hasErrors;
        data["isInitialized"] = this.isInitialized;
        data["locale"] = this.locale ? this.locale.toJSON() : <any>undefined;
        data["site"] = this.site ? this.site.toJSON() : <any>undefined;
        if (Array.isArray(this.relations)) {
            data["relations"] = [];
            for (let item of this.relations)
                data["relations"].push(item);
        }
        if (Array.isArray(this.tables)) {
            data["tables"] = [];
            for (let item of this.tables)
                data["tables"].push(item);
        }
        return data;
    }
}

export interface IDataSet {
    container?: IContainer;
    designMode?: boolean;
    remotingFormat?: SerializationFormat;
    schemaSerializationMode?: SchemaSerializationMode;
    caseSensitive?: boolean;
    defaultViewManager?: any[] | undefined;
    enforceConstraints?: boolean;
    dataSetName?: string | undefined;
    namespace?: string | undefined;
    prefix?: string | undefined;
    extendedProperties?: { [key: string]: any; } | undefined;
    hasErrors?: boolean;
    isInitialized?: boolean;
    locale?: CultureInfo;
    site?: ISite;
    relations?: any[] | undefined;
    tables?: any[] | undefined;
}

export class DateTimeFormatInfo implements IDateTimeFormatInfo {
    amDesignator?: string | undefined;
    calendar?: Calendar;
    dateSeparator?: string | undefined;
    firstDayOfWeek?: DayOfWeek;
    calendarWeekRule?: CalendarWeekRule;
    fullDateTimePattern?: string | undefined;
    longDatePattern?: string | undefined;
    longTimePattern?: string | undefined;
    monthDayPattern?: string | undefined;
    pmDesignator?: string | undefined;
    readonly rfC1123Pattern?: string | undefined;
    shortDatePattern?: string | undefined;
    shortTimePattern?: string | undefined;
    readonly sortableDateTimePattern?: string | undefined;
    timeSeparator?: string | undefined;
    readonly universalSortableDateTimePattern?: string | undefined;
    yearMonthPattern?: string | undefined;
    abbreviatedDayNames?: string[] | undefined;
    shortestDayNames?: string[] | undefined;
    dayNames?: string[] | undefined;
    abbreviatedMonthNames?: string[] | undefined;
    monthNames?: string[] | undefined;
    readonly isReadOnly?: boolean;
    readonly nativeCalendarName?: string | undefined;
    abbreviatedMonthGenitiveNames?: string[] | undefined;
    monthGenitiveNames?: string[] | undefined;

    constructor(data?: IDateTimeFormatInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amDesignator = _data["amDesignator"];
            this.calendar = _data["calendar"] ? Calendar.fromJS(_data["calendar"]) : <any>undefined;
            this.dateSeparator = _data["dateSeparator"];
            this.firstDayOfWeek = _data["firstDayOfWeek"];
            this.calendarWeekRule = _data["calendarWeekRule"];
            this.fullDateTimePattern = _data["fullDateTimePattern"];
            this.longDatePattern = _data["longDatePattern"];
            this.longTimePattern = _data["longTimePattern"];
            this.monthDayPattern = _data["monthDayPattern"];
            this.pmDesignator = _data["pmDesignator"];
            (<any>this).rfC1123Pattern = _data["rfC1123Pattern"];
            this.shortDatePattern = _data["shortDatePattern"];
            this.shortTimePattern = _data["shortTimePattern"];
            (<any>this).sortableDateTimePattern = _data["sortableDateTimePattern"];
            this.timeSeparator = _data["timeSeparator"];
            (<any>this).universalSortableDateTimePattern = _data["universalSortableDateTimePattern"];
            this.yearMonthPattern = _data["yearMonthPattern"];
            if (Array.isArray(_data["abbreviatedDayNames"])) {
                this.abbreviatedDayNames = [] as any;
                for (let item of _data["abbreviatedDayNames"])
                    this.abbreviatedDayNames!.push(item);
            }
            if (Array.isArray(_data["shortestDayNames"])) {
                this.shortestDayNames = [] as any;
                for (let item of _data["shortestDayNames"])
                    this.shortestDayNames!.push(item);
            }
            if (Array.isArray(_data["dayNames"])) {
                this.dayNames = [] as any;
                for (let item of _data["dayNames"])
                    this.dayNames!.push(item);
            }
            if (Array.isArray(_data["abbreviatedMonthNames"])) {
                this.abbreviatedMonthNames = [] as any;
                for (let item of _data["abbreviatedMonthNames"])
                    this.abbreviatedMonthNames!.push(item);
            }
            if (Array.isArray(_data["monthNames"])) {
                this.monthNames = [] as any;
                for (let item of _data["monthNames"])
                    this.monthNames!.push(item);
            }
            (<any>this).isReadOnly = _data["isReadOnly"];
            (<any>this).nativeCalendarName = _data["nativeCalendarName"];
            if (Array.isArray(_data["abbreviatedMonthGenitiveNames"])) {
                this.abbreviatedMonthGenitiveNames = [] as any;
                for (let item of _data["abbreviatedMonthGenitiveNames"])
                    this.abbreviatedMonthGenitiveNames!.push(item);
            }
            if (Array.isArray(_data["monthGenitiveNames"])) {
                this.monthGenitiveNames = [] as any;
                for (let item of _data["monthGenitiveNames"])
                    this.monthGenitiveNames!.push(item);
            }
        }
    }

    static fromJS(data: any): DateTimeFormatInfo {
        data = typeof data === 'object' ? data : {};
        let result = new DateTimeFormatInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amDesignator"] = this.amDesignator;
        data["calendar"] = this.calendar ? this.calendar.toJSON() : <any>undefined;
        data["dateSeparator"] = this.dateSeparator;
        data["firstDayOfWeek"] = this.firstDayOfWeek;
        data["calendarWeekRule"] = this.calendarWeekRule;
        data["fullDateTimePattern"] = this.fullDateTimePattern;
        data["longDatePattern"] = this.longDatePattern;
        data["longTimePattern"] = this.longTimePattern;
        data["monthDayPattern"] = this.monthDayPattern;
        data["pmDesignator"] = this.pmDesignator;
        data["rfC1123Pattern"] = this.rfC1123Pattern;
        data["shortDatePattern"] = this.shortDatePattern;
        data["shortTimePattern"] = this.shortTimePattern;
        data["sortableDateTimePattern"] = this.sortableDateTimePattern;
        data["timeSeparator"] = this.timeSeparator;
        data["universalSortableDateTimePattern"] = this.universalSortableDateTimePattern;
        data["yearMonthPattern"] = this.yearMonthPattern;
        if (Array.isArray(this.abbreviatedDayNames)) {
            data["abbreviatedDayNames"] = [];
            for (let item of this.abbreviatedDayNames)
                data["abbreviatedDayNames"].push(item);
        }
        if (Array.isArray(this.shortestDayNames)) {
            data["shortestDayNames"] = [];
            for (let item of this.shortestDayNames)
                data["shortestDayNames"].push(item);
        }
        if (Array.isArray(this.dayNames)) {
            data["dayNames"] = [];
            for (let item of this.dayNames)
                data["dayNames"].push(item);
        }
        if (Array.isArray(this.abbreviatedMonthNames)) {
            data["abbreviatedMonthNames"] = [];
            for (let item of this.abbreviatedMonthNames)
                data["abbreviatedMonthNames"].push(item);
        }
        if (Array.isArray(this.monthNames)) {
            data["monthNames"] = [];
            for (let item of this.monthNames)
                data["monthNames"].push(item);
        }
        data["isReadOnly"] = this.isReadOnly;
        data["nativeCalendarName"] = this.nativeCalendarName;
        if (Array.isArray(this.abbreviatedMonthGenitiveNames)) {
            data["abbreviatedMonthGenitiveNames"] = [];
            for (let item of this.abbreviatedMonthGenitiveNames)
                data["abbreviatedMonthGenitiveNames"].push(item);
        }
        if (Array.isArray(this.monthGenitiveNames)) {
            data["monthGenitiveNames"] = [];
            for (let item of this.monthGenitiveNames)
                data["monthGenitiveNames"].push(item);
        }
        return data;
    }
}

export interface IDateTimeFormatInfo {
    amDesignator?: string | undefined;
    calendar?: Calendar;
    dateSeparator?: string | undefined;
    firstDayOfWeek?: DayOfWeek;
    calendarWeekRule?: CalendarWeekRule;
    fullDateTimePattern?: string | undefined;
    longDatePattern?: string | undefined;
    longTimePattern?: string | undefined;
    monthDayPattern?: string | undefined;
    pmDesignator?: string | undefined;
    rfC1123Pattern?: string | undefined;
    shortDatePattern?: string | undefined;
    shortTimePattern?: string | undefined;
    sortableDateTimePattern?: string | undefined;
    timeSeparator?: string | undefined;
    universalSortableDateTimePattern?: string | undefined;
    yearMonthPattern?: string | undefined;
    abbreviatedDayNames?: string[] | undefined;
    shortestDayNames?: string[] | undefined;
    dayNames?: string[] | undefined;
    abbreviatedMonthNames?: string[] | undefined;
    monthNames?: string[] | undefined;
    isReadOnly?: boolean;
    nativeCalendarName?: string | undefined;
    abbreviatedMonthGenitiveNames?: string[] | undefined;
    monthGenitiveNames?: string[] | undefined;
}

export enum DayOfWeek {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export enum DigitShapes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class DocSignatories implements IDocSignatories {
    docSignatoryID?: number;
    docTypeID?: number | undefined;
    rptFreqTypeID?: number | undefined;
    numOfSigs?: number | undefined;
    firstSig?: string | undefined;
    secondSig?: string | undefined;
    thirdSig?: string | undefined;
    fourthSig?: string | undefined;
    validFlag?: boolean;
    userID?: number;
    docSignText?: string | undefined;
    docAccessRoles?: string | undefined;
    wLinkToFormDesc?: string | undefined;
    wIndFromTypeID?: number | undefined;
    freqTypeDesc?: string | undefined;
    objectID?: number | undefined;
    firmTypeID?: number | undefined;

    constructor(data?: IDocSignatories) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.docSignatoryID = _data["docSignatoryID"];
            this.docTypeID = _data["docTypeID"];
            this.rptFreqTypeID = _data["rptFreqTypeID"];
            this.numOfSigs = _data["numOfSigs"];
            this.firstSig = _data["firstSig"];
            this.secondSig = _data["secondSig"];
            this.thirdSig = _data["thirdSig"];
            this.fourthSig = _data["fourthSig"];
            this.validFlag = _data["validFlag"];
            this.userID = _data["userID"];
            this.docSignText = _data["docSignText"];
            this.docAccessRoles = _data["docAccessRoles"];
            this.wLinkToFormDesc = _data["wLinkToFormDesc"];
            this.wIndFromTypeID = _data["wIndFromTypeID"];
            this.freqTypeDesc = _data["freqTypeDesc"];
            this.objectID = _data["objectID"];
            this.firmTypeID = _data["firmTypeID"];
        }
    }

    static fromJS(data: any): DocSignatories {
        data = typeof data === 'object' ? data : {};
        let result = new DocSignatories();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["docSignatoryID"] = this.docSignatoryID;
        data["docTypeID"] = this.docTypeID;
        data["rptFreqTypeID"] = this.rptFreqTypeID;
        data["numOfSigs"] = this.numOfSigs;
        data["firstSig"] = this.firstSig;
        data["secondSig"] = this.secondSig;
        data["thirdSig"] = this.thirdSig;
        data["fourthSig"] = this.fourthSig;
        data["validFlag"] = this.validFlag;
        data["userID"] = this.userID;
        data["docSignText"] = this.docSignText;
        data["docAccessRoles"] = this.docAccessRoles;
        data["wLinkToFormDesc"] = this.wLinkToFormDesc;
        data["wIndFromTypeID"] = this.wIndFromTypeID;
        data["freqTypeDesc"] = this.freqTypeDesc;
        data["objectID"] = this.objectID;
        data["firmTypeID"] = this.firmTypeID;
        return data;
    }
}

export interface IDocSignatories {
    docSignatoryID?: number;
    docTypeID?: number | undefined;
    rptFreqTypeID?: number | undefined;
    numOfSigs?: number | undefined;
    firstSig?: string | undefined;
    secondSig?: string | undefined;
    thirdSig?: string | undefined;
    fourthSig?: string | undefined;
    validFlag?: boolean;
    userID?: number;
    docSignText?: string | undefined;
    docAccessRoles?: string | undefined;
    wLinkToFormDesc?: string | undefined;
    wIndFromTypeID?: number | undefined;
    freqTypeDesc?: string | undefined;
    objectID?: number | undefined;
    firmTypeID?: number | undefined;
}

export class DocSignatoriesBaseResponse implements IDocSignatoriesBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: DocSignatories;

    constructor(data?: IDocSignatoriesBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            this.response = _data["response"] ? DocSignatories.fromJS(_data["response"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DocSignatoriesBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DocSignatoriesBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        return data;
    }
}

export interface IDocSignatoriesBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: DocSignatories;
}

export class EmailEventForReportValidationRequest implements IEmailEventForReportValidationRequest {
    objReportSchDetails?: ReportSchDetails;
    lstObjectSOTaskStatus?: ObjectSOTaskStatus[] | undefined;
    eventType?: number;
    objectID?: number;

    constructor(data?: IEmailEventForReportValidationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objReportSchDetails = _data["objReportSchDetails"] ? ReportSchDetails.fromJS(_data["objReportSchDetails"]) : <any>undefined;
            if (Array.isArray(_data["lstObjectSOTaskStatus"])) {
                this.lstObjectSOTaskStatus = [] as any;
                for (let item of _data["lstObjectSOTaskStatus"])
                    this.lstObjectSOTaskStatus!.push(ObjectSOTaskStatus.fromJS(item));
            }
            this.eventType = _data["eventType"];
            this.objectID = _data["objectID"];
        }
    }

    static fromJS(data: any): EmailEventForReportValidationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EmailEventForReportValidationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objReportSchDetails"] = this.objReportSchDetails ? this.objReportSchDetails.toJSON() : <any>undefined;
        if (Array.isArray(this.lstObjectSOTaskStatus)) {
            data["lstObjectSOTaskStatus"] = [];
            for (let item of this.lstObjectSOTaskStatus)
                data["lstObjectSOTaskStatus"].push(item.toJSON());
        }
        data["eventType"] = this.eventType;
        data["objectID"] = this.objectID;
        return data;
    }
}

export interface IEmailEventForReportValidationRequest {
    objReportSchDetails?: ReportSchDetails;
    lstObjectSOTaskStatus?: ObjectSOTaskStatus[] | undefined;
    eventType?: number;
    objectID?: number;
}

export class EmailEventRequest implements IEmailEventRequest {
    objReportSchDetails?: ReportSchDetails;
    lstObjectSOTaskStatus?: ObjectSOTaskStatus[] | undefined;
    eventType?: number;
    objectID?: number;

    constructor(data?: IEmailEventRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objReportSchDetails = _data["objReportSchDetails"] ? ReportSchDetails.fromJS(_data["objReportSchDetails"]) : <any>undefined;
            if (Array.isArray(_data["lstObjectSOTaskStatus"])) {
                this.lstObjectSOTaskStatus = [] as any;
                for (let item of _data["lstObjectSOTaskStatus"])
                    this.lstObjectSOTaskStatus!.push(ObjectSOTaskStatus.fromJS(item));
            }
            this.eventType = _data["eventType"];
            this.objectID = _data["objectID"];
        }
    }

    static fromJS(data: any): EmailEventRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EmailEventRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objReportSchDetails"] = this.objReportSchDetails ? this.objReportSchDetails.toJSON() : <any>undefined;
        if (Array.isArray(this.lstObjectSOTaskStatus)) {
            data["lstObjectSOTaskStatus"] = [];
            for (let item of this.lstObjectSOTaskStatus)
                data["lstObjectSOTaskStatus"].push(item.toJSON());
        }
        data["eventType"] = this.eventType;
        data["objectID"] = this.objectID;
        return data;
    }
}

export interface IEmailEventRequest {
    objReportSchDetails?: ReportSchDetails;
    lstObjectSOTaskStatus?: ObjectSOTaskStatus[] | undefined;
    eventType?: number;
    objectID?: number;
}

export class EmailRequisites implements IEmailRequisites {
    fromEmail?: string | undefined;
    toEmailCC?: string | undefined;
    toEmailBCC?: string | undefined;
    fromUserName?: string | undefined;
    toEmail?: string | undefined;
    toUserName?: string | undefined;
    subject?: string | undefined;
    body?: string | undefined;
    objectID?: number;
    objectInstanceID?: number | undefined;
    objectInstanceRevNo?: number | undefined;
    emailURL?: string | undefined;
    emailCount?: number;
    notifiedBy?: number | undefined;

    constructor(data?: IEmailRequisites) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fromEmail = _data["fromEmail"];
            this.toEmailCC = _data["toEmailCC"];
            this.toEmailBCC = _data["toEmailBCC"];
            this.fromUserName = _data["fromUserName"];
            this.toEmail = _data["toEmail"];
            this.toUserName = _data["toUserName"];
            this.subject = _data["subject"];
            this.body = _data["body"];
            this.objectID = _data["objectID"];
            this.objectInstanceID = _data["objectInstanceID"];
            this.objectInstanceRevNo = _data["objectInstanceRevNo"];
            this.emailURL = _data["emailURL"];
            this.emailCount = _data["emailCount"];
            this.notifiedBy = _data["notifiedBy"];
        }
    }

    static fromJS(data: any): EmailRequisites {
        data = typeof data === 'object' ? data : {};
        let result = new EmailRequisites();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fromEmail"] = this.fromEmail;
        data["toEmailCC"] = this.toEmailCC;
        data["toEmailBCC"] = this.toEmailBCC;
        data["fromUserName"] = this.fromUserName;
        data["toEmail"] = this.toEmail;
        data["toUserName"] = this.toUserName;
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["objectID"] = this.objectID;
        data["objectInstanceID"] = this.objectInstanceID;
        data["objectInstanceRevNo"] = this.objectInstanceRevNo;
        data["emailURL"] = this.emailURL;
        data["emailCount"] = this.emailCount;
        data["notifiedBy"] = this.notifiedBy;
        return data;
    }
}

export interface IEmailRequisites {
    fromEmail?: string | undefined;
    toEmailCC?: string | undefined;
    toEmailBCC?: string | undefined;
    fromUserName?: string | undefined;
    toEmail?: string | undefined;
    toUserName?: string | undefined;
    subject?: string | undefined;
    body?: string | undefined;
    objectID?: number;
    objectInstanceID?: number | undefined;
    objectInstanceRevNo?: number | undefined;
    emailURL?: string | undefined;
    emailCount?: number;
    notifiedBy?: number | undefined;
}

export class FirmContactDetails implements IFirmContactDetails {
    firmID?: number;
    applicationID?: number;
    fullName?: string | undefined;
    id?: number;
    userId?: number;
    userModified?: number;
    createdDate?: string | undefined;
    value?: string | undefined;
    qfcNmuner?: string | undefined;
    formTypeID?: number;
    applContactDetailID?: number;
    applicationStatusTypeID?: number;
    addressLine1?: string | undefined;
    addressLine2?: string | undefined;
    addressLine3?: string | undefined;
    addressLine4?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    countryID?: string | undefined;
    countryName?: string | undefined;
    postalCode?: string | undefined;
    firmName?: string | undefined;
    functionID?: number;
    positionOfMainContact?: string | undefined;
    contactID?: number;
    nameOfMainContact?: string | undefined;
    telephoneNumber?: string | undefined;
    faxNumber?: string | undefined;
    emailAddressOfMainAccount?: string | undefined;
    preferredMethodOfContact?: string | undefined;
    aiNumber?: string | undefined;
    modifiedDate?: string | undefined;
    primarySupervisorEmailAddress?: string | undefined;
    secondarySupervisorEmailAddress?: string | undefined;
    additionalSupervisorEmailAddress?: string | undefined;
    amlPrimarySupervisorEmailAddress?: string | undefined;
    amlSecondarySupervisorEmailAddress?: string | undefined;
    additionalAMLSupervisorEmailAddress?: string | undefined;
    directorEmailAddress?: string | undefined;
    amlDirectorEmailAddress?: string | undefined;
    rsgEmailAddress?: string | undefined;
    firmTypeID?: number;

    constructor(data?: IFirmContactDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmID = _data["firmID"];
            this.applicationID = _data["applicationID"];
            this.fullName = _data["fullName"];
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.userModified = _data["userModified"];
            this.createdDate = _data["createdDate"];
            this.value = _data["value"];
            this.qfcNmuner = _data["qfcNmuner"];
            this.formTypeID = _data["formTypeID"];
            this.applContactDetailID = _data["applContactDetailID"];
            this.applicationStatusTypeID = _data["applicationStatusTypeID"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.addressLine3 = _data["addressLine3"];
            this.addressLine4 = _data["addressLine4"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.countryID = _data["countryID"];
            this.countryName = _data["countryName"];
            this.postalCode = _data["postalCode"];
            this.firmName = _data["firmName"];
            this.functionID = _data["functionID"];
            this.positionOfMainContact = _data["positionOfMainContact"];
            this.contactID = _data["contactID"];
            this.nameOfMainContact = _data["nameOfMainContact"];
            this.telephoneNumber = _data["telephoneNumber"];
            this.faxNumber = _data["faxNumber"];
            this.emailAddressOfMainAccount = _data["emailAddressOfMainAccount"];
            this.preferredMethodOfContact = _data["preferredMethodOfContact"];
            this.aiNumber = _data["aiNumber"];
            this.modifiedDate = _data["modifiedDate"];
            this.primarySupervisorEmailAddress = _data["primarySupervisorEmailAddress"];
            this.secondarySupervisorEmailAddress = _data["secondarySupervisorEmailAddress"];
            this.additionalSupervisorEmailAddress = _data["additionalSupervisorEmailAddress"];
            this.amlPrimarySupervisorEmailAddress = _data["amlPrimarySupervisorEmailAddress"];
            this.amlSecondarySupervisorEmailAddress = _data["amlSecondarySupervisorEmailAddress"];
            this.additionalAMLSupervisorEmailAddress = _data["additionalAMLSupervisorEmailAddress"];
            this.directorEmailAddress = _data["directorEmailAddress"];
            this.amlDirectorEmailAddress = _data["amlDirectorEmailAddress"];
            this.rsgEmailAddress = _data["rsgEmailAddress"];
            this.firmTypeID = _data["firmTypeID"];
        }
    }

    static fromJS(data: any): FirmContactDetails {
        data = typeof data === 'object' ? data : {};
        let result = new FirmContactDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmID"] = this.firmID;
        data["applicationID"] = this.applicationID;
        data["fullName"] = this.fullName;
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["userModified"] = this.userModified;
        data["createdDate"] = this.createdDate;
        data["value"] = this.value;
        data["qfcNmuner"] = this.qfcNmuner;
        data["formTypeID"] = this.formTypeID;
        data["applContactDetailID"] = this.applContactDetailID;
        data["applicationStatusTypeID"] = this.applicationStatusTypeID;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["addressLine3"] = this.addressLine3;
        data["addressLine4"] = this.addressLine4;
        data["city"] = this.city;
        data["state"] = this.state;
        data["countryID"] = this.countryID;
        data["countryName"] = this.countryName;
        data["postalCode"] = this.postalCode;
        data["firmName"] = this.firmName;
        data["functionID"] = this.functionID;
        data["positionOfMainContact"] = this.positionOfMainContact;
        data["contactID"] = this.contactID;
        data["nameOfMainContact"] = this.nameOfMainContact;
        data["telephoneNumber"] = this.telephoneNumber;
        data["faxNumber"] = this.faxNumber;
        data["emailAddressOfMainAccount"] = this.emailAddressOfMainAccount;
        data["preferredMethodOfContact"] = this.preferredMethodOfContact;
        data["aiNumber"] = this.aiNumber;
        data["modifiedDate"] = this.modifiedDate;
        data["primarySupervisorEmailAddress"] = this.primarySupervisorEmailAddress;
        data["secondarySupervisorEmailAddress"] = this.secondarySupervisorEmailAddress;
        data["additionalSupervisorEmailAddress"] = this.additionalSupervisorEmailAddress;
        data["amlPrimarySupervisorEmailAddress"] = this.amlPrimarySupervisorEmailAddress;
        data["amlSecondarySupervisorEmailAddress"] = this.amlSecondarySupervisorEmailAddress;
        data["additionalAMLSupervisorEmailAddress"] = this.additionalAMLSupervisorEmailAddress;
        data["directorEmailAddress"] = this.directorEmailAddress;
        data["amlDirectorEmailAddress"] = this.amlDirectorEmailAddress;
        data["rsgEmailAddress"] = this.rsgEmailAddress;
        data["firmTypeID"] = this.firmTypeID;
        return data;
    }
}

export interface IFirmContactDetails {
    firmID?: number;
    applicationID?: number;
    fullName?: string | undefined;
    id?: number;
    userId?: number;
    userModified?: number;
    createdDate?: string | undefined;
    value?: string | undefined;
    qfcNmuner?: string | undefined;
    formTypeID?: number;
    applContactDetailID?: number;
    applicationStatusTypeID?: number;
    addressLine1?: string | undefined;
    addressLine2?: string | undefined;
    addressLine3?: string | undefined;
    addressLine4?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    countryID?: string | undefined;
    countryName?: string | undefined;
    postalCode?: string | undefined;
    firmName?: string | undefined;
    functionID?: number;
    positionOfMainContact?: string | undefined;
    contactID?: number;
    nameOfMainContact?: string | undefined;
    telephoneNumber?: string | undefined;
    faxNumber?: string | undefined;
    emailAddressOfMainAccount?: string | undefined;
    preferredMethodOfContact?: string | undefined;
    aiNumber?: string | undefined;
    modifiedDate?: string | undefined;
    primarySupervisorEmailAddress?: string | undefined;
    secondarySupervisorEmailAddress?: string | undefined;
    additionalSupervisorEmailAddress?: string | undefined;
    amlPrimarySupervisorEmailAddress?: string | undefined;
    amlSecondarySupervisorEmailAddress?: string | undefined;
    additionalAMLSupervisorEmailAddress?: string | undefined;
    directorEmailAddress?: string | undefined;
    amlDirectorEmailAddress?: string | undefined;
    rsgEmailAddress?: string | undefined;
    firmTypeID?: number;
}

export class FirmDto implements IFirmDto {
    qfcNumber?: string | undefined;
    firmName?: string | undefined;
    isEssActive?: boolean | undefined;
    fromDate?: string | undefined;
    endDate?: string | undefined;
    lastModifiedBy?: number | undefined;
    firmTypeID?: number | undefined;

    constructor(data?: IFirmDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.qfcNumber = _data["qfcNumber"];
            this.firmName = _data["firmName"];
            this.isEssActive = _data["isEssActive"];
            this.fromDate = _data["fromDate"];
            this.endDate = _data["endDate"];
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.firmTypeID = _data["firmTypeID"];
        }
    }

    static fromJS(data: any): FirmDto {
        data = typeof data === 'object' ? data : {};
        let result = new FirmDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qfcNumber"] = this.qfcNumber;
        data["firmName"] = this.firmName;
        data["isEssActive"] = this.isEssActive;
        data["fromDate"] = this.fromDate;
        data["endDate"] = this.endDate;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["firmTypeID"] = this.firmTypeID;
        return data;
    }
}

export interface IFirmDto {
    qfcNumber?: string | undefined;
    firmName?: string | undefined;
    isEssActive?: boolean | undefined;
    fromDate?: string | undefined;
    endDate?: string | undefined;
    lastModifiedBy?: number | undefined;
    firmTypeID?: number | undefined;
}

export class FirmDtoListBaseResponse implements IFirmDtoListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: FirmDto[] | undefined;

    constructor(data?: IFirmDtoListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["response"])) {
                this.response = [] as any;
                for (let item of _data["response"])
                    this.response!.push(FirmDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FirmDtoListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new FirmDtoListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.response)) {
            data["response"] = [];
            for (let item of this.response)
                data["response"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFirmDtoListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: FirmDto[] | undefined;
}

export class FirmNoticeResponseItems implements IFirmNoticeResponseItems {
    noticeResponseItemID?: number | undefined;
    essNoticeResponseItemID?: number;
    noticeQuestionNumber?: string | undefined;
    noticeQuestion?: string | undefined;
    responseTypeID?: number | undefined;
    questionDisplayOrder?: number;
    noticeQuestionnaireItemID?: number;
    responses?: string | undefined;
    explanation?: string | undefined;
    explanationReqdCriteriaMet?: boolean | undefined;
    explanationRequired?: number | undefined;
    createdBy?: number;
    lstFirmNoticeResponseValues?: FirmNoticeResponseValues[] | undefined;

    constructor(data?: IFirmNoticeResponseItems) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noticeResponseItemID = _data["noticeResponseItemID"];
            this.essNoticeResponseItemID = _data["essNoticeResponseItemID"];
            this.noticeQuestionNumber = _data["noticeQuestionNumber"];
            this.noticeQuestion = _data["noticeQuestion"];
            this.responseTypeID = _data["responseTypeID"];
            this.questionDisplayOrder = _data["questionDisplayOrder"];
            this.noticeQuestionnaireItemID = _data["noticeQuestionnaireItemID"];
            this.responses = _data["responses"];
            this.explanation = _data["explanation"];
            this.explanationReqdCriteriaMet = _data["explanationReqdCriteriaMet"];
            this.explanationRequired = _data["explanationRequired"];
            this.createdBy = _data["createdBy"];
            if (Array.isArray(_data["lstFirmNoticeResponseValues"])) {
                this.lstFirmNoticeResponseValues = [] as any;
                for (let item of _data["lstFirmNoticeResponseValues"])
                    this.lstFirmNoticeResponseValues!.push(FirmNoticeResponseValues.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FirmNoticeResponseItems {
        data = typeof data === 'object' ? data : {};
        let result = new FirmNoticeResponseItems();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noticeResponseItemID"] = this.noticeResponseItemID;
        data["essNoticeResponseItemID"] = this.essNoticeResponseItemID;
        data["noticeQuestionNumber"] = this.noticeQuestionNumber;
        data["noticeQuestion"] = this.noticeQuestion;
        data["responseTypeID"] = this.responseTypeID;
        data["questionDisplayOrder"] = this.questionDisplayOrder;
        data["noticeQuestionnaireItemID"] = this.noticeQuestionnaireItemID;
        data["responses"] = this.responses;
        data["explanation"] = this.explanation;
        data["explanationReqdCriteriaMet"] = this.explanationReqdCriteriaMet;
        data["explanationRequired"] = this.explanationRequired;
        data["createdBy"] = this.createdBy;
        if (Array.isArray(this.lstFirmNoticeResponseValues)) {
            data["lstFirmNoticeResponseValues"] = [];
            for (let item of this.lstFirmNoticeResponseValues)
                data["lstFirmNoticeResponseValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFirmNoticeResponseItems {
    noticeResponseItemID?: number | undefined;
    essNoticeResponseItemID?: number;
    noticeQuestionNumber?: string | undefined;
    noticeQuestion?: string | undefined;
    responseTypeID?: number | undefined;
    questionDisplayOrder?: number;
    noticeQuestionnaireItemID?: number;
    responses?: string | undefined;
    explanation?: string | undefined;
    explanationReqdCriteriaMet?: boolean | undefined;
    explanationRequired?: number | undefined;
    createdBy?: number;
    lstFirmNoticeResponseValues?: FirmNoticeResponseValues[] | undefined;
}

export class FirmNoticeResponseValues implements IFirmNoticeResponseValues {
    noticeResponseValueID?: number | undefined;
    response?: string | undefined;
    listValueID?: number | undefined;
    essNoticeResponseItemID?: number;
    createdBy?: number;

    constructor(data?: IFirmNoticeResponseValues) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noticeResponseValueID = _data["noticeResponseValueID"];
            this.response = _data["response"];
            this.listValueID = _data["listValueID"];
            this.essNoticeResponseItemID = _data["essNoticeResponseItemID"];
            this.createdBy = _data["createdBy"];
        }
    }

    static fromJS(data: any): FirmNoticeResponseValues {
        data = typeof data === 'object' ? data : {};
        let result = new FirmNoticeResponseValues();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noticeResponseValueID"] = this.noticeResponseValueID;
        data["response"] = this.response;
        data["listValueID"] = this.listValueID;
        data["essNoticeResponseItemID"] = this.essNoticeResponseItemID;
        data["createdBy"] = this.createdBy;
        return data;
    }
}

export interface IFirmNoticeResponseValues {
    noticeResponseValueID?: number | undefined;
    response?: string | undefined;
    listValueID?: number | undefined;
    essNoticeResponseItemID?: number;
    createdBy?: number;
}

export class FirmNoticesDto implements IFirmNoticesDto {
    noticeID?: number;
    firmNoticeID?: number;
    firmID?: number;
    qfcNumber?: string | undefined;
    objectSOStatusID?: number | undefined;
    escalationReqdCriteriaMet?: boolean | undefined;
    notes?: string | undefined;
    responseProvidedBy?: string | undefined;
    responseProvidedDate?: string | undefined;
    opType?: string | undefined;
    createdBy?: number;
    lstFirmNoticeResponseItems?: FirmNoticeResponseItems[] | undefined;

    constructor(data?: IFirmNoticesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noticeID = _data["noticeID"];
            this.firmNoticeID = _data["firmNoticeID"];
            this.firmID = _data["firmID"];
            this.qfcNumber = _data["qfcNumber"];
            this.objectSOStatusID = _data["objectSOStatusID"];
            this.escalationReqdCriteriaMet = _data["escalationReqdCriteriaMet"];
            this.notes = _data["notes"];
            this.responseProvidedBy = _data["responseProvidedBy"];
            this.responseProvidedDate = _data["responseProvidedDate"];
            this.opType = _data["opType"];
            this.createdBy = _data["createdBy"];
            if (Array.isArray(_data["lstFirmNoticeResponseItems"])) {
                this.lstFirmNoticeResponseItems = [] as any;
                for (let item of _data["lstFirmNoticeResponseItems"])
                    this.lstFirmNoticeResponseItems!.push(FirmNoticeResponseItems.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FirmNoticesDto {
        data = typeof data === 'object' ? data : {};
        let result = new FirmNoticesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noticeID"] = this.noticeID;
        data["firmNoticeID"] = this.firmNoticeID;
        data["firmID"] = this.firmID;
        data["qfcNumber"] = this.qfcNumber;
        data["objectSOStatusID"] = this.objectSOStatusID;
        data["escalationReqdCriteriaMet"] = this.escalationReqdCriteriaMet;
        data["notes"] = this.notes;
        data["responseProvidedBy"] = this.responseProvidedBy;
        data["responseProvidedDate"] = this.responseProvidedDate;
        data["opType"] = this.opType;
        data["createdBy"] = this.createdBy;
        if (Array.isArray(this.lstFirmNoticeResponseItems)) {
            data["lstFirmNoticeResponseItems"] = [];
            for (let item of this.lstFirmNoticeResponseItems)
                data["lstFirmNoticeResponseItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFirmNoticesDto {
    noticeID?: number;
    firmNoticeID?: number;
    firmID?: number;
    qfcNumber?: string | undefined;
    objectSOStatusID?: number | undefined;
    escalationReqdCriteriaMet?: boolean | undefined;
    notes?: string | undefined;
    responseProvidedBy?: string | undefined;
    responseProvidedDate?: string | undefined;
    opType?: string | undefined;
    createdBy?: number;
    lstFirmNoticeResponseItems?: FirmNoticeResponseItems[] | undefined;
}

export class FirmNoticesDtoBaseResponse implements IFirmNoticesDtoBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: FirmNoticesDto;

    constructor(data?: IFirmNoticesDtoBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            this.response = _data["response"] ? FirmNoticesDto.fromJS(_data["response"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FirmNoticesDtoBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new FirmNoticesDtoBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFirmNoticesDtoBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: FirmNoticesDto;
}

export class FirmReportSchItemsDto implements IFirmReportSchItemsDto {
    firmRptSchItemID?: number | undefined;
    rptSchItemAttachmentID?: number | undefined;
    validationResult?: number | undefined;
    validationFileName?: string | undefined;
    validationFileLocation?: string | undefined;

    constructor(data?: IFirmReportSchItemsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmRptSchItemID = _data["firmRptSchItemID"];
            this.rptSchItemAttachmentID = _data["rptSchItemAttachmentID"];
            this.validationResult = _data["validationResult"];
            this.validationFileName = _data["validationFileName"];
            this.validationFileLocation = _data["validationFileLocation"];
        }
    }

    static fromJS(data: any): FirmReportSchItemsDto {
        data = typeof data === 'object' ? data : {};
        let result = new FirmReportSchItemsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmRptSchItemID"] = this.firmRptSchItemID;
        data["rptSchItemAttachmentID"] = this.rptSchItemAttachmentID;
        data["validationResult"] = this.validationResult;
        data["validationFileName"] = this.validationFileName;
        data["validationFileLocation"] = this.validationFileLocation;
        return data;
    }
}

export interface IFirmReportSchItemsDto {
    firmRptSchItemID?: number | undefined;
    rptSchItemAttachmentID?: number | undefined;
    validationResult?: number | undefined;
    validationFileName?: string | undefined;
    validationFileLocation?: string | undefined;
}

export class GeneralSubmissionDto implements IGeneralSubmissionDto {
    genSubmissionID?: number | undefined;
    qfcNumber?: string | undefined;
    docTypeID?: number | undefined;
    comments?: string | undefined;
    rptSOMethodTypeID?: number | undefined;
    objectStatusTypeID?: number | undefined;
    wObjectSOStatusID?: number | undefined;
    userCreated?: number | undefined;
    dateCreated?: string | undefined;
    userModified?: number | undefined;
    dateModified?: string | undefined;
    soCompletionDate?: string | undefined;
    fileName?: string | undefined;
    supervisorName?: string | undefined;
    objectID?: number | undefined;

    constructor(data?: IGeneralSubmissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.genSubmissionID = _data["genSubmissionID"];
            this.qfcNumber = _data["qfcNumber"];
            this.docTypeID = _data["docTypeID"];
            this.comments = _data["comments"];
            this.rptSOMethodTypeID = _data["rptSOMethodTypeID"];
            this.objectStatusTypeID = _data["objectStatusTypeID"];
            this.wObjectSOStatusID = _data["wObjectSOStatusID"];
            this.userCreated = _data["userCreated"];
            this.dateCreated = _data["dateCreated"];
            this.userModified = _data["userModified"];
            this.dateModified = _data["dateModified"];
            this.soCompletionDate = _data["soCompletionDate"];
            this.fileName = _data["fileName"];
            this.supervisorName = _data["supervisorName"];
            this.objectID = _data["objectID"];
        }
    }

    static fromJS(data: any): GeneralSubmissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSubmissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["genSubmissionID"] = this.genSubmissionID;
        data["qfcNumber"] = this.qfcNumber;
        data["docTypeID"] = this.docTypeID;
        data["comments"] = this.comments;
        data["rptSOMethodTypeID"] = this.rptSOMethodTypeID;
        data["objectStatusTypeID"] = this.objectStatusTypeID;
        data["wObjectSOStatusID"] = this.wObjectSOStatusID;
        data["userCreated"] = this.userCreated;
        data["dateCreated"] = this.dateCreated;
        data["userModified"] = this.userModified;
        data["dateModified"] = this.dateModified;
        data["soCompletionDate"] = this.soCompletionDate;
        data["fileName"] = this.fileName;
        data["supervisorName"] = this.supervisorName;
        data["objectID"] = this.objectID;
        return data;
    }
}

export interface IGeneralSubmissionDto {
    genSubmissionID?: number | undefined;
    qfcNumber?: string | undefined;
    docTypeID?: number | undefined;
    comments?: string | undefined;
    rptSOMethodTypeID?: number | undefined;
    objectStatusTypeID?: number | undefined;
    wObjectSOStatusID?: number | undefined;
    userCreated?: number | undefined;
    dateCreated?: string | undefined;
    userModified?: number | undefined;
    dateModified?: string | undefined;
    soCompletionDate?: string | undefined;
    fileName?: string | undefined;
    supervisorName?: string | undefined;
    objectID?: number | undefined;
}

export class GeneralSubmissionDtoBaseResponse implements IGeneralSubmissionDtoBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: GeneralSubmissionDto;

    constructor(data?: IGeneralSubmissionDtoBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            this.response = _data["response"] ? GeneralSubmissionDto.fromJS(_data["response"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GeneralSubmissionDtoBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSubmissionDtoBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGeneralSubmissionDtoBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: GeneralSubmissionDto;
}

export class GeneralSubmissionForm implements IGeneralSubmissionForm {
    linkToDownload?: string | undefined;
    linkToSubmitToRA?: string | undefined;
    docTypeDesc?: string | undefined;
    docTypeId?: number;
    wIndFromTypeID?: number;

    constructor(data?: IGeneralSubmissionForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.linkToDownload = _data["linkToDownload"];
            this.linkToSubmitToRA = _data["linkToSubmitToRA"];
            this.docTypeDesc = _data["docTypeDesc"];
            this.docTypeId = _data["docTypeId"];
            this.wIndFromTypeID = _data["wIndFromTypeID"];
        }
    }

    static fromJS(data: any): GeneralSubmissionForm {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSubmissionForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["linkToDownload"] = this.linkToDownload;
        data["linkToSubmitToRA"] = this.linkToSubmitToRA;
        data["docTypeDesc"] = this.docTypeDesc;
        data["docTypeId"] = this.docTypeId;
        data["wIndFromTypeID"] = this.wIndFromTypeID;
        return data;
    }
}

export interface IGeneralSubmissionForm {
    linkToDownload?: string | undefined;
    linkToSubmitToRA?: string | undefined;
    docTypeDesc?: string | undefined;
    docTypeId?: number;
    wIndFromTypeID?: number;
}

export class GeneralSubmissionFormListBaseResponse implements IGeneralSubmissionFormListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: GeneralSubmissionForm[] | undefined;

    constructor(data?: IGeneralSubmissionFormListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["response"])) {
                this.response = [] as any;
                for (let item of _data["response"])
                    this.response!.push(GeneralSubmissionForm.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GeneralSubmissionFormListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSubmissionFormListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.response)) {
            data["response"] = [];
            for (let item of this.response)
                data["response"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGeneralSubmissionFormListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: GeneralSubmissionForm[] | undefined;
}

export class HistoryDetailsDto implements IHistoryDetailsDto {
    objectID?: number | undefined;
    rptSchItemID?: number | undefined;
    docTypeID?: number | undefined;
    lstAattachments?: AttachmentDto[] | undefined;

    constructor(data?: IHistoryDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectID = _data["objectID"];
            this.rptSchItemID = _data["rptSchItemID"];
            this.docTypeID = _data["docTypeID"];
            if (Array.isArray(_data["lstAattachments"])) {
                this.lstAattachments = [] as any;
                for (let item of _data["lstAattachments"])
                    this.lstAattachments!.push(AttachmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HistoryDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new HistoryDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectID"] = this.objectID;
        data["rptSchItemID"] = this.rptSchItemID;
        data["docTypeID"] = this.docTypeID;
        if (Array.isArray(this.lstAattachments)) {
            data["lstAattachments"] = [];
            for (let item of this.lstAattachments)
                data["lstAattachments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IHistoryDetailsDto {
    objectID?: number | undefined;
    rptSchItemID?: number | undefined;
    docTypeID?: number | undefined;
    lstAattachments?: AttachmentDto[] | undefined;
}

export class IComponent implements IIComponent {
    site?: ISite;

    constructor(data?: IIComponent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.site = _data["site"] ? ISite.fromJS(_data["site"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IComponent {
        data = typeof data === 'object' ? data : {};
        let result = new IComponent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["site"] = this.site ? this.site.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIComponent {
    site?: ISite;
}

export class IContainer implements IIContainer {
    readonly components?: any[] | undefined;

    constructor(data?: IIContainer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["components"])) {
                (<any>this).components = [] as any;
                for (let item of _data["components"])
                    (<any>this).components!.push(item);
            }
        }
    }

    static fromJS(data: any): IContainer {
        data = typeof data === 'object' ? data : {};
        let result = new IContainer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.components)) {
            data["components"] = [];
            for (let item of this.components)
                data["components"].push(item);
        }
        return data;
    }
}

export interface IIContainer {
    components?: any[] | undefined;
}

export class ISite implements IISite {
    component?: IComponent;
    container?: IContainer;
    readonly designMode?: boolean;
    name?: string | undefined;

    constructor(data?: IISite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.component = _data["component"] ? IComponent.fromJS(_data["component"]) : <any>undefined;
            this.container = _data["container"] ? IContainer.fromJS(_data["container"]) : <any>undefined;
            (<any>this).designMode = _data["designMode"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ISite {
        data = typeof data === 'object' ? data : {};
        let result = new ISite();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["component"] = this.component ? this.component.toJSON() : <any>undefined;
        data["container"] = this.container ? this.container.toJSON() : <any>undefined;
        data["designMode"] = this.designMode;
        data["name"] = this.name;
        return data;
    }
}

export interface IISite {
    component?: IComponent;
    container?: IContainer;
    designMode?: boolean;
    name?: string | undefined;
}

export class IndividualDetailDto implements IIndividualDetailDto {
    fullName?: string | undefined;
    aiNumber?: string | undefined;
    qfcNumber?: string | undefined;
    emailAddress?: string | undefined;
    dateOfBirth?: string | undefined;

    constructor(data?: IIndividualDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"];
            this.aiNumber = _data["aiNumber"];
            this.qfcNumber = _data["qfcNumber"];
            this.emailAddress = _data["emailAddress"];
            this.dateOfBirth = _data["dateOfBirth"];
        }
    }

    static fromJS(data: any): IndividualDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new IndividualDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["aiNumber"] = this.aiNumber;
        data["qfcNumber"] = this.qfcNumber;
        data["emailAddress"] = this.emailAddress;
        data["dateOfBirth"] = this.dateOfBirth;
        return data;
    }
}

export interface IIndividualDetailDto {
    fullName?: string | undefined;
    aiNumber?: string | undefined;
    qfcNumber?: string | undefined;
    emailAddress?: string | undefined;
    dateOfBirth?: string | undefined;
}

export class IndividualDetailDtoBaseResponse implements IIndividualDetailDtoBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: IndividualDetailDto;

    constructor(data?: IIndividualDetailDtoBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            this.response = _data["response"] ? IndividualDetailDto.fromJS(_data["response"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IndividualDetailDtoBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new IndividualDetailDtoBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIndividualDetailDtoBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: IndividualDetailDto;
}

export class IndividualDetails implements IIndividualDetails {
    title?: string | undefined;
    familyName?: string | undefined;
    otherNames?: string | undefined;
    previousNames?: PreviousNames[] | undefined;
    dateOfBirth?: string | undefined;
    placeOfBirthCity?: string | undefined;
    placeOfBirthCountry?: string | undefined;
    nationality?: string | undefined;
    residencyList?: Residencies[] | undefined;
    passportnumber?: string | undefined;
    jurisdiction?: string | undefined;
    nationalIdNumber?: string | undefined;
    resTelephoneNumber?: string | undefined;
    workTelephonenumber?: string | undefined;
    emailAddress?: string | undefined;
    addressAssnDateFrom?: string | undefined;
    addressAssnDateTo?: string | undefined;
    addrLessThanThreeYears?: Address[] | undefined;
    addressQatar?: Address;
    dateQatar?: string | undefined;
    applicationID?: number;
    qfcNumber?: string | undefined;
    formTypeID?: string | undefined;
    userID?: number;
    personalDetailID?: number;
    residencyNAFlag?: boolean | undefined;
    aliasesNAFlag?: boolean | undefined;
    nationalIdNAFlag?: boolean | undefined;
    qatarRelocationNAFlag?: boolean | undefined;
    aiNumber?: string | undefined;
    nationalityID?: number;
    placeOfBirthCountryID?: number;
    createdDate?: string | undefined;
    modifiedBy?: number;
    modifiedDate?: string | undefined;
    fullName?: string | undefined;
    appIndividualID?: number;
    businessEmail?: string | undefined;
    proposedRelDay?: number;
    proposedRelMonth?: number;
    proposedRelYear?: number;
    countryOfResidence?: number;
    prevApplicationId?: number | undefined;
    wObjectSOStatusID?: number | undefined;
    isOrdinarilyResidentFlag?: boolean | undefined;
    windApplicationStatus?: number;

    constructor(data?: IIndividualDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.familyName = _data["familyName"];
            this.otherNames = _data["otherNames"];
            if (Array.isArray(_data["previousNames"])) {
                this.previousNames = [] as any;
                for (let item of _data["previousNames"])
                    this.previousNames!.push(PreviousNames.fromJS(item));
            }
            this.dateOfBirth = _data["dateOfBirth"];
            this.placeOfBirthCity = _data["placeOfBirthCity"];
            this.placeOfBirthCountry = _data["placeOfBirthCountry"];
            this.nationality = _data["nationality"];
            if (Array.isArray(_data["residencyList"])) {
                this.residencyList = [] as any;
                for (let item of _data["residencyList"])
                    this.residencyList!.push(Residencies.fromJS(item));
            }
            this.passportnumber = _data["passportnumber"];
            this.jurisdiction = _data["jurisdiction"];
            this.nationalIdNumber = _data["nationalIdNumber"];
            this.resTelephoneNumber = _data["resTelephoneNumber"];
            this.workTelephonenumber = _data["workTelephonenumber"];
            this.emailAddress = _data["emailAddress"];
            this.addressAssnDateFrom = _data["addressAssnDateFrom"];
            this.addressAssnDateTo = _data["addressAssnDateTo"];
            if (Array.isArray(_data["addrLessThanThreeYears"])) {
                this.addrLessThanThreeYears = [] as any;
                for (let item of _data["addrLessThanThreeYears"])
                    this.addrLessThanThreeYears!.push(Address.fromJS(item));
            }
            this.addressQatar = _data["addressQatar"] ? Address.fromJS(_data["addressQatar"]) : <any>undefined;
            this.dateQatar = _data["dateQatar"];
            this.applicationID = _data["applicationID"];
            this.qfcNumber = _data["qfcNumber"];
            this.formTypeID = _data["formTypeID"];
            this.userID = _data["userID"];
            this.personalDetailID = _data["personalDetailID"];
            this.residencyNAFlag = _data["residencyNAFlag"];
            this.aliasesNAFlag = _data["aliasesNAFlag"];
            this.nationalIdNAFlag = _data["nationalIdNAFlag"];
            this.qatarRelocationNAFlag = _data["qatarRelocationNAFlag"];
            this.aiNumber = _data["aiNumber"];
            this.nationalityID = _data["nationalityID"];
            this.placeOfBirthCountryID = _data["placeOfBirthCountryID"];
            this.createdDate = _data["createdDate"];
            this.modifiedBy = _data["modifiedBy"];
            this.modifiedDate = _data["modifiedDate"];
            this.fullName = _data["fullName"];
            this.appIndividualID = _data["appIndividualID"];
            this.businessEmail = _data["businessEmail"];
            this.proposedRelDay = _data["proposedRelDay"];
            this.proposedRelMonth = _data["proposedRelMonth"];
            this.proposedRelYear = _data["proposedRelYear"];
            this.countryOfResidence = _data["countryOfResidence"];
            this.prevApplicationId = _data["prevApplicationId"];
            this.wObjectSOStatusID = _data["wObjectSOStatusID"];
            this.isOrdinarilyResidentFlag = _data["isOrdinarilyResidentFlag"];
            this.windApplicationStatus = _data["windApplicationStatus"];
        }
    }

    static fromJS(data: any): IndividualDetails {
        data = typeof data === 'object' ? data : {};
        let result = new IndividualDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["familyName"] = this.familyName;
        data["otherNames"] = this.otherNames;
        if (Array.isArray(this.previousNames)) {
            data["previousNames"] = [];
            for (let item of this.previousNames)
                data["previousNames"].push(item.toJSON());
        }
        data["dateOfBirth"] = this.dateOfBirth;
        data["placeOfBirthCity"] = this.placeOfBirthCity;
        data["placeOfBirthCountry"] = this.placeOfBirthCountry;
        data["nationality"] = this.nationality;
        if (Array.isArray(this.residencyList)) {
            data["residencyList"] = [];
            for (let item of this.residencyList)
                data["residencyList"].push(item.toJSON());
        }
        data["passportnumber"] = this.passportnumber;
        data["jurisdiction"] = this.jurisdiction;
        data["nationalIdNumber"] = this.nationalIdNumber;
        data["resTelephoneNumber"] = this.resTelephoneNumber;
        data["workTelephonenumber"] = this.workTelephonenumber;
        data["emailAddress"] = this.emailAddress;
        data["addressAssnDateFrom"] = this.addressAssnDateFrom;
        data["addressAssnDateTo"] = this.addressAssnDateTo;
        if (Array.isArray(this.addrLessThanThreeYears)) {
            data["addrLessThanThreeYears"] = [];
            for (let item of this.addrLessThanThreeYears)
                data["addrLessThanThreeYears"].push(item.toJSON());
        }
        data["addressQatar"] = this.addressQatar ? this.addressQatar.toJSON() : <any>undefined;
        data["dateQatar"] = this.dateQatar;
        data["applicationID"] = this.applicationID;
        data["qfcNumber"] = this.qfcNumber;
        data["formTypeID"] = this.formTypeID;
        data["userID"] = this.userID;
        data["personalDetailID"] = this.personalDetailID;
        data["residencyNAFlag"] = this.residencyNAFlag;
        data["aliasesNAFlag"] = this.aliasesNAFlag;
        data["nationalIdNAFlag"] = this.nationalIdNAFlag;
        data["qatarRelocationNAFlag"] = this.qatarRelocationNAFlag;
        data["aiNumber"] = this.aiNumber;
        data["nationalityID"] = this.nationalityID;
        data["placeOfBirthCountryID"] = this.placeOfBirthCountryID;
        data["createdDate"] = this.createdDate;
        data["modifiedBy"] = this.modifiedBy;
        data["modifiedDate"] = this.modifiedDate;
        data["fullName"] = this.fullName;
        data["appIndividualID"] = this.appIndividualID;
        data["businessEmail"] = this.businessEmail;
        data["proposedRelDay"] = this.proposedRelDay;
        data["proposedRelMonth"] = this.proposedRelMonth;
        data["proposedRelYear"] = this.proposedRelYear;
        data["countryOfResidence"] = this.countryOfResidence;
        data["prevApplicationId"] = this.prevApplicationId;
        data["wObjectSOStatusID"] = this.wObjectSOStatusID;
        data["isOrdinarilyResidentFlag"] = this.isOrdinarilyResidentFlag;
        data["windApplicationStatus"] = this.windApplicationStatus;
        return data;
    }
}

export interface IIndividualDetails {
    title?: string | undefined;
    familyName?: string | undefined;
    otherNames?: string | undefined;
    previousNames?: PreviousNames[] | undefined;
    dateOfBirth?: string | undefined;
    placeOfBirthCity?: string | undefined;
    placeOfBirthCountry?: string | undefined;
    nationality?: string | undefined;
    residencyList?: Residencies[] | undefined;
    passportnumber?: string | undefined;
    jurisdiction?: string | undefined;
    nationalIdNumber?: string | undefined;
    resTelephoneNumber?: string | undefined;
    workTelephonenumber?: string | undefined;
    emailAddress?: string | undefined;
    addressAssnDateFrom?: string | undefined;
    addressAssnDateTo?: string | undefined;
    addrLessThanThreeYears?: Address[] | undefined;
    addressQatar?: Address;
    dateQatar?: string | undefined;
    applicationID?: number;
    qfcNumber?: string | undefined;
    formTypeID?: string | undefined;
    userID?: number;
    personalDetailID?: number;
    residencyNAFlag?: boolean | undefined;
    aliasesNAFlag?: boolean | undefined;
    nationalIdNAFlag?: boolean | undefined;
    qatarRelocationNAFlag?: boolean | undefined;
    aiNumber?: string | undefined;
    nationalityID?: number;
    placeOfBirthCountryID?: number;
    createdDate?: string | undefined;
    modifiedBy?: number;
    modifiedDate?: string | undefined;
    fullName?: string | undefined;
    appIndividualID?: number;
    businessEmail?: string | undefined;
    proposedRelDay?: number;
    proposedRelMonth?: number;
    proposedRelYear?: number;
    countryOfResidence?: number;
    prevApplicationId?: number | undefined;
    wObjectSOStatusID?: number | undefined;
    isOrdinarilyResidentFlag?: boolean | undefined;
    windApplicationStatus?: number;
}

export class IndividualDetailsDto implements IIndividualDetailsDto {
    applicationID?: number | undefined;
    qfcNumber?: string | undefined;
    aiNumber?: string | undefined;
    formTypeID?: string | undefined;
    userID?: number | undefined;
    personalDetailID?: number | undefined;
    wObjectSOStatusID?: number | undefined;
    windApplicationStatus?: number | undefined;
    nationalityID?: number | undefined;
    placeOfBirthCountryID?: number | undefined;
    modifiedBy?: number | undefined;
    proposedRelDay?: number | undefined;
    proposedRelMonth?: number | undefined;
    proposedRelYear?: number | undefined;
    countryOfResidence?: number | undefined;
    isOrdinarilyResidentFlag?: boolean | undefined;
    familyName?: string | undefined;
    createdDate?: string | undefined;
    modifiedDate?: string | undefined;
    title?: string | undefined;
    nationality?: string | undefined;
    placeOfBirthCountry?: string | undefined;
    nationalIdNumber?: string | undefined;
    resTelephoneNumber?: string | undefined;
    workTelephonenumber?: string | undefined;
    otherNames?: string | undefined;
    emailAddress?: string | undefined;
    dateOfBirth?: string | undefined;
    passportnumber?: string | undefined;
    jurisdiction?: string | undefined;
    placeOfBirthCity?: string | undefined;

    constructor(data?: IIndividualDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationID = _data["applicationID"];
            this.qfcNumber = _data["qfcNumber"];
            this.aiNumber = _data["aiNumber"];
            this.formTypeID = _data["formTypeID"];
            this.userID = _data["userID"];
            this.personalDetailID = _data["personalDetailID"];
            this.wObjectSOStatusID = _data["wObjectSOStatusID"];
            this.windApplicationStatus = _data["windApplicationStatus"];
            this.nationalityID = _data["nationalityID"];
            this.placeOfBirthCountryID = _data["placeOfBirthCountryID"];
            this.modifiedBy = _data["modifiedBy"];
            this.proposedRelDay = _data["proposedRelDay"];
            this.proposedRelMonth = _data["proposedRelMonth"];
            this.proposedRelYear = _data["proposedRelYear"];
            this.countryOfResidence = _data["countryOfResidence"];
            this.isOrdinarilyResidentFlag = _data["isOrdinarilyResidentFlag"];
            this.familyName = _data["familyName"];
            this.createdDate = _data["createdDate"];
            this.modifiedDate = _data["modifiedDate"];
            this.title = _data["title"];
            this.nationality = _data["nationality"];
            this.placeOfBirthCountry = _data["placeOfBirthCountry"];
            this.nationalIdNumber = _data["nationalIdNumber"];
            this.resTelephoneNumber = _data["resTelephoneNumber"];
            this.workTelephonenumber = _data["workTelephonenumber"];
            this.otherNames = _data["otherNames"];
            this.emailAddress = _data["emailAddress"];
            this.dateOfBirth = _data["dateOfBirth"];
            this.passportnumber = _data["passportnumber"];
            this.jurisdiction = _data["jurisdiction"];
            this.placeOfBirthCity = _data["placeOfBirthCity"];
        }
    }

    static fromJS(data: any): IndividualDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new IndividualDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicationID"] = this.applicationID;
        data["qfcNumber"] = this.qfcNumber;
        data["aiNumber"] = this.aiNumber;
        data["formTypeID"] = this.formTypeID;
        data["userID"] = this.userID;
        data["personalDetailID"] = this.personalDetailID;
        data["wObjectSOStatusID"] = this.wObjectSOStatusID;
        data["windApplicationStatus"] = this.windApplicationStatus;
        data["nationalityID"] = this.nationalityID;
        data["placeOfBirthCountryID"] = this.placeOfBirthCountryID;
        data["modifiedBy"] = this.modifiedBy;
        data["proposedRelDay"] = this.proposedRelDay;
        data["proposedRelMonth"] = this.proposedRelMonth;
        data["proposedRelYear"] = this.proposedRelYear;
        data["countryOfResidence"] = this.countryOfResidence;
        data["isOrdinarilyResidentFlag"] = this.isOrdinarilyResidentFlag;
        data["familyName"] = this.familyName;
        data["createdDate"] = this.createdDate;
        data["modifiedDate"] = this.modifiedDate;
        data["title"] = this.title;
        data["nationality"] = this.nationality;
        data["placeOfBirthCountry"] = this.placeOfBirthCountry;
        data["nationalIdNumber"] = this.nationalIdNumber;
        data["resTelephoneNumber"] = this.resTelephoneNumber;
        data["workTelephonenumber"] = this.workTelephonenumber;
        data["otherNames"] = this.otherNames;
        data["emailAddress"] = this.emailAddress;
        data["dateOfBirth"] = this.dateOfBirth;
        data["passportnumber"] = this.passportnumber;
        data["jurisdiction"] = this.jurisdiction;
        data["placeOfBirthCity"] = this.placeOfBirthCity;
        return data;
    }
}

export interface IIndividualDetailsDto {
    applicationID?: number | undefined;
    qfcNumber?: string | undefined;
    aiNumber?: string | undefined;
    formTypeID?: string | undefined;
    userID?: number | undefined;
    personalDetailID?: number | undefined;
    wObjectSOStatusID?: number | undefined;
    windApplicationStatus?: number | undefined;
    nationalityID?: number | undefined;
    placeOfBirthCountryID?: number | undefined;
    modifiedBy?: number | undefined;
    proposedRelDay?: number | undefined;
    proposedRelMonth?: number | undefined;
    proposedRelYear?: number | undefined;
    countryOfResidence?: number | undefined;
    isOrdinarilyResidentFlag?: boolean | undefined;
    familyName?: string | undefined;
    createdDate?: string | undefined;
    modifiedDate?: string | undefined;
    title?: string | undefined;
    nationality?: string | undefined;
    placeOfBirthCountry?: string | undefined;
    nationalIdNumber?: string | undefined;
    resTelephoneNumber?: string | undefined;
    workTelephonenumber?: string | undefined;
    otherNames?: string | undefined;
    emailAddress?: string | undefined;
    dateOfBirth?: string | undefined;
    passportnumber?: string | undefined;
    jurisdiction?: string | undefined;
    placeOfBirthCity?: string | undefined;
}

export class IndividualDetailsDtoBaseResponse implements IIndividualDetailsDtoBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: IndividualDetailsDto;

    constructor(data?: IIndividualDetailsDtoBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            this.response = _data["response"] ? IndividualDetailsDto.fromJS(_data["response"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IndividualDetailsDtoBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new IndividualDetailsDtoBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIndividualDetailsDtoBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: IndividualDetailsDto;
}

export class IndividualDetailsDtoListBaseResponse implements IIndividualDetailsDtoListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: IndividualDetailsDto[] | undefined;

    constructor(data?: IIndividualDetailsDtoListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["response"])) {
                this.response = [] as any;
                for (let item of _data["response"])
                    this.response!.push(IndividualDetailsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IndividualDetailsDtoListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new IndividualDetailsDtoListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.response)) {
            data["response"] = [];
            for (let item of this.response)
                data["response"].push(item.toJSON());
        }
        return data;
    }
}

export interface IIndividualDetailsDtoListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: IndividualDetailsDto[] | undefined;
}

export class InsertFirmNoticeRequest implements IInsertFirmNoticeRequest {
    dsFirmNotice?: DataSet;
    objNotice?: WNoticeDto;

    constructor(data?: IInsertFirmNoticeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dsFirmNotice = _data["dsFirmNotice"] ? DataSet.fromJS(_data["dsFirmNotice"]) : <any>undefined;
            this.objNotice = _data["objNotice"] ? WNoticeDto.fromJS(_data["objNotice"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InsertFirmNoticeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new InsertFirmNoticeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dsFirmNotice"] = this.dsFirmNotice ? this.dsFirmNotice.toJSON() : <any>undefined;
        data["objNotice"] = this.objNotice ? this.objNotice.toJSON() : <any>undefined;
        return data;
    }
}

export interface IInsertFirmNoticeRequest {
    dsFirmNotice?: DataSet;
    objNotice?: WNoticeDto;
}

export class InsertObjectSOStatusDetailsDto implements IInsertObjectSOStatusDetailsDto {
    objectSOStatus?: ObjectSOStatusDto;
    lstReportSignatories?: ReportSignatories[] | undefined;

    constructor(data?: IInsertObjectSOStatusDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectSOStatus = _data["objectSOStatus"] ? ObjectSOStatusDto.fromJS(_data["objectSOStatus"]) : <any>undefined;
            if (Array.isArray(_data["lstReportSignatories"])) {
                this.lstReportSignatories = [] as any;
                for (let item of _data["lstReportSignatories"])
                    this.lstReportSignatories!.push(ReportSignatories.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InsertObjectSOStatusDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertObjectSOStatusDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectSOStatus"] = this.objectSOStatus ? this.objectSOStatus.toJSON() : <any>undefined;
        if (Array.isArray(this.lstReportSignatories)) {
            data["lstReportSignatories"] = [];
            for (let item of this.lstReportSignatories)
                data["lstReportSignatories"].push(item.toJSON());
        }
        return data;
    }
}

export interface IInsertObjectSOStatusDetailsDto {
    objectSOStatus?: ObjectSOStatusDto;
    lstReportSignatories?: ReportSignatories[] | undefined;
}

export class InsertReportSchDetailsDto implements IInsertReportSchDetailsDto {
    objReportSch?: ReportSchDto;
    objReportSchItem?: ReportSchItem;
    objReportSchItemAttachment?: AttachmentDto;

    constructor(data?: IInsertReportSchDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objReportSch = _data["objReportSch"] ? ReportSchDto.fromJS(_data["objReportSch"]) : <any>undefined;
            this.objReportSchItem = _data["objReportSchItem"] ? ReportSchItem.fromJS(_data["objReportSchItem"]) : <any>undefined;
            this.objReportSchItemAttachment = _data["objReportSchItemAttachment"] ? AttachmentDto.fromJS(_data["objReportSchItemAttachment"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InsertReportSchDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertReportSchDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objReportSch"] = this.objReportSch ? this.objReportSch.toJSON() : <any>undefined;
        data["objReportSchItem"] = this.objReportSchItem ? this.objReportSchItem.toJSON() : <any>undefined;
        data["objReportSchItemAttachment"] = this.objReportSchItemAttachment ? this.objReportSchItemAttachment.toJSON() : <any>undefined;
        return data;
    }
}

export interface IInsertReportSchDetailsDto {
    objReportSch?: ReportSchDto;
    objReportSchItem?: ReportSchItem;
    objReportSchItemAttachment?: AttachmentDto;
}

export class InsertUpdateNoticeDetailsFromFirmsRequest implements IInsertUpdateNoticeDetailsFromFirmsRequest {
    objNoticeData?: WNoticeDto;
    dsNoticeDetails?: DataSet;
    firmNoticeID?: number;

    constructor(data?: IInsertUpdateNoticeDetailsFromFirmsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objNoticeData = _data["objNoticeData"] ? WNoticeDto.fromJS(_data["objNoticeData"]) : <any>undefined;
            this.dsNoticeDetails = _data["dsNoticeDetails"] ? DataSet.fromJS(_data["dsNoticeDetails"]) : <any>undefined;
            this.firmNoticeID = _data["firmNoticeID"];
        }
    }

    static fromJS(data: any): InsertUpdateNoticeDetailsFromFirmsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new InsertUpdateNoticeDetailsFromFirmsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objNoticeData"] = this.objNoticeData ? this.objNoticeData.toJSON() : <any>undefined;
        data["dsNoticeDetails"] = this.dsNoticeDetails ? this.dsNoticeDetails.toJSON() : <any>undefined;
        data["firmNoticeID"] = this.firmNoticeID;
        return data;
    }
}

export interface IInsertUpdateNoticeDetailsFromFirmsRequest {
    objNoticeData?: WNoticeDto;
    dsNoticeDetails?: DataSet;
    firmNoticeID?: number;
}

export class Int32BaseResponse implements IInt32BaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: number;

    constructor(data?: IInt32BaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            this.response = _data["response"];
        }
    }

    static fromJS(data: any): Int32BaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new Int32BaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        data["response"] = this.response;
        return data;
    }
}

export interface IInt32BaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: number;
}

export class Int32ListBaseResponse implements IInt32ListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: number[] | undefined;

    constructor(data?: IInt32ListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["response"])) {
                this.response = [] as any;
                for (let item of _data["response"])
                    this.response!.push(item);
            }
        }
    }

    static fromJS(data: any): Int32ListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new Int32ListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.response)) {
            data["response"] = [];
            for (let item of this.response)
                data["response"].push(item);
        }
        return data;
    }
}

export interface IInt32ListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: number[] | undefined;
}

export class Int32StringDictionaryBaseResponse implements IInt32StringDictionaryBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: { [key: string]: string; } | undefined;

    constructor(data?: IInt32StringDictionaryBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (_data["response"]) {
                this.response = {} as any;
                for (let key in _data["response"]) {
                    if (_data["response"].hasOwnProperty(key))
                        (<any>this.response)![key] = _data["response"][key];
                }
            }
        }
    }

    static fromJS(data: any): Int32StringDictionaryBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new Int32StringDictionaryBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (this.response) {
            data["response"] = {};
            for (let key in this.response) {
                if (this.response.hasOwnProperty(key))
                    (<any>data["response"])[key] = (<any>this.response)[key];
            }
        }
        return data;
    }
}

export interface IInt32StringDictionaryBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: { [key: string]: string; } | undefined;
}

export class NumberFormatInfo implements INumberFormatInfo {
    currencyDecimalDigits?: number;
    currencyDecimalSeparator?: string | undefined;
    readonly isReadOnly?: boolean;
    currencyGroupSizes?: number[] | undefined;
    numberGroupSizes?: number[] | undefined;
    percentGroupSizes?: number[] | undefined;
    currencyGroupSeparator?: string | undefined;
    currencySymbol?: string | undefined;
    naNSymbol?: string | undefined;
    currencyNegativePattern?: number;
    numberNegativePattern?: number;
    percentPositivePattern?: number;
    percentNegativePattern?: number;
    negativeInfinitySymbol?: string | undefined;
    negativeSign?: string | undefined;
    numberDecimalDigits?: number;
    numberDecimalSeparator?: string | undefined;
    numberGroupSeparator?: string | undefined;
    currencyPositivePattern?: number;
    positiveInfinitySymbol?: string | undefined;
    positiveSign?: string | undefined;
    percentDecimalDigits?: number;
    percentDecimalSeparator?: string | undefined;
    percentGroupSeparator?: string | undefined;
    percentSymbol?: string | undefined;
    perMilleSymbol?: string | undefined;
    nativeDigits?: string[] | undefined;
    digitSubstitution?: DigitShapes;

    constructor(data?: INumberFormatInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currencyDecimalDigits = _data["currencyDecimalDigits"];
            this.currencyDecimalSeparator = _data["currencyDecimalSeparator"];
            (<any>this).isReadOnly = _data["isReadOnly"];
            if (Array.isArray(_data["currencyGroupSizes"])) {
                this.currencyGroupSizes = [] as any;
                for (let item of _data["currencyGroupSizes"])
                    this.currencyGroupSizes!.push(item);
            }
            if (Array.isArray(_data["numberGroupSizes"])) {
                this.numberGroupSizes = [] as any;
                for (let item of _data["numberGroupSizes"])
                    this.numberGroupSizes!.push(item);
            }
            if (Array.isArray(_data["percentGroupSizes"])) {
                this.percentGroupSizes = [] as any;
                for (let item of _data["percentGroupSizes"])
                    this.percentGroupSizes!.push(item);
            }
            this.currencyGroupSeparator = _data["currencyGroupSeparator"];
            this.currencySymbol = _data["currencySymbol"];
            this.naNSymbol = _data["naNSymbol"];
            this.currencyNegativePattern = _data["currencyNegativePattern"];
            this.numberNegativePattern = _data["numberNegativePattern"];
            this.percentPositivePattern = _data["percentPositivePattern"];
            this.percentNegativePattern = _data["percentNegativePattern"];
            this.negativeInfinitySymbol = _data["negativeInfinitySymbol"];
            this.negativeSign = _data["negativeSign"];
            this.numberDecimalDigits = _data["numberDecimalDigits"];
            this.numberDecimalSeparator = _data["numberDecimalSeparator"];
            this.numberGroupSeparator = _data["numberGroupSeparator"];
            this.currencyPositivePattern = _data["currencyPositivePattern"];
            this.positiveInfinitySymbol = _data["positiveInfinitySymbol"];
            this.positiveSign = _data["positiveSign"];
            this.percentDecimalDigits = _data["percentDecimalDigits"];
            this.percentDecimalSeparator = _data["percentDecimalSeparator"];
            this.percentGroupSeparator = _data["percentGroupSeparator"];
            this.percentSymbol = _data["percentSymbol"];
            this.perMilleSymbol = _data["perMilleSymbol"];
            if (Array.isArray(_data["nativeDigits"])) {
                this.nativeDigits = [] as any;
                for (let item of _data["nativeDigits"])
                    this.nativeDigits!.push(item);
            }
            this.digitSubstitution = _data["digitSubstitution"];
        }
    }

    static fromJS(data: any): NumberFormatInfo {
        data = typeof data === 'object' ? data : {};
        let result = new NumberFormatInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currencyDecimalDigits"] = this.currencyDecimalDigits;
        data["currencyDecimalSeparator"] = this.currencyDecimalSeparator;
        data["isReadOnly"] = this.isReadOnly;
        if (Array.isArray(this.currencyGroupSizes)) {
            data["currencyGroupSizes"] = [];
            for (let item of this.currencyGroupSizes)
                data["currencyGroupSizes"].push(item);
        }
        if (Array.isArray(this.numberGroupSizes)) {
            data["numberGroupSizes"] = [];
            for (let item of this.numberGroupSizes)
                data["numberGroupSizes"].push(item);
        }
        if (Array.isArray(this.percentGroupSizes)) {
            data["percentGroupSizes"] = [];
            for (let item of this.percentGroupSizes)
                data["percentGroupSizes"].push(item);
        }
        data["currencyGroupSeparator"] = this.currencyGroupSeparator;
        data["currencySymbol"] = this.currencySymbol;
        data["naNSymbol"] = this.naNSymbol;
        data["currencyNegativePattern"] = this.currencyNegativePattern;
        data["numberNegativePattern"] = this.numberNegativePattern;
        data["percentPositivePattern"] = this.percentPositivePattern;
        data["percentNegativePattern"] = this.percentNegativePattern;
        data["negativeInfinitySymbol"] = this.negativeInfinitySymbol;
        data["negativeSign"] = this.negativeSign;
        data["numberDecimalDigits"] = this.numberDecimalDigits;
        data["numberDecimalSeparator"] = this.numberDecimalSeparator;
        data["numberGroupSeparator"] = this.numberGroupSeparator;
        data["currencyPositivePattern"] = this.currencyPositivePattern;
        data["positiveInfinitySymbol"] = this.positiveInfinitySymbol;
        data["positiveSign"] = this.positiveSign;
        data["percentDecimalDigits"] = this.percentDecimalDigits;
        data["percentDecimalSeparator"] = this.percentDecimalSeparator;
        data["percentGroupSeparator"] = this.percentGroupSeparator;
        data["percentSymbol"] = this.percentSymbol;
        data["perMilleSymbol"] = this.perMilleSymbol;
        if (Array.isArray(this.nativeDigits)) {
            data["nativeDigits"] = [];
            for (let item of this.nativeDigits)
                data["nativeDigits"].push(item);
        }
        data["digitSubstitution"] = this.digitSubstitution;
        return data;
    }
}

export interface INumberFormatInfo {
    currencyDecimalDigits?: number;
    currencyDecimalSeparator?: string | undefined;
    isReadOnly?: boolean;
    currencyGroupSizes?: number[] | undefined;
    numberGroupSizes?: number[] | undefined;
    percentGroupSizes?: number[] | undefined;
    currencyGroupSeparator?: string | undefined;
    currencySymbol?: string | undefined;
    naNSymbol?: string | undefined;
    currencyNegativePattern?: number;
    numberNegativePattern?: number;
    percentPositivePattern?: number;
    percentNegativePattern?: number;
    negativeInfinitySymbol?: string | undefined;
    negativeSign?: string | undefined;
    numberDecimalDigits?: number;
    numberDecimalSeparator?: string | undefined;
    numberGroupSeparator?: string | undefined;
    currencyPositivePattern?: number;
    positiveInfinitySymbol?: string | undefined;
    positiveSign?: string | undefined;
    percentDecimalDigits?: number;
    percentDecimalSeparator?: string | undefined;
    percentGroupSeparator?: string | undefined;
    percentSymbol?: string | undefined;
    perMilleSymbol?: string | undefined;
    nativeDigits?: string[] | undefined;
    digitSubstitution?: DigitShapes;
}

export class ObjTasks implements IObjTasks {
    wObjTaskID?: number | undefined;
    wObjectID?: number | undefined;
    wObjInstanceID?: number | undefined;
    wObjTaskSyncStatusTypeID?: number | undefined;
    wObjectEventTypeID?: number | undefined;
    dateCreated?: Date | undefined;
    userCreated?: number | undefined;

    constructor(data?: IObjTasks) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wObjTaskID = _data["wObjTaskID"];
            this.wObjectID = _data["wObjectID"];
            this.wObjInstanceID = _data["wObjInstanceID"];
            this.wObjTaskSyncStatusTypeID = _data["wObjTaskSyncStatusTypeID"];
            this.wObjectEventTypeID = _data["wObjectEventTypeID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.userCreated = _data["userCreated"];
        }
    }

    static fromJS(data: any): ObjTasks {
        data = typeof data === 'object' ? data : {};
        let result = new ObjTasks();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wObjTaskID"] = this.wObjTaskID;
        data["wObjectID"] = this.wObjectID;
        data["wObjInstanceID"] = this.wObjInstanceID;
        data["wObjTaskSyncStatusTypeID"] = this.wObjTaskSyncStatusTypeID;
        data["wObjectEventTypeID"] = this.wObjectEventTypeID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["userCreated"] = this.userCreated;
        return data;
    }
}

export interface IObjTasks {
    wObjTaskID?: number | undefined;
    wObjectID?: number | undefined;
    wObjInstanceID?: number | undefined;
    wObjTaskSyncStatusTypeID?: number | undefined;
    wObjectEventTypeID?: number | undefined;
    dateCreated?: Date | undefined;
    userCreated?: number | undefined;
}

export class ObjTasksDto implements IObjTasksDto {
    wObjTaskID?: number | undefined;
    wObjectID?: number | undefined;
    wObjInstanceID?: number | undefined;
    wObjTaskSyncStatusTypeID?: number | undefined;
    wObjectEventTypeID?: number | undefined;
    dateCreated?: Date | undefined;
    userCreated?: number | undefined;

    constructor(data?: IObjTasksDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wObjTaskID = _data["wObjTaskID"];
            this.wObjectID = _data["wObjectID"];
            this.wObjInstanceID = _data["wObjInstanceID"];
            this.wObjTaskSyncStatusTypeID = _data["wObjTaskSyncStatusTypeID"];
            this.wObjectEventTypeID = _data["wObjectEventTypeID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.userCreated = _data["userCreated"];
        }
    }

    static fromJS(data: any): ObjTasksDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObjTasksDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wObjTaskID"] = this.wObjTaskID;
        data["wObjectID"] = this.wObjectID;
        data["wObjInstanceID"] = this.wObjInstanceID;
        data["wObjTaskSyncStatusTypeID"] = this.wObjTaskSyncStatusTypeID;
        data["wObjectEventTypeID"] = this.wObjectEventTypeID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["userCreated"] = this.userCreated;
        return data;
    }
}

export interface IObjTasksDto {
    wObjTaskID?: number | undefined;
    wObjectID?: number | undefined;
    wObjInstanceID?: number | undefined;
    wObjTaskSyncStatusTypeID?: number | undefined;
    wObjectEventTypeID?: number | undefined;
    dateCreated?: Date | undefined;
    userCreated?: number | undefined;
}

export class ObjectSOStatusDto implements IObjectSOStatusDto {
    objectID?: number | undefined;
    objectInstanceID?: number | undefined;
    soStatusTypeID?: number | undefined;
    userID?: number | undefined;
    soTaskValid?: boolean | undefined;

    constructor(data?: IObjectSOStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectID = _data["objectID"];
            this.objectInstanceID = _data["objectInstanceID"];
            this.soStatusTypeID = _data["soStatusTypeID"];
            this.userID = _data["userID"];
            this.soTaskValid = _data["soTaskValid"];
        }
    }

    static fromJS(data: any): ObjectSOStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectSOStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectID"] = this.objectID;
        data["objectInstanceID"] = this.objectInstanceID;
        data["soStatusTypeID"] = this.soStatusTypeID;
        data["userID"] = this.userID;
        data["soTaskValid"] = this.soTaskValid;
        return data;
    }
}

export interface IObjectSOStatusDto {
    objectID?: number | undefined;
    objectInstanceID?: number | undefined;
    soStatusTypeID?: number | undefined;
    userID?: number | undefined;
    soTaskValid?: boolean | undefined;
}

export class ObjectSOTaskStatus implements IObjectSOTaskStatus {
    objectID?: number;
    objectInstanceID?: number;
    soStatusTypeDesc?: string | undefined;
    soInitiationDate?: string | undefined;
    soCompletionDate?: string | undefined;
    docTypeID?: number;
    rptFreqTypeDesc?: string | undefined;
    attachmentID?: number;
    objectSOTaskStatusID?: number;
    objectSOStatusID?: number;
    soTaskAssignedTo?: number;
    soTaskAssignedDate?: string | undefined;
    soTaskSeqNo?: number;
    groupSignOff?: boolean;
    soStatusTypeID?: number;
    soTaskCompletionDate?: string | undefined;
    userID?: number;
    individualName?: string | undefined;
    emailAdd?: string | undefined;
    isLoggedInUser?: boolean;
    roles?: string | undefined;
    individualJobTitle?: string | undefined;
    userActive?: boolean | undefined;
    wTermID?: number | undefined;
    agreedOnTerms?: boolean | undefined;
    termsAgreedDate?: string | undefined;
    soTaskValid?: boolean | undefined;

    constructor(data?: IObjectSOTaskStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectID = _data["objectID"];
            this.objectInstanceID = _data["objectInstanceID"];
            this.soStatusTypeDesc = _data["soStatusTypeDesc"];
            this.soInitiationDate = _data["soInitiationDate"];
            this.soCompletionDate = _data["soCompletionDate"];
            this.docTypeID = _data["docTypeID"];
            this.rptFreqTypeDesc = _data["rptFreqTypeDesc"];
            this.attachmentID = _data["attachmentID"];
            this.objectSOTaskStatusID = _data["objectSOTaskStatusID"];
            this.objectSOStatusID = _data["objectSOStatusID"];
            this.soTaskAssignedTo = _data["soTaskAssignedTo"];
            this.soTaskAssignedDate = _data["soTaskAssignedDate"];
            this.soTaskSeqNo = _data["soTaskSeqNo"];
            this.groupSignOff = _data["groupSignOff"];
            this.soStatusTypeID = _data["soStatusTypeID"];
            this.soTaskCompletionDate = _data["soTaskCompletionDate"];
            this.userID = _data["userID"];
            this.individualName = _data["individualName"];
            this.emailAdd = _data["emailAdd"];
            this.isLoggedInUser = _data["isLoggedInUser"];
            this.roles = _data["roles"];
            this.individualJobTitle = _data["individualJobTitle"];
            this.userActive = _data["userActive"];
            this.wTermID = _data["wTermID"];
            this.agreedOnTerms = _data["agreedOnTerms"];
            this.termsAgreedDate = _data["termsAgreedDate"];
            this.soTaskValid = _data["soTaskValid"];
        }
    }

    static fromJS(data: any): ObjectSOTaskStatus {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectSOTaskStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectID"] = this.objectID;
        data["objectInstanceID"] = this.objectInstanceID;
        data["soStatusTypeDesc"] = this.soStatusTypeDesc;
        data["soInitiationDate"] = this.soInitiationDate;
        data["soCompletionDate"] = this.soCompletionDate;
        data["docTypeID"] = this.docTypeID;
        data["rptFreqTypeDesc"] = this.rptFreqTypeDesc;
        data["attachmentID"] = this.attachmentID;
        data["objectSOTaskStatusID"] = this.objectSOTaskStatusID;
        data["objectSOStatusID"] = this.objectSOStatusID;
        data["soTaskAssignedTo"] = this.soTaskAssignedTo;
        data["soTaskAssignedDate"] = this.soTaskAssignedDate;
        data["soTaskSeqNo"] = this.soTaskSeqNo;
        data["groupSignOff"] = this.groupSignOff;
        data["soStatusTypeID"] = this.soStatusTypeID;
        data["soTaskCompletionDate"] = this.soTaskCompletionDate;
        data["userID"] = this.userID;
        data["individualName"] = this.individualName;
        data["emailAdd"] = this.emailAdd;
        data["isLoggedInUser"] = this.isLoggedInUser;
        data["roles"] = this.roles;
        data["individualJobTitle"] = this.individualJobTitle;
        data["userActive"] = this.userActive;
        data["wTermID"] = this.wTermID;
        data["agreedOnTerms"] = this.agreedOnTerms;
        data["termsAgreedDate"] = this.termsAgreedDate;
        data["soTaskValid"] = this.soTaskValid;
        return data;
    }
}

export interface IObjectSOTaskStatus {
    objectID?: number;
    objectInstanceID?: number;
    soStatusTypeDesc?: string | undefined;
    soInitiationDate?: string | undefined;
    soCompletionDate?: string | undefined;
    docTypeID?: number;
    rptFreqTypeDesc?: string | undefined;
    attachmentID?: number;
    objectSOTaskStatusID?: number;
    objectSOStatusID?: number;
    soTaskAssignedTo?: number;
    soTaskAssignedDate?: string | undefined;
    soTaskSeqNo?: number;
    groupSignOff?: boolean;
    soStatusTypeID?: number;
    soTaskCompletionDate?: string | undefined;
    userID?: number;
    individualName?: string | undefined;
    emailAdd?: string | undefined;
    isLoggedInUser?: boolean;
    roles?: string | undefined;
    individualJobTitle?: string | undefined;
    userActive?: boolean | undefined;
    wTermID?: number | undefined;
    agreedOnTerms?: boolean | undefined;
    termsAgreedDate?: string | undefined;
    soTaskValid?: boolean | undefined;
}

export class ObjectSOTaskStatusDto implements IObjectSOTaskStatusDto {
    objectSOStatusID?: number | undefined;
    soTaskAssignedTo?: number | undefined;
    soTaskSeqNo?: number | undefined;
    userID?: number | undefined;
    soTaskAssignedDate?: string | undefined;
    groupSignOff?: boolean | undefined;
    soTaskValid?: boolean | undefined;
    objectSOTaskStatusID?: number;
    soTaskCompletionDate?: string | undefined;
    individualName?: string | undefined;
    emailAdd?: string | undefined;
    soStatusTypeID?: number;
    individualJobTitle?: string | undefined;
    objectID?: any | undefined;
    objectInstanceID?: any | undefined;

    constructor(data?: IObjectSOTaskStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectSOStatusID = _data["objectSOStatusID"];
            this.soTaskAssignedTo = _data["soTaskAssignedTo"];
            this.soTaskSeqNo = _data["soTaskSeqNo"];
            this.userID = _data["userID"];
            this.soTaskAssignedDate = _data["soTaskAssignedDate"];
            this.groupSignOff = _data["groupSignOff"];
            this.soTaskValid = _data["soTaskValid"];
            this.objectSOTaskStatusID = _data["objectSOTaskStatusID"];
            this.soTaskCompletionDate = _data["soTaskCompletionDate"];
            this.individualName = _data["individualName"];
            this.emailAdd = _data["emailAdd"];
            this.soStatusTypeID = _data["soStatusTypeID"];
            this.individualJobTitle = _data["individualJobTitle"];
            this.objectID = _data["objectID"];
            this.objectInstanceID = _data["objectInstanceID"];
        }
    }

    static fromJS(data: any): ObjectSOTaskStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectSOTaskStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectSOStatusID"] = this.objectSOStatusID;
        data["soTaskAssignedTo"] = this.soTaskAssignedTo;
        data["soTaskSeqNo"] = this.soTaskSeqNo;
        data["userID"] = this.userID;
        data["soTaskAssignedDate"] = this.soTaskAssignedDate;
        data["groupSignOff"] = this.groupSignOff;
        data["soTaskValid"] = this.soTaskValid;
        data["objectSOTaskStatusID"] = this.objectSOTaskStatusID;
        data["soTaskCompletionDate"] = this.soTaskCompletionDate;
        data["individualName"] = this.individualName;
        data["emailAdd"] = this.emailAdd;
        data["soStatusTypeID"] = this.soStatusTypeID;
        data["individualJobTitle"] = this.individualJobTitle;
        data["objectID"] = this.objectID;
        data["objectInstanceID"] = this.objectInstanceID;
        return data;
    }
}

export interface IObjectSOTaskStatusDto {
    objectSOStatusID?: number | undefined;
    soTaskAssignedTo?: number | undefined;
    soTaskSeqNo?: number | undefined;
    userID?: number | undefined;
    soTaskAssignedDate?: string | undefined;
    groupSignOff?: boolean | undefined;
    soTaskValid?: boolean | undefined;
    objectSOTaskStatusID?: number;
    soTaskCompletionDate?: string | undefined;
    individualName?: string | undefined;
    emailAdd?: string | undefined;
    soStatusTypeID?: number;
    individualJobTitle?: string | undefined;
    objectID?: any | undefined;
    objectInstanceID?: any | undefined;
}

export class ObjectSOTaskStatusListBaseResponse implements IObjectSOTaskStatusListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: ObjectSOTaskStatus[] | undefined;

    constructor(data?: IObjectSOTaskStatusListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["response"])) {
                this.response = [] as any;
                for (let item of _data["response"])
                    this.response!.push(ObjectSOTaskStatus.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ObjectSOTaskStatusListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectSOTaskStatusListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.response)) {
            data["response"] = [];
            for (let item of this.response)
                data["response"].push(item.toJSON());
        }
        return data;
    }
}

export interface IObjectSOTaskStatusListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: ObjectSOTaskStatus[] | undefined;
}

export class ObjectSoTaskStatusDto implements IObjectSoTaskStatusDto {
    individualName?: string | undefined;
    emailAdd?: string | undefined;
    soTaskSeqNo?: number | undefined;
    soTaskCompletionDate?: string | undefined;

    constructor(data?: IObjectSoTaskStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.individualName = _data["individualName"];
            this.emailAdd = _data["emailAdd"];
            this.soTaskSeqNo = _data["soTaskSeqNo"];
            this.soTaskCompletionDate = _data["soTaskCompletionDate"];
        }
    }

    static fromJS(data: any): ObjectSoTaskStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectSoTaskStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["individualName"] = this.individualName;
        data["emailAdd"] = this.emailAdd;
        data["soTaskSeqNo"] = this.soTaskSeqNo;
        data["soTaskCompletionDate"] = this.soTaskCompletionDate;
        return data;
    }
}

export interface IObjectSoTaskStatusDto {
    individualName?: string | undefined;
    emailAdd?: string | undefined;
    soTaskSeqNo?: number | undefined;
    soTaskCompletionDate?: string | undefined;
}

export class ObjectSoTaskStatusDtoListBaseResponse implements IObjectSoTaskStatusDtoListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: ObjectSoTaskStatusDto[] | undefined;

    constructor(data?: IObjectSoTaskStatusDtoListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["response"])) {
                this.response = [] as any;
                for (let item of _data["response"])
                    this.response!.push(ObjectSoTaskStatusDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ObjectSoTaskStatusDtoListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectSoTaskStatusDtoListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.response)) {
            data["response"] = [];
            for (let item of this.response)
                data["response"].push(item.toJSON());
        }
        return data;
    }
}

export interface IObjectSoTaskStatusDtoListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: ObjectSoTaskStatusDto[] | undefined;
}

export class ObjectTextDto implements IObjectTextDto {
    wObjectTextID?: number | undefined;
    wObjectID?: number | undefined;
    wObjectPageID?: number | undefined;
    wPageSectionID?: number | undefined;
    wHelpControlID?: string | undefined;
    wObjectTextDesc?: string | undefined;
    wPageSectionDesc?: string | undefined;

    constructor(data?: IObjectTextDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wObjectTextID = _data["wObjectTextID"];
            this.wObjectID = _data["wObjectID"];
            this.wObjectPageID = _data["wObjectPageID"];
            this.wPageSectionID = _data["wPageSectionID"];
            this.wHelpControlID = _data["wHelpControlID"];
            this.wObjectTextDesc = _data["wObjectTextDesc"];
            this.wPageSectionDesc = _data["wPageSectionDesc"];
        }
    }

    static fromJS(data: any): ObjectTextDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectTextDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wObjectTextID"] = this.wObjectTextID;
        data["wObjectID"] = this.wObjectID;
        data["wObjectPageID"] = this.wObjectPageID;
        data["wPageSectionID"] = this.wPageSectionID;
        data["wHelpControlID"] = this.wHelpControlID;
        data["wObjectTextDesc"] = this.wObjectTextDesc;
        data["wPageSectionDesc"] = this.wPageSectionDesc;
        return data;
    }
}

export interface IObjectTextDto {
    wObjectTextID?: number | undefined;
    wObjectID?: number | undefined;
    wObjectPageID?: number | undefined;
    wPageSectionID?: number | undefined;
    wHelpControlID?: string | undefined;
    wObjectTextDesc?: string | undefined;
    wPageSectionDesc?: string | undefined;
}

export class ObjectTextDtoBaseResponse implements IObjectTextDtoBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: ObjectTextDto;

    constructor(data?: IObjectTextDtoBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            this.response = _data["response"] ? ObjectTextDto.fromJS(_data["response"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ObjectTextDtoBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectTextDtoBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        return data;
    }
}

export interface IObjectTextDtoBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: ObjectTextDto;
}

export class ObjectTextDtoListBaseResponse implements IObjectTextDtoListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: ObjectTextDto[] | undefined;

    constructor(data?: IObjectTextDtoListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["response"])) {
                this.response = [] as any;
                for (let item of _data["response"])
                    this.response!.push(ObjectTextDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ObjectTextDtoListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectTextDtoListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.response)) {
            data["response"] = [];
            for (let item of this.response)
                data["response"].push(item.toJSON());
        }
        return data;
    }
}

export interface IObjectTextDtoListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: ObjectTextDto[] | undefined;
}

export class PendingItemsDto implements IPendingItemsDto {
    applicationID?: number | undefined;
    qfcNmuner?: string | undefined;
    formTypeID?: number | undefined;
    statusTypeID?: number | undefined;
    formType?: string | undefined;
    individualName?: string | undefined;
    applicationStatus?: string | undefined;
    applicationContactDetailID?: number;
    createdDate?: string | undefined;
    wObjectSOStatusID?: number | undefined;
    description?: string | undefined;
    submittedDate?: string | undefined;
    isItemAccessible?: boolean;
    userCreated?: number;
    applicantSignOffDone?: boolean;
    attachmentResubmissionRequired?: boolean;
    resubmissionComments?: string | undefined;
    docTypeID?: number | undefined;
    objectID?: number | undefined;
    docTypeDesc?: string | undefined;
    lstAttachments?: AttachmentDto[] | undefined;

    constructor(data?: IPendingItemsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationID = _data["applicationID"];
            this.qfcNmuner = _data["qfcNmuner"];
            this.formTypeID = _data["formTypeID"];
            this.statusTypeID = _data["statusTypeID"];
            this.formType = _data["formType"];
            this.individualName = _data["individualName"];
            this.applicationStatus = _data["applicationStatus"];
            this.applicationContactDetailID = _data["applicationContactDetailID"];
            this.createdDate = _data["createdDate"];
            this.wObjectSOStatusID = _data["wObjectSOStatusID"];
            this.description = _data["description"];
            this.submittedDate = _data["submittedDate"];
            this.isItemAccessible = _data["isItemAccessible"];
            this.userCreated = _data["userCreated"];
            this.applicantSignOffDone = _data["applicantSignOffDone"];
            this.attachmentResubmissionRequired = _data["attachmentResubmissionRequired"];
            this.resubmissionComments = _data["resubmissionComments"];
            this.docTypeID = _data["docTypeID"];
            this.objectID = _data["objectID"];
            this.docTypeDesc = _data["docTypeDesc"];
            if (Array.isArray(_data["lstAttachments"])) {
                this.lstAttachments = [] as any;
                for (let item of _data["lstAttachments"])
                    this.lstAttachments!.push(AttachmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PendingItemsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PendingItemsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicationID"] = this.applicationID;
        data["qfcNmuner"] = this.qfcNmuner;
        data["formTypeID"] = this.formTypeID;
        data["statusTypeID"] = this.statusTypeID;
        data["formType"] = this.formType;
        data["individualName"] = this.individualName;
        data["applicationStatus"] = this.applicationStatus;
        data["applicationContactDetailID"] = this.applicationContactDetailID;
        data["createdDate"] = this.createdDate;
        data["wObjectSOStatusID"] = this.wObjectSOStatusID;
        data["description"] = this.description;
        data["submittedDate"] = this.submittedDate;
        data["isItemAccessible"] = this.isItemAccessible;
        data["userCreated"] = this.userCreated;
        data["applicantSignOffDone"] = this.applicantSignOffDone;
        data["attachmentResubmissionRequired"] = this.attachmentResubmissionRequired;
        data["resubmissionComments"] = this.resubmissionComments;
        data["docTypeID"] = this.docTypeID;
        data["objectID"] = this.objectID;
        data["docTypeDesc"] = this.docTypeDesc;
        if (Array.isArray(this.lstAttachments)) {
            data["lstAttachments"] = [];
            for (let item of this.lstAttachments)
                data["lstAttachments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPendingItemsDto {
    applicationID?: number | undefined;
    qfcNmuner?: string | undefined;
    formTypeID?: number | undefined;
    statusTypeID?: number | undefined;
    formType?: string | undefined;
    individualName?: string | undefined;
    applicationStatus?: string | undefined;
    applicationContactDetailID?: number;
    createdDate?: string | undefined;
    wObjectSOStatusID?: number | undefined;
    description?: string | undefined;
    submittedDate?: string | undefined;
    isItemAccessible?: boolean;
    userCreated?: number;
    applicantSignOffDone?: boolean;
    attachmentResubmissionRequired?: boolean;
    resubmissionComments?: string | undefined;
    docTypeID?: number | undefined;
    objectID?: number | undefined;
    docTypeDesc?: string | undefined;
    lstAttachments?: AttachmentDto[] | undefined;
}

export class PendingItemsDtoListBaseResponse implements IPendingItemsDtoListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: PendingItemsDto[] | undefined;

    constructor(data?: IPendingItemsDtoListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["response"])) {
                this.response = [] as any;
                for (let item of _data["response"])
                    this.response!.push(PendingItemsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PendingItemsDtoListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PendingItemsDtoListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.response)) {
            data["response"] = [];
            for (let item of this.response)
                data["response"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPendingItemsDtoListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: PendingItemsDto[] | undefined;
}

export class PreviousNames implements IPreviousNames {
    previousNamesID?: number | undefined;
    previousNamesGUID?: string | undefined;
    previousName?: string | undefined;
    previousNameReason?: string | undefined;
    userID?: number;
    fromDay?: string | undefined;
    fromMonth?: string | undefined;
    fromYear?: string | undefined;
    createdDate?: string | undefined;
    modifiedDate?: string | undefined;
    modifiedBy?: number;
    applicationID?: number;
    previousNameDate?: string | undefined;

    constructor(data?: IPreviousNames) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.previousNamesID = _data["previousNamesID"];
            this.previousNamesGUID = _data["previousNamesGUID"];
            this.previousName = _data["previousName"];
            this.previousNameReason = _data["previousNameReason"];
            this.userID = _data["userID"];
            this.fromDay = _data["fromDay"];
            this.fromMonth = _data["fromMonth"];
            this.fromYear = _data["fromYear"];
            this.createdDate = _data["createdDate"];
            this.modifiedDate = _data["modifiedDate"];
            this.modifiedBy = _data["modifiedBy"];
            this.applicationID = _data["applicationID"];
            this.previousNameDate = _data["previousNameDate"];
        }
    }

    static fromJS(data: any): PreviousNames {
        data = typeof data === 'object' ? data : {};
        let result = new PreviousNames();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["previousNamesID"] = this.previousNamesID;
        data["previousNamesGUID"] = this.previousNamesGUID;
        data["previousName"] = this.previousName;
        data["previousNameReason"] = this.previousNameReason;
        data["userID"] = this.userID;
        data["fromDay"] = this.fromDay;
        data["fromMonth"] = this.fromMonth;
        data["fromYear"] = this.fromYear;
        data["createdDate"] = this.createdDate;
        data["modifiedDate"] = this.modifiedDate;
        data["modifiedBy"] = this.modifiedBy;
        data["applicationID"] = this.applicationID;
        data["previousNameDate"] = this.previousNameDate;
        return data;
    }
}

export interface IPreviousNames {
    previousNamesID?: number | undefined;
    previousNamesGUID?: string | undefined;
    previousName?: string | undefined;
    previousNameReason?: string | undefined;
    userID?: number;
    fromDay?: string | undefined;
    fromMonth?: string | undefined;
    fromYear?: string | undefined;
    createdDate?: string | undefined;
    modifiedDate?: string | undefined;
    modifiedBy?: number;
    applicationID?: number;
    previousNameDate?: string | undefined;
}

export class ProcessNoticeEmailDetailsRequest implements IProcessNoticeEmailDetailsRequest {
    dsNoticeEmail?: DataSet;
    objNotice?: WNoticeDto;

    constructor(data?: IProcessNoticeEmailDetailsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dsNoticeEmail = _data["dsNoticeEmail"] ? DataSet.fromJS(_data["dsNoticeEmail"]) : <any>undefined;
            this.objNotice = _data["objNotice"] ? WNoticeDto.fromJS(_data["objNotice"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProcessNoticeEmailDetailsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessNoticeEmailDetailsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dsNoticeEmail"] = this.dsNoticeEmail ? this.dsNoticeEmail.toJSON() : <any>undefined;
        data["objNotice"] = this.objNotice ? this.objNotice.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProcessNoticeEmailDetailsRequest {
    dsNoticeEmail?: DataSet;
    objNotice?: WNoticeDto;
}

export class ReportEvaluations implements IReportEvaluations {
    sheetDesc?: string | undefined;
    excelLocationCellRange?: string | undefined;
    elementRowLabel?: string | undefined;
    excelCellNameForElementRowLabel?: string | undefined;
    excelCellNameForReportedValue?: string | undefined;
    isValueMandatory?: boolean;
    isMetadataTable?: boolean;

    constructor(data?: IReportEvaluations) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sheetDesc = _data["sheetDesc"];
            this.excelLocationCellRange = _data["excelLocationCellRange"];
            this.elementRowLabel = _data["elementRowLabel"];
            this.excelCellNameForElementRowLabel = _data["excelCellNameForElementRowLabel"];
            this.excelCellNameForReportedValue = _data["excelCellNameForReportedValue"];
            this.isValueMandatory = _data["isValueMandatory"];
            this.isMetadataTable = _data["isMetadataTable"];
        }
    }

    static fromJS(data: any): ReportEvaluations {
        data = typeof data === 'object' ? data : {};
        let result = new ReportEvaluations();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sheetDesc"] = this.sheetDesc;
        data["excelLocationCellRange"] = this.excelLocationCellRange;
        data["elementRowLabel"] = this.elementRowLabel;
        data["excelCellNameForElementRowLabel"] = this.excelCellNameForElementRowLabel;
        data["excelCellNameForReportedValue"] = this.excelCellNameForReportedValue;
        data["isValueMandatory"] = this.isValueMandatory;
        data["isMetadataTable"] = this.isMetadataTable;
        return data;
    }
}

export interface IReportEvaluations {
    sheetDesc?: string | undefined;
    excelLocationCellRange?: string | undefined;
    elementRowLabel?: string | undefined;
    excelCellNameForElementRowLabel?: string | undefined;
    excelCellNameForReportedValue?: string | undefined;
    isValueMandatory?: boolean;
    isMetadataTable?: boolean;
}

export class ReportEvaluationsListBaseResponse implements IReportEvaluationsListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: ReportEvaluations[] | undefined;

    constructor(data?: IReportEvaluationsListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["response"])) {
                this.response = [] as any;
                for (let item of _data["response"])
                    this.response!.push(ReportEvaluations.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReportEvaluationsListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ReportEvaluationsListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.response)) {
            data["response"] = [];
            for (let item of this.response)
                data["response"].push(item.toJSON());
        }
        return data;
    }
}

export interface IReportEvaluationsListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: ReportEvaluations[] | undefined;
}

export class ReportSchDetails implements IReportSchDetails {
    firmsRptSchID?: number;
    firmsRptSchItemID?: number;
    rptSchID?: number;
    qfcNum?: string | undefined;
    rptSchFinYearFromDate?: string | undefined;
    rptSchFinYearToDate?: string | undefined;
    rptSchFinYearPeriod?: string | undefined;
    rptSchItemID?: number;
    docTypeID?: number;
    rptName?: string | undefined;
    rptDueDate?: string | undefined;
    rptPeriodFromDate?: string | undefined;
    rptPeriodToDate?: string | undefined;
    rptPeriodTypeDesc?: string | undefined;
    rptFreqTypeDesc?: string | undefined;
    reviewComments?: string | undefined;
    manuallyReceived?: boolean;
    allowReSubmit?: boolean;
    rptSchItemAttachmentID?: number;
    fileName?: string | undefined;
    attachmentFilePath?: string | undefined;
    attachmentFileURI?: string | undefined;
    rptSOMethodTypeID?: number;
    rptSOMethodTypeDesc?: string | undefined;
    fileUploadedByName?: string | undefined;
    fileUploadedByEmailAdd?: string | undefined;
    fileUploadedOnDate?: string | undefined;
    validAttachment?: boolean;
    submittedOn?: string | undefined;
    fileStream?: string | undefined;
    objectSOStatusID?: number;
    objectID?: number;
    objectInstanceID?: number;
    soStatusTypeID?: number;
    soStatusTypeDesc?: string | undefined;
    soInitiationDate?: string | undefined;
    soCompletionDate?: string | undefined;
    userID?: number;
    description?: string | undefined;
    isItemAccessible?: boolean;
    submittedBy?: number;
    isFileRecieved?: boolean;
    lateFeeFlag?: boolean;
    daysOverDue?: number;
    isReportDue?: boolean;
    rptSchAttachmentStatusDesc?: string | undefined;
    rptSubmissionTypeID?: number;
    rptSubmissionType?: string | undefined;
    rptFormsToBeSubmited?: string | undefined;
    rptNextStatus?: string | undefined;
    attachmentStatusTypeID?: number;
    fileAttachedUserEmail?: string | undefined;
    rptAttachmentStatusDate?: string | undefined;
    isReportReminderDue?: boolean;
    rptSchAttachmentStatusId?: number | undefined;
    isResubmissionRequested?: boolean;
    isResubmissionNotificationRequired?: number;
    resubmissionRequestedDate?: string | undefined;
    docReceivedDate?: string | undefined;
    submissionBeforeRptPeriodEnd?: boolean;
    resubmissionDueDate?: string | undefined;
    isAMLDocType?: boolean;

    constructor(data?: IReportSchDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmsRptSchID = _data["firmsRptSchID"];
            this.firmsRptSchItemID = _data["firmsRptSchItemID"];
            this.rptSchID = _data["rptSchID"];
            this.qfcNum = _data["qfcNum"];
            this.rptSchFinYearFromDate = _data["rptSchFinYearFromDate"];
            this.rptSchFinYearToDate = _data["rptSchFinYearToDate"];
            this.rptSchFinYearPeriod = _data["rptSchFinYearPeriod"];
            this.rptSchItemID = _data["rptSchItemID"];
            this.docTypeID = _data["docTypeID"];
            this.rptName = _data["rptName"];
            this.rptDueDate = _data["rptDueDate"];
            this.rptPeriodFromDate = _data["rptPeriodFromDate"];
            this.rptPeriodToDate = _data["rptPeriodToDate"];
            this.rptPeriodTypeDesc = _data["rptPeriodTypeDesc"];
            this.rptFreqTypeDesc = _data["rptFreqTypeDesc"];
            this.reviewComments = _data["reviewComments"];
            this.manuallyReceived = _data["manuallyReceived"];
            this.allowReSubmit = _data["allowReSubmit"];
            this.rptSchItemAttachmentID = _data["rptSchItemAttachmentID"];
            this.fileName = _data["fileName"];
            this.attachmentFilePath = _data["attachmentFilePath"];
            this.attachmentFileURI = _data["attachmentFileURI"];
            this.rptSOMethodTypeID = _data["rptSOMethodTypeID"];
            this.rptSOMethodTypeDesc = _data["rptSOMethodTypeDesc"];
            this.fileUploadedByName = _data["fileUploadedByName"];
            this.fileUploadedByEmailAdd = _data["fileUploadedByEmailAdd"];
            this.fileUploadedOnDate = _data["fileUploadedOnDate"];
            this.validAttachment = _data["validAttachment"];
            this.submittedOn = _data["submittedOn"];
            this.fileStream = _data["fileStream"];
            this.objectSOStatusID = _data["objectSOStatusID"];
            this.objectID = _data["objectID"];
            this.objectInstanceID = _data["objectInstanceID"];
            this.soStatusTypeID = _data["soStatusTypeID"];
            this.soStatusTypeDesc = _data["soStatusTypeDesc"];
            this.soInitiationDate = _data["soInitiationDate"];
            this.soCompletionDate = _data["soCompletionDate"];
            this.userID = _data["userID"];
            this.description = _data["description"];
            this.isItemAccessible = _data["isItemAccessible"];
            this.submittedBy = _data["submittedBy"];
            this.isFileRecieved = _data["isFileRecieved"];
            this.lateFeeFlag = _data["lateFeeFlag"];
            this.daysOverDue = _data["daysOverDue"];
            this.isReportDue = _data["isReportDue"];
            this.rptSchAttachmentStatusDesc = _data["rptSchAttachmentStatusDesc"];
            this.rptSubmissionTypeID = _data["rptSubmissionTypeID"];
            this.rptSubmissionType = _data["rptSubmissionType"];
            this.rptFormsToBeSubmited = _data["rptFormsToBeSubmited"];
            this.rptNextStatus = _data["rptNextStatus"];
            this.attachmentStatusTypeID = _data["attachmentStatusTypeID"];
            this.fileAttachedUserEmail = _data["fileAttachedUserEmail"];
            this.rptAttachmentStatusDate = _data["rptAttachmentStatusDate"];
            this.isReportReminderDue = _data["isReportReminderDue"];
            this.rptSchAttachmentStatusId = _data["rptSchAttachmentStatusId"];
            this.isResubmissionRequested = _data["isResubmissionRequested"];
            this.isResubmissionNotificationRequired = _data["isResubmissionNotificationRequired"];
            this.resubmissionRequestedDate = _data["resubmissionRequestedDate"];
            this.docReceivedDate = _data["docReceivedDate"];
            this.submissionBeforeRptPeriodEnd = _data["submissionBeforeRptPeriodEnd"];
            this.resubmissionDueDate = _data["resubmissionDueDate"];
            this.isAMLDocType = _data["isAMLDocType"];
        }
    }

    static fromJS(data: any): ReportSchDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ReportSchDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmsRptSchID"] = this.firmsRptSchID;
        data["firmsRptSchItemID"] = this.firmsRptSchItemID;
        data["rptSchID"] = this.rptSchID;
        data["qfcNum"] = this.qfcNum;
        data["rptSchFinYearFromDate"] = this.rptSchFinYearFromDate;
        data["rptSchFinYearToDate"] = this.rptSchFinYearToDate;
        data["rptSchFinYearPeriod"] = this.rptSchFinYearPeriod;
        data["rptSchItemID"] = this.rptSchItemID;
        data["docTypeID"] = this.docTypeID;
        data["rptName"] = this.rptName;
        data["rptDueDate"] = this.rptDueDate;
        data["rptPeriodFromDate"] = this.rptPeriodFromDate;
        data["rptPeriodToDate"] = this.rptPeriodToDate;
        data["rptPeriodTypeDesc"] = this.rptPeriodTypeDesc;
        data["rptFreqTypeDesc"] = this.rptFreqTypeDesc;
        data["reviewComments"] = this.reviewComments;
        data["manuallyReceived"] = this.manuallyReceived;
        data["allowReSubmit"] = this.allowReSubmit;
        data["rptSchItemAttachmentID"] = this.rptSchItemAttachmentID;
        data["fileName"] = this.fileName;
        data["attachmentFilePath"] = this.attachmentFilePath;
        data["attachmentFileURI"] = this.attachmentFileURI;
        data["rptSOMethodTypeID"] = this.rptSOMethodTypeID;
        data["rptSOMethodTypeDesc"] = this.rptSOMethodTypeDesc;
        data["fileUploadedByName"] = this.fileUploadedByName;
        data["fileUploadedByEmailAdd"] = this.fileUploadedByEmailAdd;
        data["fileUploadedOnDate"] = this.fileUploadedOnDate;
        data["validAttachment"] = this.validAttachment;
        data["submittedOn"] = this.submittedOn;
        data["fileStream"] = this.fileStream;
        data["objectSOStatusID"] = this.objectSOStatusID;
        data["objectID"] = this.objectID;
        data["objectInstanceID"] = this.objectInstanceID;
        data["soStatusTypeID"] = this.soStatusTypeID;
        data["soStatusTypeDesc"] = this.soStatusTypeDesc;
        data["soInitiationDate"] = this.soInitiationDate;
        data["soCompletionDate"] = this.soCompletionDate;
        data["userID"] = this.userID;
        data["description"] = this.description;
        data["isItemAccessible"] = this.isItemAccessible;
        data["submittedBy"] = this.submittedBy;
        data["isFileRecieved"] = this.isFileRecieved;
        data["lateFeeFlag"] = this.lateFeeFlag;
        data["daysOverDue"] = this.daysOverDue;
        data["isReportDue"] = this.isReportDue;
        data["rptSchAttachmentStatusDesc"] = this.rptSchAttachmentStatusDesc;
        data["rptSubmissionTypeID"] = this.rptSubmissionTypeID;
        data["rptSubmissionType"] = this.rptSubmissionType;
        data["rptFormsToBeSubmited"] = this.rptFormsToBeSubmited;
        data["rptNextStatus"] = this.rptNextStatus;
        data["attachmentStatusTypeID"] = this.attachmentStatusTypeID;
        data["fileAttachedUserEmail"] = this.fileAttachedUserEmail;
        data["rptAttachmentStatusDate"] = this.rptAttachmentStatusDate;
        data["isReportReminderDue"] = this.isReportReminderDue;
        data["rptSchAttachmentStatusId"] = this.rptSchAttachmentStatusId;
        data["isResubmissionRequested"] = this.isResubmissionRequested;
        data["isResubmissionNotificationRequired"] = this.isResubmissionNotificationRequired;
        data["resubmissionRequestedDate"] = this.resubmissionRequestedDate;
        data["docReceivedDate"] = this.docReceivedDate;
        data["submissionBeforeRptPeriodEnd"] = this.submissionBeforeRptPeriodEnd;
        data["resubmissionDueDate"] = this.resubmissionDueDate;
        data["isAMLDocType"] = this.isAMLDocType;
        return data;
    }
}

export interface IReportSchDetails {
    firmsRptSchID?: number;
    firmsRptSchItemID?: number;
    rptSchID?: number;
    qfcNum?: string | undefined;
    rptSchFinYearFromDate?: string | undefined;
    rptSchFinYearToDate?: string | undefined;
    rptSchFinYearPeriod?: string | undefined;
    rptSchItemID?: number;
    docTypeID?: number;
    rptName?: string | undefined;
    rptDueDate?: string | undefined;
    rptPeriodFromDate?: string | undefined;
    rptPeriodToDate?: string | undefined;
    rptPeriodTypeDesc?: string | undefined;
    rptFreqTypeDesc?: string | undefined;
    reviewComments?: string | undefined;
    manuallyReceived?: boolean;
    allowReSubmit?: boolean;
    rptSchItemAttachmentID?: number;
    fileName?: string | undefined;
    attachmentFilePath?: string | undefined;
    attachmentFileURI?: string | undefined;
    rptSOMethodTypeID?: number;
    rptSOMethodTypeDesc?: string | undefined;
    fileUploadedByName?: string | undefined;
    fileUploadedByEmailAdd?: string | undefined;
    fileUploadedOnDate?: string | undefined;
    validAttachment?: boolean;
    submittedOn?: string | undefined;
    fileStream?: string | undefined;
    objectSOStatusID?: number;
    objectID?: number;
    objectInstanceID?: number;
    soStatusTypeID?: number;
    soStatusTypeDesc?: string | undefined;
    soInitiationDate?: string | undefined;
    soCompletionDate?: string | undefined;
    userID?: number;
    description?: string | undefined;
    isItemAccessible?: boolean;
    submittedBy?: number;
    isFileRecieved?: boolean;
    lateFeeFlag?: boolean;
    daysOverDue?: number;
    isReportDue?: boolean;
    rptSchAttachmentStatusDesc?: string | undefined;
    rptSubmissionTypeID?: number;
    rptSubmissionType?: string | undefined;
    rptFormsToBeSubmited?: string | undefined;
    rptNextStatus?: string | undefined;
    attachmentStatusTypeID?: number;
    fileAttachedUserEmail?: string | undefined;
    rptAttachmentStatusDate?: string | undefined;
    isReportReminderDue?: boolean;
    rptSchAttachmentStatusId?: number | undefined;
    isResubmissionRequested?: boolean;
    isResubmissionNotificationRequired?: number;
    resubmissionRequestedDate?: string | undefined;
    docReceivedDate?: string | undefined;
    submissionBeforeRptPeriodEnd?: boolean;
    resubmissionDueDate?: string | undefined;
    isAMLDocType?: boolean;
}

export class ReportSchDetailsDto implements IReportSchDetailsDto {
    qfcNum?: string | undefined;
    rptSchFinYearFromDate?: string | undefined;
    rptSchFinYearToDate?: string | undefined;
    soCompletionDate?: string | undefined;
    rptPeriodTypeDesc?: string | undefined;
    docTypeID?: number | undefined;
    userID?: number | undefined;
    firmsRptSchID?: number | undefined;
    rptSchAttachmentStatusId?: number | undefined;
    rptName?: string | undefined;
    rptDueDate?: string | undefined;
    fileUploadedOnDate?: string | undefined;
    rptSchAttachmentStatusDesc?: string | undefined;
    rptSubmissionTypeID?: number | undefined;
    rptPeriodFromDate?: string | undefined;
    rptSubmissionType?: string | undefined;
    rptPeriodToDate?: string | undefined;
    rptFreqTypeDesc?: string | undefined;
    rptSchID?: number | undefined;
    rptSchItemID?: number | undefined;
    rptSchItemAttachmentID?: number | undefined;
    fileName?: string | undefined;
    attachmentFileURI?: string | undefined;
    objectSOStatusID?: number | undefined;
    fileUploadedByName?: string | undefined;
    fileUploadedByEmailAdd?: string | undefined;
    submittedOn?: string | undefined;
    soStatusTypeDesc?: string | undefined;
    attachmentFilePath?: string | undefined;
    soStatusTypeID?: number | undefined;
    submittedBy?: number | undefined;
    rptNextStatus?: string | undefined;
    attachmentStatusTypeID?: number | undefined;
    objectID?: number | undefined;
    fileAttachedUserEmail?: string | undefined;
    rptAttachmentStatusDate?: string | undefined;
    fileStream?: string | undefined;
    reviewComments?: string | undefined;
    firmsRptSchItemID?: number | undefined;
    manuallyReceived?: boolean | undefined;
    allowReSubmit?: boolean | undefined;
    isFileRecieved?: boolean | undefined;
    lateFeeFlag?: boolean | undefined;
    isReportDue?: boolean | undefined;
    daysOverDue?: number | undefined;
    isReportReminderDue?: boolean | undefined;
    isResubmissionRequested?: boolean | undefined;
    resubmissionRequestedDate?: string | undefined;
    isResubmissionNotificationRequired?: boolean | undefined;
    docReceivedDate?: string | undefined;
    isAMLDocType?: boolean | undefined;
    rptFormsToBeSubmited?: string | undefined;
    submissionBeforeRptPeriodEnd?: boolean | undefined;
    resubmissionDueDate?: string | undefined;

    constructor(data?: IReportSchDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.qfcNum = _data["qfcNum"];
            this.rptSchFinYearFromDate = _data["rptSchFinYearFromDate"];
            this.rptSchFinYearToDate = _data["rptSchFinYearToDate"];
            this.soCompletionDate = _data["soCompletionDate"];
            this.rptPeriodTypeDesc = _data["rptPeriodTypeDesc"];
            this.docTypeID = _data["docTypeID"];
            this.userID = _data["userID"];
            this.firmsRptSchID = _data["firmsRptSchID"];
            this.rptSchAttachmentStatusId = _data["rptSchAttachmentStatusId"];
            this.rptName = _data["rptName"];
            this.rptDueDate = _data["rptDueDate"];
            this.fileUploadedOnDate = _data["fileUploadedOnDate"];
            this.rptSchAttachmentStatusDesc = _data["rptSchAttachmentStatusDesc"];
            this.rptSubmissionTypeID = _data["rptSubmissionTypeID"];
            this.rptPeriodFromDate = _data["rptPeriodFromDate"];
            this.rptSubmissionType = _data["rptSubmissionType"];
            this.rptPeriodToDate = _data["rptPeriodToDate"];
            this.rptFreqTypeDesc = _data["rptFreqTypeDesc"];
            this.rptSchID = _data["rptSchID"];
            this.rptSchItemID = _data["rptSchItemID"];
            this.rptSchItemAttachmentID = _data["rptSchItemAttachmentID"];
            this.fileName = _data["fileName"];
            this.attachmentFileURI = _data["attachmentFileURI"];
            this.objectSOStatusID = _data["objectSOStatusID"];
            this.fileUploadedByName = _data["fileUploadedByName"];
            this.fileUploadedByEmailAdd = _data["fileUploadedByEmailAdd"];
            this.submittedOn = _data["submittedOn"];
            this.soStatusTypeDesc = _data["soStatusTypeDesc"];
            this.attachmentFilePath = _data["attachmentFilePath"];
            this.soStatusTypeID = _data["soStatusTypeID"];
            this.submittedBy = _data["submittedBy"];
            this.rptNextStatus = _data["rptNextStatus"];
            this.attachmentStatusTypeID = _data["attachmentStatusTypeID"];
            this.objectID = _data["objectID"];
            this.fileAttachedUserEmail = _data["fileAttachedUserEmail"];
            this.rptAttachmentStatusDate = _data["rptAttachmentStatusDate"];
            this.fileStream = _data["fileStream"];
            this.reviewComments = _data["reviewComments"];
            this.firmsRptSchItemID = _data["firmsRptSchItemID"];
            this.manuallyReceived = _data["manuallyReceived"];
            this.allowReSubmit = _data["allowReSubmit"];
            this.isFileRecieved = _data["isFileRecieved"];
            this.lateFeeFlag = _data["lateFeeFlag"];
            this.isReportDue = _data["isReportDue"];
            this.daysOverDue = _data["daysOverDue"];
            this.isReportReminderDue = _data["isReportReminderDue"];
            this.isResubmissionRequested = _data["isResubmissionRequested"];
            this.resubmissionRequestedDate = _data["resubmissionRequestedDate"];
            this.isResubmissionNotificationRequired = _data["isResubmissionNotificationRequired"];
            this.docReceivedDate = _data["docReceivedDate"];
            this.isAMLDocType = _data["isAMLDocType"];
            this.rptFormsToBeSubmited = _data["rptFormsToBeSubmited"];
            this.submissionBeforeRptPeriodEnd = _data["submissionBeforeRptPeriodEnd"];
            this.resubmissionDueDate = _data["resubmissionDueDate"];
        }
    }

    static fromJS(data: any): ReportSchDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportSchDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qfcNum"] = this.qfcNum;
        data["rptSchFinYearFromDate"] = this.rptSchFinYearFromDate;
        data["rptSchFinYearToDate"] = this.rptSchFinYearToDate;
        data["soCompletionDate"] = this.soCompletionDate;
        data["rptPeriodTypeDesc"] = this.rptPeriodTypeDesc;
        data["docTypeID"] = this.docTypeID;
        data["userID"] = this.userID;
        data["firmsRptSchID"] = this.firmsRptSchID;
        data["rptSchAttachmentStatusId"] = this.rptSchAttachmentStatusId;
        data["rptName"] = this.rptName;
        data["rptDueDate"] = this.rptDueDate;
        data["fileUploadedOnDate"] = this.fileUploadedOnDate;
        data["rptSchAttachmentStatusDesc"] = this.rptSchAttachmentStatusDesc;
        data["rptSubmissionTypeID"] = this.rptSubmissionTypeID;
        data["rptPeriodFromDate"] = this.rptPeriodFromDate;
        data["rptSubmissionType"] = this.rptSubmissionType;
        data["rptPeriodToDate"] = this.rptPeriodToDate;
        data["rptFreqTypeDesc"] = this.rptFreqTypeDesc;
        data["rptSchID"] = this.rptSchID;
        data["rptSchItemID"] = this.rptSchItemID;
        data["rptSchItemAttachmentID"] = this.rptSchItemAttachmentID;
        data["fileName"] = this.fileName;
        data["attachmentFileURI"] = this.attachmentFileURI;
        data["objectSOStatusID"] = this.objectSOStatusID;
        data["fileUploadedByName"] = this.fileUploadedByName;
        data["fileUploadedByEmailAdd"] = this.fileUploadedByEmailAdd;
        data["submittedOn"] = this.submittedOn;
        data["soStatusTypeDesc"] = this.soStatusTypeDesc;
        data["attachmentFilePath"] = this.attachmentFilePath;
        data["soStatusTypeID"] = this.soStatusTypeID;
        data["submittedBy"] = this.submittedBy;
        data["rptNextStatus"] = this.rptNextStatus;
        data["attachmentStatusTypeID"] = this.attachmentStatusTypeID;
        data["objectID"] = this.objectID;
        data["fileAttachedUserEmail"] = this.fileAttachedUserEmail;
        data["rptAttachmentStatusDate"] = this.rptAttachmentStatusDate;
        data["fileStream"] = this.fileStream;
        data["reviewComments"] = this.reviewComments;
        data["firmsRptSchItemID"] = this.firmsRptSchItemID;
        data["manuallyReceived"] = this.manuallyReceived;
        data["allowReSubmit"] = this.allowReSubmit;
        data["isFileRecieved"] = this.isFileRecieved;
        data["lateFeeFlag"] = this.lateFeeFlag;
        data["isReportDue"] = this.isReportDue;
        data["daysOverDue"] = this.daysOverDue;
        data["isReportReminderDue"] = this.isReportReminderDue;
        data["isResubmissionRequested"] = this.isResubmissionRequested;
        data["resubmissionRequestedDate"] = this.resubmissionRequestedDate;
        data["isResubmissionNotificationRequired"] = this.isResubmissionNotificationRequired;
        data["docReceivedDate"] = this.docReceivedDate;
        data["isAMLDocType"] = this.isAMLDocType;
        data["rptFormsToBeSubmited"] = this.rptFormsToBeSubmited;
        data["submissionBeforeRptPeriodEnd"] = this.submissionBeforeRptPeriodEnd;
        data["resubmissionDueDate"] = this.resubmissionDueDate;
        return data;
    }
}

export interface IReportSchDetailsDto {
    qfcNum?: string | undefined;
    rptSchFinYearFromDate?: string | undefined;
    rptSchFinYearToDate?: string | undefined;
    soCompletionDate?: string | undefined;
    rptPeriodTypeDesc?: string | undefined;
    docTypeID?: number | undefined;
    userID?: number | undefined;
    firmsRptSchID?: number | undefined;
    rptSchAttachmentStatusId?: number | undefined;
    rptName?: string | undefined;
    rptDueDate?: string | undefined;
    fileUploadedOnDate?: string | undefined;
    rptSchAttachmentStatusDesc?: string | undefined;
    rptSubmissionTypeID?: number | undefined;
    rptPeriodFromDate?: string | undefined;
    rptSubmissionType?: string | undefined;
    rptPeriodToDate?: string | undefined;
    rptFreqTypeDesc?: string | undefined;
    rptSchID?: number | undefined;
    rptSchItemID?: number | undefined;
    rptSchItemAttachmentID?: number | undefined;
    fileName?: string | undefined;
    attachmentFileURI?: string | undefined;
    objectSOStatusID?: number | undefined;
    fileUploadedByName?: string | undefined;
    fileUploadedByEmailAdd?: string | undefined;
    submittedOn?: string | undefined;
    soStatusTypeDesc?: string | undefined;
    attachmentFilePath?: string | undefined;
    soStatusTypeID?: number | undefined;
    submittedBy?: number | undefined;
    rptNextStatus?: string | undefined;
    attachmentStatusTypeID?: number | undefined;
    objectID?: number | undefined;
    fileAttachedUserEmail?: string | undefined;
    rptAttachmentStatusDate?: string | undefined;
    fileStream?: string | undefined;
    reviewComments?: string | undefined;
    firmsRptSchItemID?: number | undefined;
    manuallyReceived?: boolean | undefined;
    allowReSubmit?: boolean | undefined;
    isFileRecieved?: boolean | undefined;
    lateFeeFlag?: boolean | undefined;
    isReportDue?: boolean | undefined;
    daysOverDue?: number | undefined;
    isReportReminderDue?: boolean | undefined;
    isResubmissionRequested?: boolean | undefined;
    resubmissionRequestedDate?: string | undefined;
    isResubmissionNotificationRequired?: boolean | undefined;
    docReceivedDate?: string | undefined;
    isAMLDocType?: boolean | undefined;
    rptFormsToBeSubmited?: string | undefined;
    submissionBeforeRptPeriodEnd?: boolean | undefined;
    resubmissionDueDate?: string | undefined;
}

export class ReportSchDetailsDtoBaseResponse implements IReportSchDetailsDtoBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: ReportSchDetailsDto;

    constructor(data?: IReportSchDetailsDtoBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            this.response = _data["response"] ? ReportSchDetailsDto.fromJS(_data["response"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ReportSchDetailsDtoBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ReportSchDetailsDtoBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        return data;
    }
}

export interface IReportSchDetailsDtoBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: ReportSchDetailsDto;
}

export class ReportSchDetailsDtoListBaseResponse implements IReportSchDetailsDtoListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: ReportSchDetailsDto[] | undefined;

    constructor(data?: IReportSchDetailsDtoListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["response"])) {
                this.response = [] as any;
                for (let item of _data["response"])
                    this.response!.push(ReportSchDetailsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReportSchDetailsDtoListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ReportSchDetailsDtoListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.response)) {
            data["response"] = [];
            for (let item of this.response)
                data["response"].push(item.toJSON());
        }
        return data;
    }
}

export interface IReportSchDetailsDtoListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: ReportSchDetailsDto[] | undefined;
}

export class ReportSchDetailsListBaseResponse implements IReportSchDetailsListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: ReportSchDetails[] | undefined;

    constructor(data?: IReportSchDetailsListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["response"])) {
                this.response = [] as any;
                for (let item of _data["response"])
                    this.response!.push(ReportSchDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReportSchDetailsListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ReportSchDetailsListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.response)) {
            data["response"] = [];
            for (let item of this.response)
                data["response"].push(item.toJSON());
        }
        return data;
    }
}

export interface IReportSchDetailsListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: ReportSchDetails[] | undefined;
}

export class ReportSchDto implements IReportSchDto {
    qfcNum?: string | undefined;
    rptSchFinYearFromDate?: string | undefined;
    rptSchFinYearToDate?: string | undefined;
    userID?: number | undefined;

    constructor(data?: IReportSchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.qfcNum = _data["qfcNum"];
            this.rptSchFinYearFromDate = _data["rptSchFinYearFromDate"];
            this.rptSchFinYearToDate = _data["rptSchFinYearToDate"];
            this.userID = _data["userID"];
        }
    }

    static fromJS(data: any): ReportSchDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportSchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qfcNum"] = this.qfcNum;
        data["rptSchFinYearFromDate"] = this.rptSchFinYearFromDate;
        data["rptSchFinYearToDate"] = this.rptSchFinYearToDate;
        data["userID"] = this.userID;
        return data;
    }
}

export interface IReportSchDto {
    qfcNum?: string | undefined;
    rptSchFinYearFromDate?: string | undefined;
    rptSchFinYearToDate?: string | undefined;
    userID?: number | undefined;
}

export class ReportSchEmailDet implements IReportSchEmailDet {
    objectID?: number;
    objectInstanceID?: number;
    fromEmail?: string | undefined;
    toEmail?: string | undefined;
    ccEmail?: string | undefined;
    title?: string | undefined;
    subject?: string | undefined;
    body?: string | undefined;
    footer?: string | undefined;
    fileName?: string | undefined;
    reportName?: string | undefined;
    reportDueDate?: string | undefined;
    submittedBy?: string | undefined;
    submittedByEmail?: string | undefined;
    submittedOnDate?: string | undefined;
    signOffRequiredBy?: string | undefined;
    signOffCompletedBy?: string | undefined;
    completionSignOffCompletedBy?: string | undefined;
    url?: string | undefined;
    notifiedBy?: number;
    isFileAgainAttached?: boolean;
    fileAgainAttachedByEmail?: string | undefined;
    applicantName?: string | undefined;
    aiNumber?: string | undefined;
    statusId?: string | undefined;
    statusIdDesc?: string | undefined;
    statusCompletionDate?: string | undefined;
    actionRequested?: string | undefined;
    validationStatus?: string | undefined;
    validationCompletionDate?: string | undefined;
    submissionSignoffCompletionDate?: string | undefined;
    returnCompDate?: string | undefined;

    constructor(data?: IReportSchEmailDet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectID = _data["objectID"];
            this.objectInstanceID = _data["objectInstanceID"];
            this.fromEmail = _data["fromEmail"];
            this.toEmail = _data["toEmail"];
            this.ccEmail = _data["ccEmail"];
            this.title = _data["title"];
            this.subject = _data["subject"];
            this.body = _data["body"];
            this.footer = _data["footer"];
            this.fileName = _data["fileName"];
            this.reportName = _data["reportName"];
            this.reportDueDate = _data["reportDueDate"];
            this.submittedBy = _data["submittedBy"];
            this.submittedByEmail = _data["submittedByEmail"];
            this.submittedOnDate = _data["submittedOnDate"];
            this.signOffRequiredBy = _data["signOffRequiredBy"];
            this.signOffCompletedBy = _data["signOffCompletedBy"];
            this.completionSignOffCompletedBy = _data["completionSignOffCompletedBy"];
            this.url = _data["url"];
            this.notifiedBy = _data["notifiedBy"];
            this.isFileAgainAttached = _data["isFileAgainAttached"];
            this.fileAgainAttachedByEmail = _data["fileAgainAttachedByEmail"];
            this.applicantName = _data["applicantName"];
            this.aiNumber = _data["aiNumber"];
            this.statusId = _data["statusId"];
            this.statusIdDesc = _data["statusIdDesc"];
            this.statusCompletionDate = _data["statusCompletionDate"];
            this.actionRequested = _data["actionRequested"];
            this.validationStatus = _data["validationStatus"];
            this.validationCompletionDate = _data["validationCompletionDate"];
            this.submissionSignoffCompletionDate = _data["submissionSignoffCompletionDate"];
            this.returnCompDate = _data["returnCompDate"];
        }
    }

    static fromJS(data: any): ReportSchEmailDet {
        data = typeof data === 'object' ? data : {};
        let result = new ReportSchEmailDet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectID"] = this.objectID;
        data["objectInstanceID"] = this.objectInstanceID;
        data["fromEmail"] = this.fromEmail;
        data["toEmail"] = this.toEmail;
        data["ccEmail"] = this.ccEmail;
        data["title"] = this.title;
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["footer"] = this.footer;
        data["fileName"] = this.fileName;
        data["reportName"] = this.reportName;
        data["reportDueDate"] = this.reportDueDate;
        data["submittedBy"] = this.submittedBy;
        data["submittedByEmail"] = this.submittedByEmail;
        data["submittedOnDate"] = this.submittedOnDate;
        data["signOffRequiredBy"] = this.signOffRequiredBy;
        data["signOffCompletedBy"] = this.signOffCompletedBy;
        data["completionSignOffCompletedBy"] = this.completionSignOffCompletedBy;
        data["url"] = this.url;
        data["notifiedBy"] = this.notifiedBy;
        data["isFileAgainAttached"] = this.isFileAgainAttached;
        data["fileAgainAttachedByEmail"] = this.fileAgainAttachedByEmail;
        data["applicantName"] = this.applicantName;
        data["aiNumber"] = this.aiNumber;
        data["statusId"] = this.statusId;
        data["statusIdDesc"] = this.statusIdDesc;
        data["statusCompletionDate"] = this.statusCompletionDate;
        data["actionRequested"] = this.actionRequested;
        data["validationStatus"] = this.validationStatus;
        data["validationCompletionDate"] = this.validationCompletionDate;
        data["submissionSignoffCompletionDate"] = this.submissionSignoffCompletionDate;
        data["returnCompDate"] = this.returnCompDate;
        return data;
    }
}

export interface IReportSchEmailDet {
    objectID?: number;
    objectInstanceID?: number;
    fromEmail?: string | undefined;
    toEmail?: string | undefined;
    ccEmail?: string | undefined;
    title?: string | undefined;
    subject?: string | undefined;
    body?: string | undefined;
    footer?: string | undefined;
    fileName?: string | undefined;
    reportName?: string | undefined;
    reportDueDate?: string | undefined;
    submittedBy?: string | undefined;
    submittedByEmail?: string | undefined;
    submittedOnDate?: string | undefined;
    signOffRequiredBy?: string | undefined;
    signOffCompletedBy?: string | undefined;
    completionSignOffCompletedBy?: string | undefined;
    url?: string | undefined;
    notifiedBy?: number;
    isFileAgainAttached?: boolean;
    fileAgainAttachedByEmail?: string | undefined;
    applicantName?: string | undefined;
    aiNumber?: string | undefined;
    statusId?: string | undefined;
    statusIdDesc?: string | undefined;
    statusCompletionDate?: string | undefined;
    actionRequested?: string | undefined;
    validationStatus?: string | undefined;
    validationCompletionDate?: string | undefined;
    submissionSignoffCompletionDate?: string | undefined;
    returnCompDate?: string | undefined;
}

export class ReportSchEmailDetBaseResponse implements IReportSchEmailDetBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: ReportSchEmailDet;

    constructor(data?: IReportSchEmailDetBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            this.response = _data["response"] ? ReportSchEmailDet.fromJS(_data["response"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ReportSchEmailDetBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ReportSchEmailDetBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        return data;
    }
}

export interface IReportSchEmailDetBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: ReportSchEmailDet;
}

export class ReportSchItem implements IReportSchItem {
    rptSchItemID?: number;
    rptSchID?: number;
    docTypeID?: number;
    rptName?: string | undefined;
    rptDueDate?: string | undefined;
    rptPeriodFromDate?: string | undefined;
    rptPeriodToDate?: string | undefined;
    rptPeriodTypeDesc?: string | undefined;
    rptFreqTypeDesc?: string | undefined;
    userID?: number;
    reviewComments?: string | undefined;
    manuallyReceived?: boolean;
    allowReSubmit?: boolean;
    rptSubmissionTypeID?: number;

    constructor(data?: IReportSchItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rptSchItemID = _data["rptSchItemID"];
            this.rptSchID = _data["rptSchID"];
            this.docTypeID = _data["docTypeID"];
            this.rptName = _data["rptName"];
            this.rptDueDate = _data["rptDueDate"];
            this.rptPeriodFromDate = _data["rptPeriodFromDate"];
            this.rptPeriodToDate = _data["rptPeriodToDate"];
            this.rptPeriodTypeDesc = _data["rptPeriodTypeDesc"];
            this.rptFreqTypeDesc = _data["rptFreqTypeDesc"];
            this.userID = _data["userID"];
            this.reviewComments = _data["reviewComments"];
            this.manuallyReceived = _data["manuallyReceived"];
            this.allowReSubmit = _data["allowReSubmit"];
            this.rptSubmissionTypeID = _data["rptSubmissionTypeID"];
        }
    }

    static fromJS(data: any): ReportSchItem {
        data = typeof data === 'object' ? data : {};
        let result = new ReportSchItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rptSchItemID"] = this.rptSchItemID;
        data["rptSchID"] = this.rptSchID;
        data["docTypeID"] = this.docTypeID;
        data["rptName"] = this.rptName;
        data["rptDueDate"] = this.rptDueDate;
        data["rptPeriodFromDate"] = this.rptPeriodFromDate;
        data["rptPeriodToDate"] = this.rptPeriodToDate;
        data["rptPeriodTypeDesc"] = this.rptPeriodTypeDesc;
        data["rptFreqTypeDesc"] = this.rptFreqTypeDesc;
        data["userID"] = this.userID;
        data["reviewComments"] = this.reviewComments;
        data["manuallyReceived"] = this.manuallyReceived;
        data["allowReSubmit"] = this.allowReSubmit;
        data["rptSubmissionTypeID"] = this.rptSubmissionTypeID;
        return data;
    }
}

export interface IReportSchItem {
    rptSchItemID?: number;
    rptSchID?: number;
    docTypeID?: number;
    rptName?: string | undefined;
    rptDueDate?: string | undefined;
    rptPeriodFromDate?: string | undefined;
    rptPeriodToDate?: string | undefined;
    rptPeriodTypeDesc?: string | undefined;
    rptFreqTypeDesc?: string | undefined;
    userID?: number;
    reviewComments?: string | undefined;
    manuallyReceived?: boolean;
    allowReSubmit?: boolean;
    rptSubmissionTypeID?: number;
}

export class ReportSignatories implements IReportSignatories {
    rptSignatoryID?: number;
    qfcNum?: string | undefined;
    docTypeID?: number;
    signOffSeqNo?: number;
    groupSignOff?: boolean;
    valid?: boolean;
    individualName?: string | undefined;
    emailAdd?: string | undefined;
    signedByID?: number;
    signedOnDate?: string | undefined;
    userID?: number;
    docSignatoryID?: number;
    roles?: string | undefined;
    occurance?: number;
    userRole?: number;

    constructor(data?: IReportSignatories) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rptSignatoryID = _data["rptSignatoryID"];
            this.qfcNum = _data["qfcNum"];
            this.docTypeID = _data["docTypeID"];
            this.signOffSeqNo = _data["signOffSeqNo"];
            this.groupSignOff = _data["groupSignOff"];
            this.valid = _data["valid"];
            this.individualName = _data["individualName"];
            this.emailAdd = _data["emailAdd"];
            this.signedByID = _data["signedByID"];
            this.signedOnDate = _data["signedOnDate"];
            this.userID = _data["userID"];
            this.docSignatoryID = _data["docSignatoryID"];
            this.roles = _data["roles"];
            this.occurance = _data["occurance"];
            this.userRole = _data["userRole"];
        }
    }

    static fromJS(data: any): ReportSignatories {
        data = typeof data === 'object' ? data : {};
        let result = new ReportSignatories();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rptSignatoryID"] = this.rptSignatoryID;
        data["qfcNum"] = this.qfcNum;
        data["docTypeID"] = this.docTypeID;
        data["signOffSeqNo"] = this.signOffSeqNo;
        data["groupSignOff"] = this.groupSignOff;
        data["valid"] = this.valid;
        data["individualName"] = this.individualName;
        data["emailAdd"] = this.emailAdd;
        data["signedByID"] = this.signedByID;
        data["signedOnDate"] = this.signedOnDate;
        data["userID"] = this.userID;
        data["docSignatoryID"] = this.docSignatoryID;
        data["roles"] = this.roles;
        data["occurance"] = this.occurance;
        data["userRole"] = this.userRole;
        return data;
    }
}

export interface IReportSignatories {
    rptSignatoryID?: number;
    qfcNum?: string | undefined;
    docTypeID?: number;
    signOffSeqNo?: number;
    groupSignOff?: boolean;
    valid?: boolean;
    individualName?: string | undefined;
    emailAdd?: string | undefined;
    signedByID?: number;
    signedOnDate?: string | undefined;
    userID?: number;
    docSignatoryID?: number;
    roles?: string | undefined;
    occurance?: number;
    userRole?: number;
}

export class ReportSignatoriesListBaseResponse implements IReportSignatoriesListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: ReportSignatories[] | undefined;

    constructor(data?: IReportSignatoriesListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["response"])) {
                this.response = [] as any;
                for (let item of _data["response"])
                    this.response!.push(ReportSignatories.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReportSignatoriesListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ReportSignatoriesListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.response)) {
            data["response"] = [];
            for (let item of this.response)
                data["response"].push(item.toJSON());
        }
        return data;
    }
}

export interface IReportSignatoriesListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: ReportSignatories[] | undefined;
}

export class Residencies implements IResidencies {
    residenciesID?: number | undefined;
    residenciesGUID?: string | undefined;
    residenciesTypeID?: number | undefined;
    residenciesTypeDesc?: string | undefined;
    countryID?: number | undefined;
    countryName?: string | undefined;
    notes?: string | undefined;
    fromDay?: string | undefined;
    fromMonth?: string | undefined;
    fromYear?: string | undefined;
    toDay?: string | undefined;
    toMonth?: string | undefined;
    toYear?: string | undefined;
    userID?: number;
    applicationID?: number;
    createdDate?: string | undefined;
    modifiedDate?: string | undefined;
    modifiedBy?: number;

    constructor(data?: IResidencies) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.residenciesID = _data["residenciesID"];
            this.residenciesGUID = _data["residenciesGUID"];
            this.residenciesTypeID = _data["residenciesTypeID"];
            this.residenciesTypeDesc = _data["residenciesTypeDesc"];
            this.countryID = _data["countryID"];
            this.countryName = _data["countryName"];
            this.notes = _data["notes"];
            this.fromDay = _data["fromDay"];
            this.fromMonth = _data["fromMonth"];
            this.fromYear = _data["fromYear"];
            this.toDay = _data["toDay"];
            this.toMonth = _data["toMonth"];
            this.toYear = _data["toYear"];
            this.userID = _data["userID"];
            this.applicationID = _data["applicationID"];
            this.createdDate = _data["createdDate"];
            this.modifiedDate = _data["modifiedDate"];
            this.modifiedBy = _data["modifiedBy"];
        }
    }

    static fromJS(data: any): Residencies {
        data = typeof data === 'object' ? data : {};
        let result = new Residencies();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["residenciesID"] = this.residenciesID;
        data["residenciesGUID"] = this.residenciesGUID;
        data["residenciesTypeID"] = this.residenciesTypeID;
        data["residenciesTypeDesc"] = this.residenciesTypeDesc;
        data["countryID"] = this.countryID;
        data["countryName"] = this.countryName;
        data["notes"] = this.notes;
        data["fromDay"] = this.fromDay;
        data["fromMonth"] = this.fromMonth;
        data["fromYear"] = this.fromYear;
        data["toDay"] = this.toDay;
        data["toMonth"] = this.toMonth;
        data["toYear"] = this.toYear;
        data["userID"] = this.userID;
        data["applicationID"] = this.applicationID;
        data["createdDate"] = this.createdDate;
        data["modifiedDate"] = this.modifiedDate;
        data["modifiedBy"] = this.modifiedBy;
        return data;
    }
}

export interface IResidencies {
    residenciesID?: number | undefined;
    residenciesGUID?: string | undefined;
    residenciesTypeID?: number | undefined;
    residenciesTypeDesc?: string | undefined;
    countryID?: number | undefined;
    countryName?: string | undefined;
    notes?: string | undefined;
    fromDay?: string | undefined;
    fromMonth?: string | undefined;
    fromYear?: string | undefined;
    toDay?: string | undefined;
    toMonth?: string | undefined;
    toYear?: string | undefined;
    userID?: number;
    applicationID?: number;
    createdDate?: string | undefined;
    modifiedDate?: string | undefined;
    modifiedBy?: number;
}

export class SavePrimaryDocumentResponse implements ISavePrimaryDocumentResponse {
    wObjectInstanceID?: number;
    wObjectInstanceRevNum?: number;

    constructor(data?: ISavePrimaryDocumentResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wObjectInstanceID = _data["wObjectInstanceID"];
            this.wObjectInstanceRevNum = _data["wObjectInstanceRevNum"];
        }
    }

    static fromJS(data: any): SavePrimaryDocumentResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SavePrimaryDocumentResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wObjectInstanceID"] = this.wObjectInstanceID;
        data["wObjectInstanceRevNum"] = this.wObjectInstanceRevNum;
        return data;
    }
}

export interface ISavePrimaryDocumentResponse {
    wObjectInstanceID?: number;
    wObjectInstanceRevNum?: number;
}

export class SavePrimaryDocumentResponseBaseResponse implements ISavePrimaryDocumentResponseBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: SavePrimaryDocumentResponse;

    constructor(data?: ISavePrimaryDocumentResponseBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            this.response = _data["response"] ? SavePrimaryDocumentResponse.fromJS(_data["response"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SavePrimaryDocumentResponseBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SavePrimaryDocumentResponseBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISavePrimaryDocumentResponseBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: SavePrimaryDocumentResponse;
}

export enum SchemaSerializationMode {
    _1 = 1,
    _2 = 2,
}

export enum SerializationFormat {
    _0 = 0,
    _1 = 1,
}

export class SignOffDetails implements ISignOffDetails {
    userName?: string | undefined;
    password?: string | undefined;
    objectID?: number;
    objectInstanceID?: number;
    objectSOStatusID?: number;
    objectSOTaskStatusID?: number;
    sequenceNumber?: number;
    docSignatoryID?: number;
    soStatusTypeID?: number;
    signOffName?: string | undefined;
    signOffUserIds?: string | undefined;
    signedOnDate?: string | undefined;
    roles?: string | undefined;
    wTermID?: number | undefined;
    agreedOnTerms?: boolean | undefined;
    termsAgreedDate?: string | undefined;
    soTaskValid?: boolean | undefined;

    constructor(data?: ISignOffDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.objectID = _data["objectID"];
            this.objectInstanceID = _data["objectInstanceID"];
            this.objectSOStatusID = _data["objectSOStatusID"];
            this.objectSOTaskStatusID = _data["objectSOTaskStatusID"];
            this.sequenceNumber = _data["sequenceNumber"];
            this.docSignatoryID = _data["docSignatoryID"];
            this.soStatusTypeID = _data["soStatusTypeID"];
            this.signOffName = _data["signOffName"];
            this.signOffUserIds = _data["signOffUserIds"];
            this.signedOnDate = _data["signedOnDate"];
            this.roles = _data["roles"];
            this.wTermID = _data["wTermID"];
            this.agreedOnTerms = _data["agreedOnTerms"];
            this.termsAgreedDate = _data["termsAgreedDate"];
            this.soTaskValid = _data["soTaskValid"];
        }
    }

    static fromJS(data: any): SignOffDetails {
        data = typeof data === 'object' ? data : {};
        let result = new SignOffDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["objectID"] = this.objectID;
        data["objectInstanceID"] = this.objectInstanceID;
        data["objectSOStatusID"] = this.objectSOStatusID;
        data["objectSOTaskStatusID"] = this.objectSOTaskStatusID;
        data["sequenceNumber"] = this.sequenceNumber;
        data["docSignatoryID"] = this.docSignatoryID;
        data["soStatusTypeID"] = this.soStatusTypeID;
        data["signOffName"] = this.signOffName;
        data["signOffUserIds"] = this.signOffUserIds;
        data["signedOnDate"] = this.signedOnDate;
        data["roles"] = this.roles;
        data["wTermID"] = this.wTermID;
        data["agreedOnTerms"] = this.agreedOnTerms;
        data["termsAgreedDate"] = this.termsAgreedDate;
        data["soTaskValid"] = this.soTaskValid;
        return data;
    }
}

export interface ISignOffDetails {
    userName?: string | undefined;
    password?: string | undefined;
    objectID?: number;
    objectInstanceID?: number;
    objectSOStatusID?: number;
    objectSOTaskStatusID?: number;
    sequenceNumber?: number;
    docSignatoryID?: number;
    soStatusTypeID?: number;
    signOffName?: string | undefined;
    signOffUserIds?: string | undefined;
    signedOnDate?: string | undefined;
    roles?: string | undefined;
    wTermID?: number | undefined;
    agreedOnTerms?: boolean | undefined;
    termsAgreedDate?: string | undefined;
    soTaskValid?: boolean | undefined;
}

export class SortVersion implements ISortVersion {
    fullVersion?: number;
    sortId?: string;

    constructor(data?: ISortVersion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullVersion = _data["fullVersion"];
            this.sortId = _data["sortId"];
        }
    }

    static fromJS(data: any): SortVersion {
        data = typeof data === 'object' ? data : {};
        let result = new SortVersion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullVersion"] = this.fullVersion;
        data["sortId"] = this.sortId;
        return data;
    }
}

export interface ISortVersion {
    fullVersion?: number;
    sortId?: string;
}

export class StringBaseResponse implements IStringBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: string | undefined;

    constructor(data?: IStringBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            this.response = _data["response"];
        }
    }

    static fromJS(data: any): StringBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        data["response"] = this.response;
        return data;
    }
}

export interface IStringBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: string | undefined;
}

export class StringListBaseResponse implements IStringListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: string[] | undefined;

    constructor(data?: IStringListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["response"])) {
                this.response = [] as any;
                for (let item of _data["response"])
                    this.response!.push(item);
            }
        }
    }

    static fromJS(data: any): StringListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.response)) {
            data["response"] = [];
            for (let item of this.response)
                data["response"].push(item);
        }
        return data;
    }
}

export interface IStringListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: string[] | undefined;
}

export class StringObjectDictionaryListBaseResponse implements IStringObjectDictionaryListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: { [key: string]: any; }[] | undefined;

    constructor(data?: IStringObjectDictionaryListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["response"])) {
                this.response = [] as any;
                for (let item of _data["response"])
                    this.response!.push(item);
            }
        }
    }

    static fromJS(data: any): StringObjectDictionaryListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringObjectDictionaryListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.response)) {
            data["response"] = [];
            for (let item of this.response)
                data["response"].push(item);
        }
        return data;
    }
}

export interface IStringObjectDictionaryListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: { [key: string]: any; }[] | undefined;
}

export class StringObjectIDictionaryListBaseResponse implements IStringObjectIDictionaryListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: { [key: string]: any; }[] | undefined;

    constructor(data?: IStringObjectIDictionaryListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["response"])) {
                this.response = [] as any;
                for (let item of _data["response"])
                    this.response!.push(item);
            }
        }
    }

    static fromJS(data: any): StringObjectIDictionaryListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringObjectIDictionaryListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.response)) {
            data["response"] = [];
            for (let item of this.response)
                data["response"].push(item);
        }
        return data;
    }
}

export interface IStringObjectIDictionaryListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: { [key: string]: any; }[] | undefined;
}

export class StringStringDictionaryBaseResponse implements IStringStringDictionaryBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: { [key: string]: string; } | undefined;

    constructor(data?: IStringStringDictionaryBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (_data["response"]) {
                this.response = {} as any;
                for (let key in _data["response"]) {
                    if (_data["response"].hasOwnProperty(key))
                        (<any>this.response)![key] = _data["response"][key];
                }
            }
        }
    }

    static fromJS(data: any): StringStringDictionaryBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringStringDictionaryBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (this.response) {
            data["response"] = {};
            for (let key in this.response) {
                if (this.response.hasOwnProperty(key))
                    (<any>data["response"])[key] = (<any>this.response)[key];
            }
        }
        return data;
    }
}

export interface IStringStringDictionaryBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: { [key: string]: string; } | undefined;
}

export class Terms implements ITerms {
    wTermsID?: number;
    wTermSubject?: string | undefined;
    wTermTitle?: string | undefined;
    wTermDesc?: string | undefined;

    constructor(data?: ITerms) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wTermsID = _data["wTermsID"];
            this.wTermSubject = _data["wTermSubject"];
            this.wTermTitle = _data["wTermTitle"];
            this.wTermDesc = _data["wTermDesc"];
        }
    }

    static fromJS(data: any): Terms {
        data = typeof data === 'object' ? data : {};
        let result = new Terms();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wTermsID"] = this.wTermsID;
        data["wTermSubject"] = this.wTermSubject;
        data["wTermTitle"] = this.wTermTitle;
        data["wTermDesc"] = this.wTermDesc;
        return data;
    }
}

export interface ITerms {
    wTermsID?: number;
    wTermSubject?: string | undefined;
    wTermTitle?: string | undefined;
    wTermDesc?: string | undefined;
}

export class TermsBaseResponse implements ITermsBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: Terms;

    constructor(data?: ITermsBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            this.response = _data["response"] ? Terms.fromJS(_data["response"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TermsBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TermsBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITermsBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: Terms;
}

export class TextInfo implements ITextInfo {
    readonly ansiCodePage?: number;
    readonly oemCodePage?: number;
    readonly macCodePage?: number;
    readonly ebcdicCodePage?: number;
    readonly lcid?: number;
    readonly cultureName?: string | undefined;
    readonly isReadOnly?: boolean;
    listSeparator?: string | undefined;
    readonly isRightToLeft?: boolean;

    constructor(data?: ITextInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).ansiCodePage = _data["ansiCodePage"];
            (<any>this).oemCodePage = _data["oemCodePage"];
            (<any>this).macCodePage = _data["macCodePage"];
            (<any>this).ebcdicCodePage = _data["ebcdicCodePage"];
            (<any>this).lcid = _data["lcid"];
            (<any>this).cultureName = _data["cultureName"];
            (<any>this).isReadOnly = _data["isReadOnly"];
            this.listSeparator = _data["listSeparator"];
            (<any>this).isRightToLeft = _data["isRightToLeft"];
        }
    }

    static fromJS(data: any): TextInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TextInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ansiCodePage"] = this.ansiCodePage;
        data["oemCodePage"] = this.oemCodePage;
        data["macCodePage"] = this.macCodePage;
        data["ebcdicCodePage"] = this.ebcdicCodePage;
        data["lcid"] = this.lcid;
        data["cultureName"] = this.cultureName;
        data["isReadOnly"] = this.isReadOnly;
        data["listSeparator"] = this.listSeparator;
        data["isRightToLeft"] = this.isRightToLeft;
        return data;
    }
}

export interface ITextInfo {
    ansiCodePage?: number;
    oemCodePage?: number;
    macCodePage?: number;
    ebcdicCodePage?: number;
    lcid?: number;
    cultureName?: string | undefined;
    isReadOnly?: boolean;
    listSeparator?: string | undefined;
    isRightToLeft?: boolean;
}

export class UserPendingItems implements IUserPendingItems {
    qfcNumber?: string | undefined;
    userID?: number;
    objectID?: number;
    objectInstanceID?: number;
    reportOrIndName?: string | undefined;
    reportFrom?: string | undefined;
    reportTo?: string | undefined;
    rptDueDate?: string | undefined;
    purpose?: string | undefined;
    formTypeID?: number;
    finalDescription?: string | undefined;
    rptSchItemID?: number;
    rptFreqTypeDesc?: string | undefined;
    rptPeriodTypeDesc?: string | undefined;
    docTypeID?: number | undefined;
    dateCreated?: string | undefined;
    wRptSubmissionTypeID?: number | undefined;
    rptSchItemFromDate?: string | undefined;
    rptSchItemToDate?: string | undefined;
    objectType?: string | undefined;
    taskType?: string | undefined;
    nextRunTime?: string | undefined;

    constructor(data?: IUserPendingItems) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.qfcNumber = _data["qfcNumber"];
            this.userID = _data["userID"];
            this.objectID = _data["objectID"];
            this.objectInstanceID = _data["objectInstanceID"];
            this.reportOrIndName = _data["reportOrIndName"];
            this.reportFrom = _data["reportFrom"];
            this.reportTo = _data["reportTo"];
            this.rptDueDate = _data["rptDueDate"];
            this.purpose = _data["purpose"];
            this.formTypeID = _data["formTypeID"];
            this.finalDescription = _data["finalDescription"];
            this.rptSchItemID = _data["rptSchItemID"];
            this.rptFreqTypeDesc = _data["rptFreqTypeDesc"];
            this.rptPeriodTypeDesc = _data["rptPeriodTypeDesc"];
            this.docTypeID = _data["docTypeID"];
            this.dateCreated = _data["dateCreated"];
            this.wRptSubmissionTypeID = _data["wRptSubmissionTypeID"];
            this.rptSchItemFromDate = _data["rptSchItemFromDate"];
            this.rptSchItemToDate = _data["rptSchItemToDate"];
            this.objectType = _data["objectType"];
            this.taskType = _data["taskType"];
            this.nextRunTime = _data["nextRunTime"];
        }
    }

    static fromJS(data: any): UserPendingItems {
        data = typeof data === 'object' ? data : {};
        let result = new UserPendingItems();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qfcNumber"] = this.qfcNumber;
        data["userID"] = this.userID;
        data["objectID"] = this.objectID;
        data["objectInstanceID"] = this.objectInstanceID;
        data["reportOrIndName"] = this.reportOrIndName;
        data["reportFrom"] = this.reportFrom;
        data["reportTo"] = this.reportTo;
        data["rptDueDate"] = this.rptDueDate;
        data["purpose"] = this.purpose;
        data["formTypeID"] = this.formTypeID;
        data["finalDescription"] = this.finalDescription;
        data["rptSchItemID"] = this.rptSchItemID;
        data["rptFreqTypeDesc"] = this.rptFreqTypeDesc;
        data["rptPeriodTypeDesc"] = this.rptPeriodTypeDesc;
        data["docTypeID"] = this.docTypeID;
        data["dateCreated"] = this.dateCreated;
        data["wRptSubmissionTypeID"] = this.wRptSubmissionTypeID;
        data["rptSchItemFromDate"] = this.rptSchItemFromDate;
        data["rptSchItemToDate"] = this.rptSchItemToDate;
        data["objectType"] = this.objectType;
        data["taskType"] = this.taskType;
        data["nextRunTime"] = this.nextRunTime;
        return data;
    }
}

export interface IUserPendingItems {
    qfcNumber?: string | undefined;
    userID?: number;
    objectID?: number;
    objectInstanceID?: number;
    reportOrIndName?: string | undefined;
    reportFrom?: string | undefined;
    reportTo?: string | undefined;
    rptDueDate?: string | undefined;
    purpose?: string | undefined;
    formTypeID?: number;
    finalDescription?: string | undefined;
    rptSchItemID?: number;
    rptFreqTypeDesc?: string | undefined;
    rptPeriodTypeDesc?: string | undefined;
    docTypeID?: number | undefined;
    dateCreated?: string | undefined;
    wRptSubmissionTypeID?: number | undefined;
    rptSchItemFromDate?: string | undefined;
    rptSchItemToDate?: string | undefined;
    objectType?: string | undefined;
    taskType?: string | undefined;
    nextRunTime?: string | undefined;
}

export class UserPendingItemsListBaseResponse implements IUserPendingItemsListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: UserPendingItems[] | undefined;

    constructor(data?: IUserPendingItemsListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["response"])) {
                this.response = [] as any;
                for (let item of _data["response"])
                    this.response!.push(UserPendingItems.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserPendingItemsListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserPendingItemsListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.response)) {
            data["response"] = [];
            for (let item of this.response)
                data["response"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserPendingItemsListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: UserPendingItems[] | undefined;
}

export class UserQuestionAnswers implements IUserQuestionAnswers {
    wAccessRequestID?: number | undefined;
    firmQFCNo?: string | undefined;
    firmName?: string | undefined;
    firmTypeID?: number;
    firmTypeDesc?: string | undefined;
    contactID?: number;
    individualName?: string | undefined;
    aiNumber?: string | undefined;
    individualJobTitle?: string | undefined;
    individualDateOfBirth?: string | undefined;
    individualNationality?: string | undefined;
    individualEmailAddress?: string | undefined;
    registrationCode?: string | undefined;
    registrationPassword?: string | undefined;
    registrationDate?: string | undefined;
    isRegistered?: boolean;
    createdBy?: number;
    createdDate?: string | undefined;
    accountLocked?: boolean;
    isAccountExpired?: boolean;
    isLoggedIn?: boolean;
    isActiveUser?: boolean;
    isAccountExists?: boolean;
    isValidReqeust?: boolean | undefined;
    wFunctionTypeIDsList?: string | undefined;
    withdrawnFunctionTypeIDsList?: string | undefined;
    wRequestTypeID?: number;
    wRequestTypeDesc?: string | undefined;
    registrationStatus?: string | undefined;
    wUserAccountTypeID?: number;
    wUserAccountTypeDesc?: string | undefined;
    roleId?: number | undefined;
    roleDesc?: string | undefined;
    wUserID?: number | undefined;
    wUserLoginID?: number | undefined;
    isRecordInsert?: boolean;
    isSEF?: boolean;
    isSessionActive?: boolean;
    passwordChangeDate?: Date | undefined;
    userPassword?: string | undefined;
    lstApplicationDetail?: ApplicationDetail[] | undefined;
    wObjectID?: number | undefined;
    wRoleStartDate?: string | undefined;
    lstWUserRoles?: WUserRoles[] | undefined;
    objectID?: number | undefined;
    userQuestionAnswerID?: number;
    wAppUserID?: number;
    wLoginQuestionTypeID?: number;
    userQuestionAnswer?: string | undefined;
    loginQuestion?: string | undefined;
    answer?: string | undefined;
    wLoginQuestionCategoryTypeID?: number;
    userIPAddess?: string | undefined;
    userSessionID?: string | undefined;

    constructor(data?: IUserQuestionAnswers) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wAccessRequestID = _data["wAccessRequestID"];
            this.firmQFCNo = _data["firmQFCNo"];
            this.firmName = _data["firmName"];
            this.firmTypeID = _data["firmTypeID"];
            this.firmTypeDesc = _data["firmTypeDesc"];
            this.contactID = _data["contactID"];
            this.individualName = _data["individualName"];
            this.aiNumber = _data["aiNumber"];
            this.individualJobTitle = _data["individualJobTitle"];
            this.individualDateOfBirth = _data["individualDateOfBirth"];
            this.individualNationality = _data["individualNationality"];
            this.individualEmailAddress = _data["individualEmailAddress"];
            this.registrationCode = _data["registrationCode"];
            this.registrationPassword = _data["registrationPassword"];
            this.registrationDate = _data["registrationDate"];
            this.isRegistered = _data["isRegistered"];
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"];
            this.accountLocked = _data["accountLocked"];
            this.isAccountExpired = _data["isAccountExpired"];
            this.isLoggedIn = _data["isLoggedIn"];
            this.isActiveUser = _data["isActiveUser"];
            this.isAccountExists = _data["isAccountExists"];
            this.isValidReqeust = _data["isValidReqeust"];
            this.wFunctionTypeIDsList = _data["wFunctionTypeIDsList"];
            this.withdrawnFunctionTypeIDsList = _data["withdrawnFunctionTypeIDsList"];
            this.wRequestTypeID = _data["wRequestTypeID"];
            this.wRequestTypeDesc = _data["wRequestTypeDesc"];
            this.registrationStatus = _data["registrationStatus"];
            this.wUserAccountTypeID = _data["wUserAccountTypeID"];
            this.wUserAccountTypeDesc = _data["wUserAccountTypeDesc"];
            this.roleId = _data["roleId"];
            this.roleDesc = _data["roleDesc"];
            this.wUserID = _data["wUserID"];
            this.wUserLoginID = _data["wUserLoginID"];
            this.isRecordInsert = _data["isRecordInsert"];
            this.isSEF = _data["isSEF"];
            this.isSessionActive = _data["isSessionActive"];
            this.passwordChangeDate = _data["passwordChangeDate"] ? new Date(_data["passwordChangeDate"].toString()) : <any>undefined;
            this.userPassword = _data["userPassword"];
            if (Array.isArray(_data["lstApplicationDetail"])) {
                this.lstApplicationDetail = [] as any;
                for (let item of _data["lstApplicationDetail"])
                    this.lstApplicationDetail!.push(ApplicationDetail.fromJS(item));
            }
            this.wObjectID = _data["wObjectID"];
            this.wRoleStartDate = _data["wRoleStartDate"];
            if (Array.isArray(_data["lstWUserRoles"])) {
                this.lstWUserRoles = [] as any;
                for (let item of _data["lstWUserRoles"])
                    this.lstWUserRoles!.push(WUserRoles.fromJS(item));
            }
            this.objectID = _data["objectID"];
            this.userQuestionAnswerID = _data["userQuestionAnswerID"];
            this.wAppUserID = _data["wAppUserID"];
            this.wLoginQuestionTypeID = _data["wLoginQuestionTypeID"];
            this.userQuestionAnswer = _data["userQuestionAnswer"];
            this.loginQuestion = _data["loginQuestion"];
            this.answer = _data["answer"];
            this.wLoginQuestionCategoryTypeID = _data["wLoginQuestionCategoryTypeID"];
            this.userIPAddess = _data["userIPAddess"];
            this.userSessionID = _data["userSessionID"];
        }
    }

    static fromJS(data: any): UserQuestionAnswers {
        data = typeof data === 'object' ? data : {};
        let result = new UserQuestionAnswers();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wAccessRequestID"] = this.wAccessRequestID;
        data["firmQFCNo"] = this.firmQFCNo;
        data["firmName"] = this.firmName;
        data["firmTypeID"] = this.firmTypeID;
        data["firmTypeDesc"] = this.firmTypeDesc;
        data["contactID"] = this.contactID;
        data["individualName"] = this.individualName;
        data["aiNumber"] = this.aiNumber;
        data["individualJobTitle"] = this.individualJobTitle;
        data["individualDateOfBirth"] = this.individualDateOfBirth;
        data["individualNationality"] = this.individualNationality;
        data["individualEmailAddress"] = this.individualEmailAddress;
        data["registrationCode"] = this.registrationCode;
        data["registrationPassword"] = this.registrationPassword;
        data["registrationDate"] = this.registrationDate;
        data["isRegistered"] = this.isRegistered;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate;
        data["accountLocked"] = this.accountLocked;
        data["isAccountExpired"] = this.isAccountExpired;
        data["isLoggedIn"] = this.isLoggedIn;
        data["isActiveUser"] = this.isActiveUser;
        data["isAccountExists"] = this.isAccountExists;
        data["isValidReqeust"] = this.isValidReqeust;
        data["wFunctionTypeIDsList"] = this.wFunctionTypeIDsList;
        data["withdrawnFunctionTypeIDsList"] = this.withdrawnFunctionTypeIDsList;
        data["wRequestTypeID"] = this.wRequestTypeID;
        data["wRequestTypeDesc"] = this.wRequestTypeDesc;
        data["registrationStatus"] = this.registrationStatus;
        data["wUserAccountTypeID"] = this.wUserAccountTypeID;
        data["wUserAccountTypeDesc"] = this.wUserAccountTypeDesc;
        data["roleId"] = this.roleId;
        data["roleDesc"] = this.roleDesc;
        data["wUserID"] = this.wUserID;
        data["wUserLoginID"] = this.wUserLoginID;
        data["isRecordInsert"] = this.isRecordInsert;
        data["isSEF"] = this.isSEF;
        data["isSessionActive"] = this.isSessionActive;
        data["passwordChangeDate"] = this.passwordChangeDate ? this.passwordChangeDate.toISOString() : <any>undefined;
        data["userPassword"] = this.userPassword;
        if (Array.isArray(this.lstApplicationDetail)) {
            data["lstApplicationDetail"] = [];
            for (let item of this.lstApplicationDetail)
                data["lstApplicationDetail"].push(item.toJSON());
        }
        data["wObjectID"] = this.wObjectID;
        data["wRoleStartDate"] = this.wRoleStartDate;
        if (Array.isArray(this.lstWUserRoles)) {
            data["lstWUserRoles"] = [];
            for (let item of this.lstWUserRoles)
                data["lstWUserRoles"].push(item.toJSON());
        }
        data["objectID"] = this.objectID;
        data["userQuestionAnswerID"] = this.userQuestionAnswerID;
        data["wAppUserID"] = this.wAppUserID;
        data["wLoginQuestionTypeID"] = this.wLoginQuestionTypeID;
        data["userQuestionAnswer"] = this.userQuestionAnswer;
        data["loginQuestion"] = this.loginQuestion;
        data["answer"] = this.answer;
        data["wLoginQuestionCategoryTypeID"] = this.wLoginQuestionCategoryTypeID;
        data["userIPAddess"] = this.userIPAddess;
        data["userSessionID"] = this.userSessionID;
        return data;
    }
}

export interface IUserQuestionAnswers {
    wAccessRequestID?: number | undefined;
    firmQFCNo?: string | undefined;
    firmName?: string | undefined;
    firmTypeID?: number;
    firmTypeDesc?: string | undefined;
    contactID?: number;
    individualName?: string | undefined;
    aiNumber?: string | undefined;
    individualJobTitle?: string | undefined;
    individualDateOfBirth?: string | undefined;
    individualNationality?: string | undefined;
    individualEmailAddress?: string | undefined;
    registrationCode?: string | undefined;
    registrationPassword?: string | undefined;
    registrationDate?: string | undefined;
    isRegistered?: boolean;
    createdBy?: number;
    createdDate?: string | undefined;
    accountLocked?: boolean;
    isAccountExpired?: boolean;
    isLoggedIn?: boolean;
    isActiveUser?: boolean;
    isAccountExists?: boolean;
    isValidReqeust?: boolean | undefined;
    wFunctionTypeIDsList?: string | undefined;
    withdrawnFunctionTypeIDsList?: string | undefined;
    wRequestTypeID?: number;
    wRequestTypeDesc?: string | undefined;
    registrationStatus?: string | undefined;
    wUserAccountTypeID?: number;
    wUserAccountTypeDesc?: string | undefined;
    roleId?: number | undefined;
    roleDesc?: string | undefined;
    wUserID?: number | undefined;
    wUserLoginID?: number | undefined;
    isRecordInsert?: boolean;
    isSEF?: boolean;
    isSessionActive?: boolean;
    passwordChangeDate?: Date | undefined;
    userPassword?: string | undefined;
    lstApplicationDetail?: ApplicationDetail[] | undefined;
    wObjectID?: number | undefined;
    wRoleStartDate?: string | undefined;
    lstWUserRoles?: WUserRoles[] | undefined;
    objectID?: number | undefined;
    userQuestionAnswerID?: number;
    wAppUserID?: number;
    wLoginQuestionTypeID?: number;
    userQuestionAnswer?: string | undefined;
    loginQuestion?: string | undefined;
    answer?: string | undefined;
    wLoginQuestionCategoryTypeID?: number;
    userIPAddess?: string | undefined;
    userSessionID?: string | undefined;
}

export class UserQuestionAnswersDto implements IUserQuestionAnswersDto {
    wLoginQuestionTypeID?: number;
    wLoginQuestionCategoryTypeID?: number;
    answer?: string | undefined;

    constructor(data?: IUserQuestionAnswersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wLoginQuestionTypeID = _data["wLoginQuestionTypeID"];
            this.wLoginQuestionCategoryTypeID = _data["wLoginQuestionCategoryTypeID"];
            this.answer = _data["answer"];
        }
    }

    static fromJS(data: any): UserQuestionAnswersDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserQuestionAnswersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wLoginQuestionTypeID"] = this.wLoginQuestionTypeID;
        data["wLoginQuestionCategoryTypeID"] = this.wLoginQuestionCategoryTypeID;
        data["answer"] = this.answer;
        return data;
    }
}

export interface IUserQuestionAnswersDto {
    wLoginQuestionTypeID?: number;
    wLoginQuestionCategoryTypeID?: number;
    answer?: string | undefined;
}

export class UserQuestionAnswersListBaseResponse implements IUserQuestionAnswersListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: UserQuestionAnswers[] | undefined;

    constructor(data?: IUserQuestionAnswersListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["response"])) {
                this.response = [] as any;
                for (let item of _data["response"])
                    this.response!.push(UserQuestionAnswers.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserQuestionAnswersListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserQuestionAnswersListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.response)) {
            data["response"] = [];
            for (let item of this.response)
                data["response"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserQuestionAnswersListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: UserQuestionAnswers[] | undefined;
}

export class ValidationFileDto implements IValidationFileDto {
    fileContent?: string | undefined;
    fileName?: string | undefined;

    constructor(data?: IValidationFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileContent = _data["fileContent"];
            this.fileName = _data["fileName"];
        }
    }

    static fromJS(data: any): ValidationFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileContent"] = this.fileContent;
        data["fileName"] = this.fileName;
        return data;
    }
}

export interface IValidationFileDto {
    fileContent?: string | undefined;
    fileName?: string | undefined;
}

export class ValidationFileDtoBaseResponse implements IValidationFileDtoBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: ValidationFileDto;

    constructor(data?: IValidationFileDtoBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            this.response = _data["response"] ? ValidationFileDto.fromJS(_data["response"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ValidationFileDtoBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationFileDtoBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        return data;
    }
}

export interface IValidationFileDtoBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: ValidationFileDto;
}

export class WAccessRequests implements IWAccessRequests {
    wAccessRequestID?: number | undefined;
    firmQFCNo?: string | undefined;
    firmName?: string | undefined;
    firmTypeID?: number;
    firmTypeDesc?: string | undefined;
    contactID?: number;
    individualName?: string | undefined;
    aiNumber?: string | undefined;
    individualJobTitle?: string | undefined;
    individualDateOfBirth?: string | undefined;
    individualNationality?: string | undefined;
    individualEmailAddress?: string | undefined;
    registrationCode?: string | undefined;
    registrationPassword?: string | undefined;
    registrationDate?: string | undefined;
    isRegistered?: boolean;
    createdBy?: number;
    createdDate?: string | undefined;
    accountLocked?: boolean;
    isAccountExpired?: boolean;
    isLoggedIn?: boolean;
    isActiveUser?: boolean;
    isAccountExists?: boolean;
    isValidReqeust?: boolean | undefined;
    wFunctionTypeIDsList?: string | undefined;
    withdrawnFunctionTypeIDsList?: string | undefined;
    wRequestTypeID?: number;
    wRequestTypeDesc?: string | undefined;
    registrationStatus?: string | undefined;
    wUserAccountTypeID?: number;
    wUserAccountTypeDesc?: string | undefined;
    roleId?: number | undefined;
    roleDesc?: string | undefined;
    wUserID?: number | undefined;
    wUserLoginID?: number | undefined;
    isRecordInsert?: boolean;
    isSEF?: boolean;
    isSessionActive?: boolean;
    passwordChangeDate?: Date | undefined;
    userPassword?: string | undefined;
    lstApplicationDetail?: ApplicationDetail[] | undefined;
    wObjectID?: number | undefined;
    wRoleStartDate?: string | undefined;
    lstWUserRoles?: WUserRoles[] | undefined;
    objectID?: number | undefined;

    constructor(data?: IWAccessRequests) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wAccessRequestID = _data["wAccessRequestID"];
            this.firmQFCNo = _data["firmQFCNo"];
            this.firmName = _data["firmName"];
            this.firmTypeID = _data["firmTypeID"];
            this.firmTypeDesc = _data["firmTypeDesc"];
            this.contactID = _data["contactID"];
            this.individualName = _data["individualName"];
            this.aiNumber = _data["aiNumber"];
            this.individualJobTitle = _data["individualJobTitle"];
            this.individualDateOfBirth = _data["individualDateOfBirth"];
            this.individualNationality = _data["individualNationality"];
            this.individualEmailAddress = _data["individualEmailAddress"];
            this.registrationCode = _data["registrationCode"];
            this.registrationPassword = _data["registrationPassword"];
            this.registrationDate = _data["registrationDate"];
            this.isRegistered = _data["isRegistered"];
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"];
            this.accountLocked = _data["accountLocked"];
            this.isAccountExpired = _data["isAccountExpired"];
            this.isLoggedIn = _data["isLoggedIn"];
            this.isActiveUser = _data["isActiveUser"];
            this.isAccountExists = _data["isAccountExists"];
            this.isValidReqeust = _data["isValidReqeust"];
            this.wFunctionTypeIDsList = _data["wFunctionTypeIDsList"];
            this.withdrawnFunctionTypeIDsList = _data["withdrawnFunctionTypeIDsList"];
            this.wRequestTypeID = _data["wRequestTypeID"];
            this.wRequestTypeDesc = _data["wRequestTypeDesc"];
            this.registrationStatus = _data["registrationStatus"];
            this.wUserAccountTypeID = _data["wUserAccountTypeID"];
            this.wUserAccountTypeDesc = _data["wUserAccountTypeDesc"];
            this.roleId = _data["roleId"];
            this.roleDesc = _data["roleDesc"];
            this.wUserID = _data["wUserID"];
            this.wUserLoginID = _data["wUserLoginID"];
            this.isRecordInsert = _data["isRecordInsert"];
            this.isSEF = _data["isSEF"];
            this.isSessionActive = _data["isSessionActive"];
            this.passwordChangeDate = _data["passwordChangeDate"] ? new Date(_data["passwordChangeDate"].toString()) : <any>undefined;
            this.userPassword = _data["userPassword"];
            if (Array.isArray(_data["lstApplicationDetail"])) {
                this.lstApplicationDetail = [] as any;
                for (let item of _data["lstApplicationDetail"])
                    this.lstApplicationDetail!.push(ApplicationDetail.fromJS(item));
            }
            this.wObjectID = _data["wObjectID"];
            this.wRoleStartDate = _data["wRoleStartDate"];
            if (Array.isArray(_data["lstWUserRoles"])) {
                this.lstWUserRoles = [] as any;
                for (let item of _data["lstWUserRoles"])
                    this.lstWUserRoles!.push(WUserRoles.fromJS(item));
            }
            this.objectID = _data["objectID"];
        }
    }

    static fromJS(data: any): WAccessRequests {
        data = typeof data === 'object' ? data : {};
        let result = new WAccessRequests();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wAccessRequestID"] = this.wAccessRequestID;
        data["firmQFCNo"] = this.firmQFCNo;
        data["firmName"] = this.firmName;
        data["firmTypeID"] = this.firmTypeID;
        data["firmTypeDesc"] = this.firmTypeDesc;
        data["contactID"] = this.contactID;
        data["individualName"] = this.individualName;
        data["aiNumber"] = this.aiNumber;
        data["individualJobTitle"] = this.individualJobTitle;
        data["individualDateOfBirth"] = this.individualDateOfBirth;
        data["individualNationality"] = this.individualNationality;
        data["individualEmailAddress"] = this.individualEmailAddress;
        data["registrationCode"] = this.registrationCode;
        data["registrationPassword"] = this.registrationPassword;
        data["registrationDate"] = this.registrationDate;
        data["isRegistered"] = this.isRegistered;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate;
        data["accountLocked"] = this.accountLocked;
        data["isAccountExpired"] = this.isAccountExpired;
        data["isLoggedIn"] = this.isLoggedIn;
        data["isActiveUser"] = this.isActiveUser;
        data["isAccountExists"] = this.isAccountExists;
        data["isValidReqeust"] = this.isValidReqeust;
        data["wFunctionTypeIDsList"] = this.wFunctionTypeIDsList;
        data["withdrawnFunctionTypeIDsList"] = this.withdrawnFunctionTypeIDsList;
        data["wRequestTypeID"] = this.wRequestTypeID;
        data["wRequestTypeDesc"] = this.wRequestTypeDesc;
        data["registrationStatus"] = this.registrationStatus;
        data["wUserAccountTypeID"] = this.wUserAccountTypeID;
        data["wUserAccountTypeDesc"] = this.wUserAccountTypeDesc;
        data["roleId"] = this.roleId;
        data["roleDesc"] = this.roleDesc;
        data["wUserID"] = this.wUserID;
        data["wUserLoginID"] = this.wUserLoginID;
        data["isRecordInsert"] = this.isRecordInsert;
        data["isSEF"] = this.isSEF;
        data["isSessionActive"] = this.isSessionActive;
        data["passwordChangeDate"] = this.passwordChangeDate ? this.passwordChangeDate.toISOString() : <any>undefined;
        data["userPassword"] = this.userPassword;
        if (Array.isArray(this.lstApplicationDetail)) {
            data["lstApplicationDetail"] = [];
            for (let item of this.lstApplicationDetail)
                data["lstApplicationDetail"].push(item.toJSON());
        }
        data["wObjectID"] = this.wObjectID;
        data["wRoleStartDate"] = this.wRoleStartDate;
        if (Array.isArray(this.lstWUserRoles)) {
            data["lstWUserRoles"] = [];
            for (let item of this.lstWUserRoles)
                data["lstWUserRoles"].push(item.toJSON());
        }
        data["objectID"] = this.objectID;
        return data;
    }
}

export interface IWAccessRequests {
    wAccessRequestID?: number | undefined;
    firmQFCNo?: string | undefined;
    firmName?: string | undefined;
    firmTypeID?: number;
    firmTypeDesc?: string | undefined;
    contactID?: number;
    individualName?: string | undefined;
    aiNumber?: string | undefined;
    individualJobTitle?: string | undefined;
    individualDateOfBirth?: string | undefined;
    individualNationality?: string | undefined;
    individualEmailAddress?: string | undefined;
    registrationCode?: string | undefined;
    registrationPassword?: string | undefined;
    registrationDate?: string | undefined;
    isRegistered?: boolean;
    createdBy?: number;
    createdDate?: string | undefined;
    accountLocked?: boolean;
    isAccountExpired?: boolean;
    isLoggedIn?: boolean;
    isActiveUser?: boolean;
    isAccountExists?: boolean;
    isValidReqeust?: boolean | undefined;
    wFunctionTypeIDsList?: string | undefined;
    withdrawnFunctionTypeIDsList?: string | undefined;
    wRequestTypeID?: number;
    wRequestTypeDesc?: string | undefined;
    registrationStatus?: string | undefined;
    wUserAccountTypeID?: number;
    wUserAccountTypeDesc?: string | undefined;
    roleId?: number | undefined;
    roleDesc?: string | undefined;
    wUserID?: number | undefined;
    wUserLoginID?: number | undefined;
    isRecordInsert?: boolean;
    isSEF?: boolean;
    isSessionActive?: boolean;
    passwordChangeDate?: Date | undefined;
    userPassword?: string | undefined;
    lstApplicationDetail?: ApplicationDetail[] | undefined;
    wObjectID?: number | undefined;
    wRoleStartDate?: string | undefined;
    lstWUserRoles?: WUserRoles[] | undefined;
    objectID?: number | undefined;
}

export class WAccessRequestsBaseResponse implements IWAccessRequestsBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: WAccessRequests;

    constructor(data?: IWAccessRequestsBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            this.response = _data["response"] ? WAccessRequests.fromJS(_data["response"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WAccessRequestsBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WAccessRequestsBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWAccessRequestsBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: WAccessRequests;
}

export class WAccessRequestsListBaseResponse implements IWAccessRequestsListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: WAccessRequests[] | undefined;

    constructor(data?: IWAccessRequestsListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["response"])) {
                this.response = [] as any;
                for (let item of _data["response"])
                    this.response!.push(WAccessRequests.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WAccessRequestsListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WAccessRequestsListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.response)) {
            data["response"] = [];
            for (let item of this.response)
                data["response"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWAccessRequestsListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: WAccessRequests[] | undefined;
}

export class WAdminAccessRequestsDto implements IWAdminAccessRequestsDto {
    firmQFCNo?: string | undefined;
    aiNumber?: string | undefined;
    individualEmailAddress?: string | undefined;
    isRegistered?: boolean | undefined;
    roleId?: number | undefined;
    accountLocked?: boolean | undefined;
    isActiveUser?: boolean | undefined;
    isUserAccessAuthorised?: boolean | undefined;
    firmTypeID?: number | undefined;
    wUserID?: number;
    wAccessRequestID?: number;
    individualName?: string | undefined;
    wUserLoginID?: number;
    isAccountExpired?: boolean;
    isLoggedIn?: boolean;
    isSessionActive?: boolean;

    constructor(data?: IWAdminAccessRequestsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmQFCNo = _data["firmQFCNo"];
            this.aiNumber = _data["aiNumber"];
            this.individualEmailAddress = _data["individualEmailAddress"];
            this.isRegistered = _data["isRegistered"];
            this.roleId = _data["roleId"];
            this.accountLocked = _data["accountLocked"];
            this.isActiveUser = _data["isActiveUser"];
            this.isUserAccessAuthorised = _data["isUserAccessAuthorised"];
            this.firmTypeID = _data["firmTypeID"];
            this.wUserID = _data["wUserID"];
            this.wAccessRequestID = _data["wAccessRequestID"];
            this.individualName = _data["individualName"];
            this.wUserLoginID = _data["wUserLoginID"];
            this.isAccountExpired = _data["isAccountExpired"];
            this.isLoggedIn = _data["isLoggedIn"];
            this.isSessionActive = _data["isSessionActive"];
        }
    }

    static fromJS(data: any): WAdminAccessRequestsDto {
        data = typeof data === 'object' ? data : {};
        let result = new WAdminAccessRequestsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmQFCNo"] = this.firmQFCNo;
        data["aiNumber"] = this.aiNumber;
        data["individualEmailAddress"] = this.individualEmailAddress;
        data["isRegistered"] = this.isRegistered;
        data["roleId"] = this.roleId;
        data["accountLocked"] = this.accountLocked;
        data["isActiveUser"] = this.isActiveUser;
        data["isUserAccessAuthorised"] = this.isUserAccessAuthorised;
        data["firmTypeID"] = this.firmTypeID;
        data["wUserID"] = this.wUserID;
        data["wAccessRequestID"] = this.wAccessRequestID;
        data["individualName"] = this.individualName;
        data["wUserLoginID"] = this.wUserLoginID;
        data["isAccountExpired"] = this.isAccountExpired;
        data["isLoggedIn"] = this.isLoggedIn;
        data["isSessionActive"] = this.isSessionActive;
        return data;
    }
}

export interface IWAdminAccessRequestsDto {
    firmQFCNo?: string | undefined;
    aiNumber?: string | undefined;
    individualEmailAddress?: string | undefined;
    isRegistered?: boolean | undefined;
    roleId?: number | undefined;
    accountLocked?: boolean | undefined;
    isActiveUser?: boolean | undefined;
    isUserAccessAuthorised?: boolean | undefined;
    firmTypeID?: number | undefined;
    wUserID?: number;
    wAccessRequestID?: number;
    individualName?: string | undefined;
    wUserLoginID?: number;
    isAccountExpired?: boolean;
    isLoggedIn?: boolean;
    isSessionActive?: boolean;
}

export class WApplicationDetailDto implements IWApplicationDetailDto {
    applicationID?: number | undefined;
    formTypeID?: number | undefined;
    formTypeDesc?: string | undefined;
    qfcNumber?: string | undefined;
    aiNumber?: string | undefined;
    applStatusTypeID?: number | undefined;
    applStatusTypeDesc?: string | undefined;
    arrangementTypeID?: number | undefined;
    arrangementTypeDesc?: string | undefined;
    arrangementTypeOtherDesc?: string | undefined;
    competenciesAndExp?: string | undefined;
    cfExcercisedDesc?: string | undefined;
    currentJobTitle?: string | undefined;
    proposedJobTitle?: string | undefined;
    jobDesc?: string | undefined;
    pastPositionFlag?: boolean | undefined;
    pastPositionDesc?: string | undefined;
    fandPAddnlInfo?: string | undefined;
    fandPChangeDesc?: string | undefined;
    withdrawlReasonDesc?: string | undefined;
    altArrangementDesc?: string | undefined;
    wcfAddnlInfo?: string | undefined;
    residencyNAFlag?: boolean | undefined;
    aliasesNAFlag?: boolean | undefined;
    careerHistoryNAFlag?: boolean | undefined;
    careerHistoryNAReason?: string | undefined;
    reglsNAFlag?: boolean | undefined;
    userId?: number | undefined;
    createdDate?: string | undefined;
    userModified?: number | undefined;
    modifiedDate?: string | undefined;
    reasonForDelayInFiling?: string | undefined;
    supervisingFlag?: boolean | undefined;
    isOrdinarilyResidentFlag?: boolean | undefined;
    proposedRelocationDateDay?: number | undefined;
    proposedRelocationDateMonth?: number | undefined;
    proposedRelocationDateYear?: number | undefined;
    applicationDate?: string | undefined;
    appCreatedBy?: number;

    constructor(data?: IWApplicationDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationID = _data["applicationID"];
            this.formTypeID = _data["formTypeID"];
            this.formTypeDesc = _data["formTypeDesc"];
            this.qfcNumber = _data["qfcNumber"];
            this.aiNumber = _data["aiNumber"];
            this.applStatusTypeID = _data["applStatusTypeID"];
            this.applStatusTypeDesc = _data["applStatusTypeDesc"];
            this.arrangementTypeID = _data["arrangementTypeID"];
            this.arrangementTypeDesc = _data["arrangementTypeDesc"];
            this.arrangementTypeOtherDesc = _data["arrangementTypeOtherDesc"];
            this.competenciesAndExp = _data["competenciesAndExp"];
            this.cfExcercisedDesc = _data["cfExcercisedDesc"];
            this.currentJobTitle = _data["currentJobTitle"];
            this.proposedJobTitle = _data["proposedJobTitle"];
            this.jobDesc = _data["jobDesc"];
            this.pastPositionFlag = _data["pastPositionFlag"];
            this.pastPositionDesc = _data["pastPositionDesc"];
            this.fandPAddnlInfo = _data["fandPAddnlInfo"];
            this.fandPChangeDesc = _data["fandPChangeDesc"];
            this.withdrawlReasonDesc = _data["withdrawlReasonDesc"];
            this.altArrangementDesc = _data["altArrangementDesc"];
            this.wcfAddnlInfo = _data["wcfAddnlInfo"];
            this.residencyNAFlag = _data["residencyNAFlag"];
            this.aliasesNAFlag = _data["aliasesNAFlag"];
            this.careerHistoryNAFlag = _data["careerHistoryNAFlag"];
            this.careerHistoryNAReason = _data["careerHistoryNAReason"];
            this.reglsNAFlag = _data["reglsNAFlag"];
            this.userId = _data["userId"];
            this.createdDate = _data["createdDate"];
            this.userModified = _data["userModified"];
            this.modifiedDate = _data["modifiedDate"];
            this.reasonForDelayInFiling = _data["reasonForDelayInFiling"];
            this.supervisingFlag = _data["supervisingFlag"];
            this.isOrdinarilyResidentFlag = _data["isOrdinarilyResidentFlag"];
            this.proposedRelocationDateDay = _data["proposedRelocationDateDay"];
            this.proposedRelocationDateMonth = _data["proposedRelocationDateMonth"];
            this.proposedRelocationDateYear = _data["proposedRelocationDateYear"];
            this.applicationDate = _data["applicationDate"];
            this.appCreatedBy = _data["appCreatedBy"];
        }
    }

    static fromJS(data: any): WApplicationDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new WApplicationDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicationID"] = this.applicationID;
        data["formTypeID"] = this.formTypeID;
        data["formTypeDesc"] = this.formTypeDesc;
        data["qfcNumber"] = this.qfcNumber;
        data["aiNumber"] = this.aiNumber;
        data["applStatusTypeID"] = this.applStatusTypeID;
        data["applStatusTypeDesc"] = this.applStatusTypeDesc;
        data["arrangementTypeID"] = this.arrangementTypeID;
        data["arrangementTypeDesc"] = this.arrangementTypeDesc;
        data["arrangementTypeOtherDesc"] = this.arrangementTypeOtherDesc;
        data["competenciesAndExp"] = this.competenciesAndExp;
        data["cfExcercisedDesc"] = this.cfExcercisedDesc;
        data["currentJobTitle"] = this.currentJobTitle;
        data["proposedJobTitle"] = this.proposedJobTitle;
        data["jobDesc"] = this.jobDesc;
        data["pastPositionFlag"] = this.pastPositionFlag;
        data["pastPositionDesc"] = this.pastPositionDesc;
        data["fandPAddnlInfo"] = this.fandPAddnlInfo;
        data["fandPChangeDesc"] = this.fandPChangeDesc;
        data["withdrawlReasonDesc"] = this.withdrawlReasonDesc;
        data["altArrangementDesc"] = this.altArrangementDesc;
        data["wcfAddnlInfo"] = this.wcfAddnlInfo;
        data["residencyNAFlag"] = this.residencyNAFlag;
        data["aliasesNAFlag"] = this.aliasesNAFlag;
        data["careerHistoryNAFlag"] = this.careerHistoryNAFlag;
        data["careerHistoryNAReason"] = this.careerHistoryNAReason;
        data["reglsNAFlag"] = this.reglsNAFlag;
        data["userId"] = this.userId;
        data["createdDate"] = this.createdDate;
        data["userModified"] = this.userModified;
        data["modifiedDate"] = this.modifiedDate;
        data["reasonForDelayInFiling"] = this.reasonForDelayInFiling;
        data["supervisingFlag"] = this.supervisingFlag;
        data["isOrdinarilyResidentFlag"] = this.isOrdinarilyResidentFlag;
        data["proposedRelocationDateDay"] = this.proposedRelocationDateDay;
        data["proposedRelocationDateMonth"] = this.proposedRelocationDateMonth;
        data["proposedRelocationDateYear"] = this.proposedRelocationDateYear;
        data["applicationDate"] = this.applicationDate;
        data["appCreatedBy"] = this.appCreatedBy;
        return data;
    }
}

export interface IWApplicationDetailDto {
    applicationID?: number | undefined;
    formTypeID?: number | undefined;
    formTypeDesc?: string | undefined;
    qfcNumber?: string | undefined;
    aiNumber?: string | undefined;
    applStatusTypeID?: number | undefined;
    applStatusTypeDesc?: string | undefined;
    arrangementTypeID?: number | undefined;
    arrangementTypeDesc?: string | undefined;
    arrangementTypeOtherDesc?: string | undefined;
    competenciesAndExp?: string | undefined;
    cfExcercisedDesc?: string | undefined;
    currentJobTitle?: string | undefined;
    proposedJobTitle?: string | undefined;
    jobDesc?: string | undefined;
    pastPositionFlag?: boolean | undefined;
    pastPositionDesc?: string | undefined;
    fandPAddnlInfo?: string | undefined;
    fandPChangeDesc?: string | undefined;
    withdrawlReasonDesc?: string | undefined;
    altArrangementDesc?: string | undefined;
    wcfAddnlInfo?: string | undefined;
    residencyNAFlag?: boolean | undefined;
    aliasesNAFlag?: boolean | undefined;
    careerHistoryNAFlag?: boolean | undefined;
    careerHistoryNAReason?: string | undefined;
    reglsNAFlag?: boolean | undefined;
    userId?: number | undefined;
    createdDate?: string | undefined;
    userModified?: number | undefined;
    modifiedDate?: string | undefined;
    reasonForDelayInFiling?: string | undefined;
    supervisingFlag?: boolean | undefined;
    isOrdinarilyResidentFlag?: boolean | undefined;
    proposedRelocationDateDay?: number | undefined;
    proposedRelocationDateMonth?: number | undefined;
    proposedRelocationDateYear?: number | undefined;
    applicationDate?: string | undefined;
    appCreatedBy?: number;
}

export class WApplicationDetailDtoListBaseResponse implements IWApplicationDetailDtoListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: WApplicationDetailDto[] | undefined;

    constructor(data?: IWApplicationDetailDtoListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["response"])) {
                this.response = [] as any;
                for (let item of _data["response"])
                    this.response!.push(WApplicationDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WApplicationDetailDtoListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WApplicationDetailDtoListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.response)) {
            data["response"] = [];
            for (let item of this.response)
                data["response"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWApplicationDetailDtoListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: WApplicationDetailDto[] | undefined;
}

export class WFirmNoticeResponseItems implements IWFirmNoticeResponseItems {
    wNoticeID?: number;
    wSourceNoticeID?: number;
    wFirmNoticeID?: number | undefined;
    wSourceFirmNoticeID?: number;
    wqfcNumber?: string | undefined;
    wObjectSOStatusID?: number | undefined;
    wNotes?: string | undefined;
    createdBy?: number;
    lstWFirmNoticeResponseItems?: WFirmNoticeResponseItems[] | undefined;
    wNoticeResponseItemID?: number;
    wNoticeQuestionnaireItemID?: number;
    wSourceNoticeQuestionnaireItemID?: number;
    wExplanation?: string | undefined;
    wExplanationReqdCriteriaMet?: boolean;
    lstWFirmNoticeResponseValues?: WFirmNoticeResponseValues[] | undefined;

    constructor(data?: IWFirmNoticeResponseItems) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wNoticeID = _data["wNoticeID"];
            this.wSourceNoticeID = _data["wSourceNoticeID"];
            this.wFirmNoticeID = _data["wFirmNoticeID"];
            this.wSourceFirmNoticeID = _data["wSourceFirmNoticeID"];
            this.wqfcNumber = _data["wqfcNumber"];
            this.wObjectSOStatusID = _data["wObjectSOStatusID"];
            this.wNotes = _data["wNotes"];
            this.createdBy = _data["createdBy"];
            if (Array.isArray(_data["lstWFirmNoticeResponseItems"])) {
                this.lstWFirmNoticeResponseItems = [] as any;
                for (let item of _data["lstWFirmNoticeResponseItems"])
                    this.lstWFirmNoticeResponseItems!.push(WFirmNoticeResponseItems.fromJS(item));
            }
            this.wNoticeResponseItemID = _data["wNoticeResponseItemID"];
            this.wNoticeQuestionnaireItemID = _data["wNoticeQuestionnaireItemID"];
            this.wSourceNoticeQuestionnaireItemID = _data["wSourceNoticeQuestionnaireItemID"];
            this.wExplanation = _data["wExplanation"];
            this.wExplanationReqdCriteriaMet = _data["wExplanationReqdCriteriaMet"];
            if (Array.isArray(_data["lstWFirmNoticeResponseValues"])) {
                this.lstWFirmNoticeResponseValues = [] as any;
                for (let item of _data["lstWFirmNoticeResponseValues"])
                    this.lstWFirmNoticeResponseValues!.push(WFirmNoticeResponseValues.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WFirmNoticeResponseItems {
        data = typeof data === 'object' ? data : {};
        let result = new WFirmNoticeResponseItems();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wNoticeID"] = this.wNoticeID;
        data["wSourceNoticeID"] = this.wSourceNoticeID;
        data["wFirmNoticeID"] = this.wFirmNoticeID;
        data["wSourceFirmNoticeID"] = this.wSourceFirmNoticeID;
        data["wqfcNumber"] = this.wqfcNumber;
        data["wObjectSOStatusID"] = this.wObjectSOStatusID;
        data["wNotes"] = this.wNotes;
        data["createdBy"] = this.createdBy;
        if (Array.isArray(this.lstWFirmNoticeResponseItems)) {
            data["lstWFirmNoticeResponseItems"] = [];
            for (let item of this.lstWFirmNoticeResponseItems)
                data["lstWFirmNoticeResponseItems"].push(item.toJSON());
        }
        data["wNoticeResponseItemID"] = this.wNoticeResponseItemID;
        data["wNoticeQuestionnaireItemID"] = this.wNoticeQuestionnaireItemID;
        data["wSourceNoticeQuestionnaireItemID"] = this.wSourceNoticeQuestionnaireItemID;
        data["wExplanation"] = this.wExplanation;
        data["wExplanationReqdCriteriaMet"] = this.wExplanationReqdCriteriaMet;
        if (Array.isArray(this.lstWFirmNoticeResponseValues)) {
            data["lstWFirmNoticeResponseValues"] = [];
            for (let item of this.lstWFirmNoticeResponseValues)
                data["lstWFirmNoticeResponseValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWFirmNoticeResponseItems {
    wNoticeID?: number;
    wSourceNoticeID?: number;
    wFirmNoticeID?: number | undefined;
    wSourceFirmNoticeID?: number;
    wqfcNumber?: string | undefined;
    wObjectSOStatusID?: number | undefined;
    wNotes?: string | undefined;
    createdBy?: number;
    lstWFirmNoticeResponseItems?: WFirmNoticeResponseItems[] | undefined;
    wNoticeResponseItemID?: number;
    wNoticeQuestionnaireItemID?: number;
    wSourceNoticeQuestionnaireItemID?: number;
    wExplanation?: string | undefined;
    wExplanationReqdCriteriaMet?: boolean;
    lstWFirmNoticeResponseValues?: WFirmNoticeResponseValues[] | undefined;
}

export class WFirmNoticeResponseValues implements IWFirmNoticeResponseValues {
    wNoticeID?: number;
    wSourceNoticeID?: number;
    wFirmNoticeID?: number | undefined;
    wSourceFirmNoticeID?: number;
    wqfcNumber?: string | undefined;
    wObjectSOStatusID?: number | undefined;
    wNotes?: string | undefined;
    createdBy?: number;
    lstWFirmNoticeResponseItems?: WFirmNoticeResponseItems[] | undefined;
    wNoticeResponseItemID?: number;
    wNoticeQuestionnaireItemID?: number;
    wSourceNoticeQuestionnaireItemID?: number;
    wExplanation?: string | undefined;
    wExplanationReqdCriteriaMet?: boolean;
    lstWFirmNoticeResponseValues?: WFirmNoticeResponseValues[] | undefined;
    wNoticeResponseValueID?: number;
    wResponse?: string | undefined;
    wListValueID?: number | undefined;

    constructor(data?: IWFirmNoticeResponseValues) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wNoticeID = _data["wNoticeID"];
            this.wSourceNoticeID = _data["wSourceNoticeID"];
            this.wFirmNoticeID = _data["wFirmNoticeID"];
            this.wSourceFirmNoticeID = _data["wSourceFirmNoticeID"];
            this.wqfcNumber = _data["wqfcNumber"];
            this.wObjectSOStatusID = _data["wObjectSOStatusID"];
            this.wNotes = _data["wNotes"];
            this.createdBy = _data["createdBy"];
            if (Array.isArray(_data["lstWFirmNoticeResponseItems"])) {
                this.lstWFirmNoticeResponseItems = [] as any;
                for (let item of _data["lstWFirmNoticeResponseItems"])
                    this.lstWFirmNoticeResponseItems!.push(WFirmNoticeResponseItems.fromJS(item));
            }
            this.wNoticeResponseItemID = _data["wNoticeResponseItemID"];
            this.wNoticeQuestionnaireItemID = _data["wNoticeQuestionnaireItemID"];
            this.wSourceNoticeQuestionnaireItemID = _data["wSourceNoticeQuestionnaireItemID"];
            this.wExplanation = _data["wExplanation"];
            this.wExplanationReqdCriteriaMet = _data["wExplanationReqdCriteriaMet"];
            if (Array.isArray(_data["lstWFirmNoticeResponseValues"])) {
                this.lstWFirmNoticeResponseValues = [] as any;
                for (let item of _data["lstWFirmNoticeResponseValues"])
                    this.lstWFirmNoticeResponseValues!.push(WFirmNoticeResponseValues.fromJS(item));
            }
            this.wNoticeResponseValueID = _data["wNoticeResponseValueID"];
            this.wResponse = _data["wResponse"];
            this.wListValueID = _data["wListValueID"];
        }
    }

    static fromJS(data: any): WFirmNoticeResponseValues {
        data = typeof data === 'object' ? data : {};
        let result = new WFirmNoticeResponseValues();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wNoticeID"] = this.wNoticeID;
        data["wSourceNoticeID"] = this.wSourceNoticeID;
        data["wFirmNoticeID"] = this.wFirmNoticeID;
        data["wSourceFirmNoticeID"] = this.wSourceFirmNoticeID;
        data["wqfcNumber"] = this.wqfcNumber;
        data["wObjectSOStatusID"] = this.wObjectSOStatusID;
        data["wNotes"] = this.wNotes;
        data["createdBy"] = this.createdBy;
        if (Array.isArray(this.lstWFirmNoticeResponseItems)) {
            data["lstWFirmNoticeResponseItems"] = [];
            for (let item of this.lstWFirmNoticeResponseItems)
                data["lstWFirmNoticeResponseItems"].push(item.toJSON());
        }
        data["wNoticeResponseItemID"] = this.wNoticeResponseItemID;
        data["wNoticeQuestionnaireItemID"] = this.wNoticeQuestionnaireItemID;
        data["wSourceNoticeQuestionnaireItemID"] = this.wSourceNoticeQuestionnaireItemID;
        data["wExplanation"] = this.wExplanation;
        data["wExplanationReqdCriteriaMet"] = this.wExplanationReqdCriteriaMet;
        if (Array.isArray(this.lstWFirmNoticeResponseValues)) {
            data["lstWFirmNoticeResponseValues"] = [];
            for (let item of this.lstWFirmNoticeResponseValues)
                data["lstWFirmNoticeResponseValues"].push(item.toJSON());
        }
        data["wNoticeResponseValueID"] = this.wNoticeResponseValueID;
        data["wResponse"] = this.wResponse;
        data["wListValueID"] = this.wListValueID;
        return data;
    }
}

export interface IWFirmNoticeResponseValues {
    wNoticeID?: number;
    wSourceNoticeID?: number;
    wFirmNoticeID?: number | undefined;
    wSourceFirmNoticeID?: number;
    wqfcNumber?: string | undefined;
    wObjectSOStatusID?: number | undefined;
    wNotes?: string | undefined;
    createdBy?: number;
    lstWFirmNoticeResponseItems?: WFirmNoticeResponseItems[] | undefined;
    wNoticeResponseItemID?: number;
    wNoticeQuestionnaireItemID?: number;
    wSourceNoticeQuestionnaireItemID?: number;
    wExplanation?: string | undefined;
    wExplanationReqdCriteriaMet?: boolean;
    lstWFirmNoticeResponseValues?: WFirmNoticeResponseValues[] | undefined;
    wNoticeResponseValueID?: number;
    wResponse?: string | undefined;
    wListValueID?: number | undefined;
}

export class WFirmNotices implements IWFirmNotices {
    wNoticeID?: number;
    wSourceNoticeID?: number;
    wFirmNoticeID?: number | undefined;
    wSourceFirmNoticeID?: number;
    wqfcNumber?: string | undefined;
    wObjectSOStatusID?: number | undefined;
    wNotes?: string | undefined;
    createdBy?: number;
    lstWFirmNoticeResponseItems?: WFirmNoticeResponseItems[] | undefined;

    constructor(data?: IWFirmNotices) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wNoticeID = _data["wNoticeID"];
            this.wSourceNoticeID = _data["wSourceNoticeID"];
            this.wFirmNoticeID = _data["wFirmNoticeID"];
            this.wSourceFirmNoticeID = _data["wSourceFirmNoticeID"];
            this.wqfcNumber = _data["wqfcNumber"];
            this.wObjectSOStatusID = _data["wObjectSOStatusID"];
            this.wNotes = _data["wNotes"];
            this.createdBy = _data["createdBy"];
            if (Array.isArray(_data["lstWFirmNoticeResponseItems"])) {
                this.lstWFirmNoticeResponseItems = [] as any;
                for (let item of _data["lstWFirmNoticeResponseItems"])
                    this.lstWFirmNoticeResponseItems!.push(WFirmNoticeResponseItems.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WFirmNotices {
        data = typeof data === 'object' ? data : {};
        let result = new WFirmNotices();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wNoticeID"] = this.wNoticeID;
        data["wSourceNoticeID"] = this.wSourceNoticeID;
        data["wFirmNoticeID"] = this.wFirmNoticeID;
        data["wSourceFirmNoticeID"] = this.wSourceFirmNoticeID;
        data["wqfcNumber"] = this.wqfcNumber;
        data["wObjectSOStatusID"] = this.wObjectSOStatusID;
        data["wNotes"] = this.wNotes;
        data["createdBy"] = this.createdBy;
        if (Array.isArray(this.lstWFirmNoticeResponseItems)) {
            data["lstWFirmNoticeResponseItems"] = [];
            for (let item of this.lstWFirmNoticeResponseItems)
                data["lstWFirmNoticeResponseItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWFirmNotices {
    wNoticeID?: number;
    wSourceNoticeID?: number;
    wFirmNoticeID?: number | undefined;
    wSourceFirmNoticeID?: number;
    wqfcNumber?: string | undefined;
    wObjectSOStatusID?: number | undefined;
    wNotes?: string | undefined;
    createdBy?: number;
    lstWFirmNoticeResponseItems?: WFirmNoticeResponseItems[] | undefined;
}

export class WIndFormType implements IWIndFormType {
    wIndFormTypeID?: number | undefined;
    wDocTypeID?: number | undefined;

    constructor(data?: IWIndFormType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wIndFormTypeID = _data["wIndFormTypeID"];
            this.wDocTypeID = _data["wDocTypeID"];
        }
    }

    static fromJS(data: any): WIndFormType {
        data = typeof data === 'object' ? data : {};
        let result = new WIndFormType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wIndFormTypeID"] = this.wIndFormTypeID;
        data["wDocTypeID"] = this.wDocTypeID;
        return data;
    }
}

export interface IWIndFormType {
    wIndFormTypeID?: number | undefined;
    wDocTypeID?: number | undefined;
}

export class WIndFormTypeBaseResponse implements IWIndFormTypeBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: WIndFormType;

    constructor(data?: IWIndFormTypeBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            this.response = _data["response"] ? WIndFormType.fromJS(_data["response"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WIndFormTypeBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WIndFormTypeBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWIndFormTypeBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: WIndFormType;
}

export class WNotice implements IWNotice {
    wNoticeID?: number | undefined;
    wFirmNoticeID?: number;
    wSourceNoticeID?: number;
    wNoticeTypeID?: number;
    wNoticeTypeDesc?: string | undefined;
    wNoticeName?: string | undefined;
    wReferenceNumber?: string | undefined;
    wcmsReferenceNumber?: string | undefined;
    wIssuersReferenceNumber?: string | undefined;
    wNoticeIssuerID?: number | undefined;
    wOtherNoticeIssuer?: string | undefined;
    wNoticeIssuedDate?: string | undefined;
    wSubject?: string | undefined;
    wReferences?: string | undefined;
    wLinkToNotice?: string | undefined;
    wNotificationSentDate?: string | undefined;
    wEmailNotificationContent?: string | undefined;
    wCreatedBy?: number;
    wNoticeIssuerShortName?: string | undefined;
    wResponseRequired?: boolean;
    wNoticeEmail?: string | undefined;
    wPublishOnESS?: boolean;
    wObjectSOStatusID?: number | undefined;
    wNotes?: string | undefined;
    wResponseDueDate?: string | undefined;
    wRespondentTypeID?: number | undefined;
    wRespondentsControlledFunctionTypeIDs?: string | undefined;
    wRespondentsDNFBPFunctionTypeIDs?: string | undefined;
    wNoticeSignOffText?: string | undefined;
    objNoticeQuestionnaire?: WNoticeQuestionnaire;

    constructor(data?: IWNotice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wNoticeID = _data["wNoticeID"];
            this.wFirmNoticeID = _data["wFirmNoticeID"];
            this.wSourceNoticeID = _data["wSourceNoticeID"];
            this.wNoticeTypeID = _data["wNoticeTypeID"];
            this.wNoticeTypeDesc = _data["wNoticeTypeDesc"];
            this.wNoticeName = _data["wNoticeName"];
            this.wReferenceNumber = _data["wReferenceNumber"];
            this.wcmsReferenceNumber = _data["wcmsReferenceNumber"];
            this.wIssuersReferenceNumber = _data["wIssuersReferenceNumber"];
            this.wNoticeIssuerID = _data["wNoticeIssuerID"];
            this.wOtherNoticeIssuer = _data["wOtherNoticeIssuer"];
            this.wNoticeIssuedDate = _data["wNoticeIssuedDate"];
            this.wSubject = _data["wSubject"];
            this.wReferences = _data["wReferences"];
            this.wLinkToNotice = _data["wLinkToNotice"];
            this.wNotificationSentDate = _data["wNotificationSentDate"];
            this.wEmailNotificationContent = _data["wEmailNotificationContent"];
            this.wCreatedBy = _data["wCreatedBy"];
            this.wNoticeIssuerShortName = _data["wNoticeIssuerShortName"];
            this.wResponseRequired = _data["wResponseRequired"];
            this.wNoticeEmail = _data["wNoticeEmail"];
            this.wPublishOnESS = _data["wPublishOnESS"];
            this.wObjectSOStatusID = _data["wObjectSOStatusID"];
            this.wNotes = _data["wNotes"];
            this.wResponseDueDate = _data["wResponseDueDate"];
            this.wRespondentTypeID = _data["wRespondentTypeID"];
            this.wRespondentsControlledFunctionTypeIDs = _data["wRespondentsControlledFunctionTypeIDs"];
            this.wRespondentsDNFBPFunctionTypeIDs = _data["wRespondentsDNFBPFunctionTypeIDs"];
            this.wNoticeSignOffText = _data["wNoticeSignOffText"];
            this.objNoticeQuestionnaire = _data["objNoticeQuestionnaire"] ? WNoticeQuestionnaire.fromJS(_data["objNoticeQuestionnaire"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WNotice {
        data = typeof data === 'object' ? data : {};
        let result = new WNotice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wNoticeID"] = this.wNoticeID;
        data["wFirmNoticeID"] = this.wFirmNoticeID;
        data["wSourceNoticeID"] = this.wSourceNoticeID;
        data["wNoticeTypeID"] = this.wNoticeTypeID;
        data["wNoticeTypeDesc"] = this.wNoticeTypeDesc;
        data["wNoticeName"] = this.wNoticeName;
        data["wReferenceNumber"] = this.wReferenceNumber;
        data["wcmsReferenceNumber"] = this.wcmsReferenceNumber;
        data["wIssuersReferenceNumber"] = this.wIssuersReferenceNumber;
        data["wNoticeIssuerID"] = this.wNoticeIssuerID;
        data["wOtherNoticeIssuer"] = this.wOtherNoticeIssuer;
        data["wNoticeIssuedDate"] = this.wNoticeIssuedDate;
        data["wSubject"] = this.wSubject;
        data["wReferences"] = this.wReferences;
        data["wLinkToNotice"] = this.wLinkToNotice;
        data["wNotificationSentDate"] = this.wNotificationSentDate;
        data["wEmailNotificationContent"] = this.wEmailNotificationContent;
        data["wCreatedBy"] = this.wCreatedBy;
        data["wNoticeIssuerShortName"] = this.wNoticeIssuerShortName;
        data["wResponseRequired"] = this.wResponseRequired;
        data["wNoticeEmail"] = this.wNoticeEmail;
        data["wPublishOnESS"] = this.wPublishOnESS;
        data["wObjectSOStatusID"] = this.wObjectSOStatusID;
        data["wNotes"] = this.wNotes;
        data["wResponseDueDate"] = this.wResponseDueDate;
        data["wRespondentTypeID"] = this.wRespondentTypeID;
        data["wRespondentsControlledFunctionTypeIDs"] = this.wRespondentsControlledFunctionTypeIDs;
        data["wRespondentsDNFBPFunctionTypeIDs"] = this.wRespondentsDNFBPFunctionTypeIDs;
        data["wNoticeSignOffText"] = this.wNoticeSignOffText;
        data["objNoticeQuestionnaire"] = this.objNoticeQuestionnaire ? this.objNoticeQuestionnaire.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWNotice {
    wNoticeID?: number | undefined;
    wFirmNoticeID?: number;
    wSourceNoticeID?: number;
    wNoticeTypeID?: number;
    wNoticeTypeDesc?: string | undefined;
    wNoticeName?: string | undefined;
    wReferenceNumber?: string | undefined;
    wcmsReferenceNumber?: string | undefined;
    wIssuersReferenceNumber?: string | undefined;
    wNoticeIssuerID?: number | undefined;
    wOtherNoticeIssuer?: string | undefined;
    wNoticeIssuedDate?: string | undefined;
    wSubject?: string | undefined;
    wReferences?: string | undefined;
    wLinkToNotice?: string | undefined;
    wNotificationSentDate?: string | undefined;
    wEmailNotificationContent?: string | undefined;
    wCreatedBy?: number;
    wNoticeIssuerShortName?: string | undefined;
    wResponseRequired?: boolean;
    wNoticeEmail?: string | undefined;
    wPublishOnESS?: boolean;
    wObjectSOStatusID?: number | undefined;
    wNotes?: string | undefined;
    wResponseDueDate?: string | undefined;
    wRespondentTypeID?: number | undefined;
    wRespondentsControlledFunctionTypeIDs?: string | undefined;
    wRespondentsDNFBPFunctionTypeIDs?: string | undefined;
    wNoticeSignOffText?: string | undefined;
    objNoticeQuestionnaire?: WNoticeQuestionnaire;
}

export class WNoticeBaseResponse implements IWNoticeBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: WNotice;

    constructor(data?: IWNoticeBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            this.response = _data["response"] ? WNotice.fromJS(_data["response"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WNoticeBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WNoticeBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWNoticeBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: WNotice;
}

export class WNoticeDto implements IWNoticeDto {
    wNoticeID?: number | undefined;
    wSourceNoticeID?: number | undefined;
    wNoticeTypeID?: number | undefined;
    wNoticeName?: string | undefined;
    wReferenceNumber?: string | undefined;
    wcmsReferenceNumber?: string | undefined;
    wIssuersReferenceNumber?: string | undefined;
    wNoticeIssuerID?: number | undefined;
    wOtherNoticeIssuer?: string | undefined;
    wNoticeIssuedDate?: string | undefined;
    wSubject?: string | undefined;
    wReferences?: string | undefined;
    wLinkToNotice?: string | undefined;
    wNotificationSentDate?: string | undefined;
    wNoticeEmail?: string | undefined;
    wPublishOnESS?: boolean | undefined;
    wCreatedBy?: number | undefined;
    wResponseRequired?: boolean | undefined;
    objNoticeQuestionnaire?: WNoticeQuestionnaireDto;

    constructor(data?: IWNoticeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wNoticeID = _data["wNoticeID"];
            this.wSourceNoticeID = _data["wSourceNoticeID"];
            this.wNoticeTypeID = _data["wNoticeTypeID"];
            this.wNoticeName = _data["wNoticeName"];
            this.wReferenceNumber = _data["wReferenceNumber"];
            this.wcmsReferenceNumber = _data["wcmsReferenceNumber"];
            this.wIssuersReferenceNumber = _data["wIssuersReferenceNumber"];
            this.wNoticeIssuerID = _data["wNoticeIssuerID"];
            this.wOtherNoticeIssuer = _data["wOtherNoticeIssuer"];
            this.wNoticeIssuedDate = _data["wNoticeIssuedDate"];
            this.wSubject = _data["wSubject"];
            this.wReferences = _data["wReferences"];
            this.wLinkToNotice = _data["wLinkToNotice"];
            this.wNotificationSentDate = _data["wNotificationSentDate"];
            this.wNoticeEmail = _data["wNoticeEmail"];
            this.wPublishOnESS = _data["wPublishOnESS"];
            this.wCreatedBy = _data["wCreatedBy"];
            this.wResponseRequired = _data["wResponseRequired"];
            this.objNoticeQuestionnaire = _data["objNoticeQuestionnaire"] ? WNoticeQuestionnaireDto.fromJS(_data["objNoticeQuestionnaire"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WNoticeDto {
        data = typeof data === 'object' ? data : {};
        let result = new WNoticeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wNoticeID"] = this.wNoticeID;
        data["wSourceNoticeID"] = this.wSourceNoticeID;
        data["wNoticeTypeID"] = this.wNoticeTypeID;
        data["wNoticeName"] = this.wNoticeName;
        data["wReferenceNumber"] = this.wReferenceNumber;
        data["wcmsReferenceNumber"] = this.wcmsReferenceNumber;
        data["wIssuersReferenceNumber"] = this.wIssuersReferenceNumber;
        data["wNoticeIssuerID"] = this.wNoticeIssuerID;
        data["wOtherNoticeIssuer"] = this.wOtherNoticeIssuer;
        data["wNoticeIssuedDate"] = this.wNoticeIssuedDate;
        data["wSubject"] = this.wSubject;
        data["wReferences"] = this.wReferences;
        data["wLinkToNotice"] = this.wLinkToNotice;
        data["wNotificationSentDate"] = this.wNotificationSentDate;
        data["wNoticeEmail"] = this.wNoticeEmail;
        data["wPublishOnESS"] = this.wPublishOnESS;
        data["wCreatedBy"] = this.wCreatedBy;
        data["wResponseRequired"] = this.wResponseRequired;
        data["objNoticeQuestionnaire"] = this.objNoticeQuestionnaire ? this.objNoticeQuestionnaire.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWNoticeDto {
    wNoticeID?: number | undefined;
    wSourceNoticeID?: number | undefined;
    wNoticeTypeID?: number | undefined;
    wNoticeName?: string | undefined;
    wReferenceNumber?: string | undefined;
    wcmsReferenceNumber?: string | undefined;
    wIssuersReferenceNumber?: string | undefined;
    wNoticeIssuerID?: number | undefined;
    wOtherNoticeIssuer?: string | undefined;
    wNoticeIssuedDate?: string | undefined;
    wSubject?: string | undefined;
    wReferences?: string | undefined;
    wLinkToNotice?: string | undefined;
    wNotificationSentDate?: string | undefined;
    wNoticeEmail?: string | undefined;
    wPublishOnESS?: boolean | undefined;
    wCreatedBy?: number | undefined;
    wResponseRequired?: boolean | undefined;
    objNoticeQuestionnaire?: WNoticeQuestionnaireDto;
}

export class WNoticeDtoBaseResponse implements IWNoticeDtoBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: WNoticeDto;

    constructor(data?: IWNoticeDtoBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            this.response = _data["response"] ? WNoticeDto.fromJS(_data["response"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WNoticeDtoBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WNoticeDtoBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWNoticeDtoBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: WNoticeDto;
}

export class WNoticeList implements IWNoticeList {
    wNoticeID?: number | undefined;
    wFirmNoticeID?: number;
    wSourceNoticeID?: number;
    wNoticeTypeID?: number;
    wNoticeTypeDesc?: string | undefined;
    wNoticeName?: string | undefined;
    wReferenceNumber?: string | undefined;
    wcmsReferenceNumber?: string | undefined;
    wIssuersReferenceNumber?: string | undefined;
    wNoticeIssuerID?: number | undefined;
    wOtherNoticeIssuer?: string | undefined;
    wNoticeIssuedDate?: string | undefined;
    wSubject?: string | undefined;
    wReferences?: string | undefined;
    wLinkToNotice?: string | undefined;
    wNotificationSentDate?: string | undefined;
    wEmailNotificationContent?: string | undefined;
    wCreatedBy?: number;
    wNoticeIssuerShortName?: string | undefined;
    wResponseRequired?: boolean;
    wNoticeEmail?: string | undefined;
    wPublishOnESS?: boolean;
    wObjectSOStatusID?: number | undefined;
    wNotes?: string | undefined;
    wResponseDueDate?: string | undefined;
    wRespondentTypeID?: number | undefined;
    wRespondentsControlledFunctionTypeIDs?: string | undefined;
    wRespondentsDNFBPFunctionTypeIDs?: string | undefined;
    wNoticeSignOffText?: string | undefined;
    objNoticeQuestionnaire?: WNoticeQuestionnaire;
    noticeType?: string | undefined;
    noticeTemplate?: string | undefined;
    noticeNumber?: string | undefined;
    noticeDate?: string | undefined;
    issuer?: string | undefined;
    responseRequired?: string | undefined;
    published?: string | undefined;
    responseDueDate?: string | undefined;
    responseProvidedDate?: string | undefined;
    responseSignedBy?: string | undefined;
    resoponseType?: string | undefined;
    wsosStatusTypeID?: number | undefined;

    constructor(data?: IWNoticeList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wNoticeID = _data["wNoticeID"];
            this.wFirmNoticeID = _data["wFirmNoticeID"];
            this.wSourceNoticeID = _data["wSourceNoticeID"];
            this.wNoticeTypeID = _data["wNoticeTypeID"];
            this.wNoticeTypeDesc = _data["wNoticeTypeDesc"];
            this.wNoticeName = _data["wNoticeName"];
            this.wReferenceNumber = _data["wReferenceNumber"];
            this.wcmsReferenceNumber = _data["wcmsReferenceNumber"];
            this.wIssuersReferenceNumber = _data["wIssuersReferenceNumber"];
            this.wNoticeIssuerID = _data["wNoticeIssuerID"];
            this.wOtherNoticeIssuer = _data["wOtherNoticeIssuer"];
            this.wNoticeIssuedDate = _data["wNoticeIssuedDate"];
            this.wSubject = _data["wSubject"];
            this.wReferences = _data["wReferences"];
            this.wLinkToNotice = _data["wLinkToNotice"];
            this.wNotificationSentDate = _data["wNotificationSentDate"];
            this.wEmailNotificationContent = _data["wEmailNotificationContent"];
            this.wCreatedBy = _data["wCreatedBy"];
            this.wNoticeIssuerShortName = _data["wNoticeIssuerShortName"];
            this.wResponseRequired = _data["wResponseRequired"];
            this.wNoticeEmail = _data["wNoticeEmail"];
            this.wPublishOnESS = _data["wPublishOnESS"];
            this.wObjectSOStatusID = _data["wObjectSOStatusID"];
            this.wNotes = _data["wNotes"];
            this.wResponseDueDate = _data["wResponseDueDate"];
            this.wRespondentTypeID = _data["wRespondentTypeID"];
            this.wRespondentsControlledFunctionTypeIDs = _data["wRespondentsControlledFunctionTypeIDs"];
            this.wRespondentsDNFBPFunctionTypeIDs = _data["wRespondentsDNFBPFunctionTypeIDs"];
            this.wNoticeSignOffText = _data["wNoticeSignOffText"];
            this.objNoticeQuestionnaire = _data["objNoticeQuestionnaire"] ? WNoticeQuestionnaire.fromJS(_data["objNoticeQuestionnaire"]) : <any>undefined;
            this.noticeType = _data["noticeType"];
            this.noticeTemplate = _data["noticeTemplate"];
            this.noticeNumber = _data["noticeNumber"];
            this.noticeDate = _data["noticeDate"];
            this.issuer = _data["issuer"];
            this.responseRequired = _data["responseRequired"];
            this.published = _data["published"];
            this.responseDueDate = _data["responseDueDate"];
            this.responseProvidedDate = _data["responseProvidedDate"];
            this.responseSignedBy = _data["responseSignedBy"];
            this.resoponseType = _data["resoponseType"];
            this.wsosStatusTypeID = _data["wsosStatusTypeID"];
        }
    }

    static fromJS(data: any): WNoticeList {
        data = typeof data === 'object' ? data : {};
        let result = new WNoticeList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wNoticeID"] = this.wNoticeID;
        data["wFirmNoticeID"] = this.wFirmNoticeID;
        data["wSourceNoticeID"] = this.wSourceNoticeID;
        data["wNoticeTypeID"] = this.wNoticeTypeID;
        data["wNoticeTypeDesc"] = this.wNoticeTypeDesc;
        data["wNoticeName"] = this.wNoticeName;
        data["wReferenceNumber"] = this.wReferenceNumber;
        data["wcmsReferenceNumber"] = this.wcmsReferenceNumber;
        data["wIssuersReferenceNumber"] = this.wIssuersReferenceNumber;
        data["wNoticeIssuerID"] = this.wNoticeIssuerID;
        data["wOtherNoticeIssuer"] = this.wOtherNoticeIssuer;
        data["wNoticeIssuedDate"] = this.wNoticeIssuedDate;
        data["wSubject"] = this.wSubject;
        data["wReferences"] = this.wReferences;
        data["wLinkToNotice"] = this.wLinkToNotice;
        data["wNotificationSentDate"] = this.wNotificationSentDate;
        data["wEmailNotificationContent"] = this.wEmailNotificationContent;
        data["wCreatedBy"] = this.wCreatedBy;
        data["wNoticeIssuerShortName"] = this.wNoticeIssuerShortName;
        data["wResponseRequired"] = this.wResponseRequired;
        data["wNoticeEmail"] = this.wNoticeEmail;
        data["wPublishOnESS"] = this.wPublishOnESS;
        data["wObjectSOStatusID"] = this.wObjectSOStatusID;
        data["wNotes"] = this.wNotes;
        data["wResponseDueDate"] = this.wResponseDueDate;
        data["wRespondentTypeID"] = this.wRespondentTypeID;
        data["wRespondentsControlledFunctionTypeIDs"] = this.wRespondentsControlledFunctionTypeIDs;
        data["wRespondentsDNFBPFunctionTypeIDs"] = this.wRespondentsDNFBPFunctionTypeIDs;
        data["wNoticeSignOffText"] = this.wNoticeSignOffText;
        data["objNoticeQuestionnaire"] = this.objNoticeQuestionnaire ? this.objNoticeQuestionnaire.toJSON() : <any>undefined;
        data["noticeType"] = this.noticeType;
        data["noticeTemplate"] = this.noticeTemplate;
        data["noticeNumber"] = this.noticeNumber;
        data["noticeDate"] = this.noticeDate;
        data["issuer"] = this.issuer;
        data["responseRequired"] = this.responseRequired;
        data["published"] = this.published;
        data["responseDueDate"] = this.responseDueDate;
        data["responseProvidedDate"] = this.responseProvidedDate;
        data["responseSignedBy"] = this.responseSignedBy;
        data["resoponseType"] = this.resoponseType;
        data["wsosStatusTypeID"] = this.wsosStatusTypeID;
        return data;
    }
}

export interface IWNoticeList {
    wNoticeID?: number | undefined;
    wFirmNoticeID?: number;
    wSourceNoticeID?: number;
    wNoticeTypeID?: number;
    wNoticeTypeDesc?: string | undefined;
    wNoticeName?: string | undefined;
    wReferenceNumber?: string | undefined;
    wcmsReferenceNumber?: string | undefined;
    wIssuersReferenceNumber?: string | undefined;
    wNoticeIssuerID?: number | undefined;
    wOtherNoticeIssuer?: string | undefined;
    wNoticeIssuedDate?: string | undefined;
    wSubject?: string | undefined;
    wReferences?: string | undefined;
    wLinkToNotice?: string | undefined;
    wNotificationSentDate?: string | undefined;
    wEmailNotificationContent?: string | undefined;
    wCreatedBy?: number;
    wNoticeIssuerShortName?: string | undefined;
    wResponseRequired?: boolean;
    wNoticeEmail?: string | undefined;
    wPublishOnESS?: boolean;
    wObjectSOStatusID?: number | undefined;
    wNotes?: string | undefined;
    wResponseDueDate?: string | undefined;
    wRespondentTypeID?: number | undefined;
    wRespondentsControlledFunctionTypeIDs?: string | undefined;
    wRespondentsDNFBPFunctionTypeIDs?: string | undefined;
    wNoticeSignOffText?: string | undefined;
    objNoticeQuestionnaire?: WNoticeQuestionnaire;
    noticeType?: string | undefined;
    noticeTemplate?: string | undefined;
    noticeNumber?: string | undefined;
    noticeDate?: string | undefined;
    issuer?: string | undefined;
    responseRequired?: string | undefined;
    published?: string | undefined;
    responseDueDate?: string | undefined;
    responseProvidedDate?: string | undefined;
    responseSignedBy?: string | undefined;
    resoponseType?: string | undefined;
    wsosStatusTypeID?: number | undefined;
}

export class WNoticeListListBaseResponse implements IWNoticeListListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: WNoticeList[] | undefined;

    constructor(data?: IWNoticeListListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["response"])) {
                this.response = [] as any;
                for (let item of _data["response"])
                    this.response!.push(WNoticeList.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WNoticeListListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WNoticeListListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.response)) {
            data["response"] = [];
            for (let item of this.response)
                data["response"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWNoticeListListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: WNoticeList[] | undefined;
}

export class WNoticeQuestionnaire implements IWNoticeQuestionnaire {
    wNoticeID?: number | undefined;
    wFirmNoticeID?: number;
    wSourceNoticeID?: number;
    wNoticeTypeID?: number;
    wNoticeTypeDesc?: string | undefined;
    wNoticeName?: string | undefined;
    wReferenceNumber?: string | undefined;
    wcmsReferenceNumber?: string | undefined;
    wIssuersReferenceNumber?: string | undefined;
    wNoticeIssuerID?: number | undefined;
    wOtherNoticeIssuer?: string | undefined;
    wNoticeIssuedDate?: string | undefined;
    wSubject?: string | undefined;
    wReferences?: string | undefined;
    wLinkToNotice?: string | undefined;
    wNotificationSentDate?: string | undefined;
    wEmailNotificationContent?: string | undefined;
    wCreatedBy?: number;
    wNoticeIssuerShortName?: string | undefined;
    wResponseRequired?: boolean;
    wNoticeEmail?: string | undefined;
    wPublishOnESS?: boolean;
    wObjectSOStatusID?: number | undefined;
    wNotes?: string | undefined;
    wNoticeSignOffText?: string | undefined;
    objNoticeQuestionnaire?: WNoticeQuestionnaire;
    wNoticeQuestionnaireID?: number | undefined;
    wSourceNoticeQuestionnaireID?: number;
    wResponseDueDate?: string | undefined;
    wRespondentTypeID?: number | undefined;
    wRespondentsControlledFunctionTypeIDs?: string | undefined;
    wRespondentsDNFBPFunctionTypeIDs?: string | undefined;
    lstNoticeQuestionnaireItems?: WNoticeQuestionnaireItems[] | undefined;

    constructor(data?: IWNoticeQuestionnaire) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wNoticeID = _data["wNoticeID"];
            this.wFirmNoticeID = _data["wFirmNoticeID"];
            this.wSourceNoticeID = _data["wSourceNoticeID"];
            this.wNoticeTypeID = _data["wNoticeTypeID"];
            this.wNoticeTypeDesc = _data["wNoticeTypeDesc"];
            this.wNoticeName = _data["wNoticeName"];
            this.wReferenceNumber = _data["wReferenceNumber"];
            this.wcmsReferenceNumber = _data["wcmsReferenceNumber"];
            this.wIssuersReferenceNumber = _data["wIssuersReferenceNumber"];
            this.wNoticeIssuerID = _data["wNoticeIssuerID"];
            this.wOtherNoticeIssuer = _data["wOtherNoticeIssuer"];
            this.wNoticeIssuedDate = _data["wNoticeIssuedDate"];
            this.wSubject = _data["wSubject"];
            this.wReferences = _data["wReferences"];
            this.wLinkToNotice = _data["wLinkToNotice"];
            this.wNotificationSentDate = _data["wNotificationSentDate"];
            this.wEmailNotificationContent = _data["wEmailNotificationContent"];
            this.wCreatedBy = _data["wCreatedBy"];
            this.wNoticeIssuerShortName = _data["wNoticeIssuerShortName"];
            this.wResponseRequired = _data["wResponseRequired"];
            this.wNoticeEmail = _data["wNoticeEmail"];
            this.wPublishOnESS = _data["wPublishOnESS"];
            this.wObjectSOStatusID = _data["wObjectSOStatusID"];
            this.wNotes = _data["wNotes"];
            this.wNoticeSignOffText = _data["wNoticeSignOffText"];
            this.objNoticeQuestionnaire = _data["objNoticeQuestionnaire"] ? WNoticeQuestionnaire.fromJS(_data["objNoticeQuestionnaire"]) : <any>undefined;
            this.wNoticeQuestionnaireID = _data["wNoticeQuestionnaireID"];
            this.wSourceNoticeQuestionnaireID = _data["wSourceNoticeQuestionnaireID"];
            this.wResponseDueDate = _data["wResponseDueDate"];
            this.wRespondentTypeID = _data["wRespondentTypeID"];
            this.wRespondentsControlledFunctionTypeIDs = _data["wRespondentsControlledFunctionTypeIDs"];
            this.wRespondentsDNFBPFunctionTypeIDs = _data["wRespondentsDNFBPFunctionTypeIDs"];
            if (Array.isArray(_data["lstNoticeQuestionnaireItems"])) {
                this.lstNoticeQuestionnaireItems = [] as any;
                for (let item of _data["lstNoticeQuestionnaireItems"])
                    this.lstNoticeQuestionnaireItems!.push(WNoticeQuestionnaireItems.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WNoticeQuestionnaire {
        data = typeof data === 'object' ? data : {};
        let result = new WNoticeQuestionnaire();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wNoticeID"] = this.wNoticeID;
        data["wFirmNoticeID"] = this.wFirmNoticeID;
        data["wSourceNoticeID"] = this.wSourceNoticeID;
        data["wNoticeTypeID"] = this.wNoticeTypeID;
        data["wNoticeTypeDesc"] = this.wNoticeTypeDesc;
        data["wNoticeName"] = this.wNoticeName;
        data["wReferenceNumber"] = this.wReferenceNumber;
        data["wcmsReferenceNumber"] = this.wcmsReferenceNumber;
        data["wIssuersReferenceNumber"] = this.wIssuersReferenceNumber;
        data["wNoticeIssuerID"] = this.wNoticeIssuerID;
        data["wOtherNoticeIssuer"] = this.wOtherNoticeIssuer;
        data["wNoticeIssuedDate"] = this.wNoticeIssuedDate;
        data["wSubject"] = this.wSubject;
        data["wReferences"] = this.wReferences;
        data["wLinkToNotice"] = this.wLinkToNotice;
        data["wNotificationSentDate"] = this.wNotificationSentDate;
        data["wEmailNotificationContent"] = this.wEmailNotificationContent;
        data["wCreatedBy"] = this.wCreatedBy;
        data["wNoticeIssuerShortName"] = this.wNoticeIssuerShortName;
        data["wResponseRequired"] = this.wResponseRequired;
        data["wNoticeEmail"] = this.wNoticeEmail;
        data["wPublishOnESS"] = this.wPublishOnESS;
        data["wObjectSOStatusID"] = this.wObjectSOStatusID;
        data["wNotes"] = this.wNotes;
        data["wNoticeSignOffText"] = this.wNoticeSignOffText;
        data["objNoticeQuestionnaire"] = this.objNoticeQuestionnaire ? this.objNoticeQuestionnaire.toJSON() : <any>undefined;
        data["wNoticeQuestionnaireID"] = this.wNoticeQuestionnaireID;
        data["wSourceNoticeQuestionnaireID"] = this.wSourceNoticeQuestionnaireID;
        data["wResponseDueDate"] = this.wResponseDueDate;
        data["wRespondentTypeID"] = this.wRespondentTypeID;
        data["wRespondentsControlledFunctionTypeIDs"] = this.wRespondentsControlledFunctionTypeIDs;
        data["wRespondentsDNFBPFunctionTypeIDs"] = this.wRespondentsDNFBPFunctionTypeIDs;
        if (Array.isArray(this.lstNoticeQuestionnaireItems)) {
            data["lstNoticeQuestionnaireItems"] = [];
            for (let item of this.lstNoticeQuestionnaireItems)
                data["lstNoticeQuestionnaireItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWNoticeQuestionnaire {
    wNoticeID?: number | undefined;
    wFirmNoticeID?: number;
    wSourceNoticeID?: number;
    wNoticeTypeID?: number;
    wNoticeTypeDesc?: string | undefined;
    wNoticeName?: string | undefined;
    wReferenceNumber?: string | undefined;
    wcmsReferenceNumber?: string | undefined;
    wIssuersReferenceNumber?: string | undefined;
    wNoticeIssuerID?: number | undefined;
    wOtherNoticeIssuer?: string | undefined;
    wNoticeIssuedDate?: string | undefined;
    wSubject?: string | undefined;
    wReferences?: string | undefined;
    wLinkToNotice?: string | undefined;
    wNotificationSentDate?: string | undefined;
    wEmailNotificationContent?: string | undefined;
    wCreatedBy?: number;
    wNoticeIssuerShortName?: string | undefined;
    wResponseRequired?: boolean;
    wNoticeEmail?: string | undefined;
    wPublishOnESS?: boolean;
    wObjectSOStatusID?: number | undefined;
    wNotes?: string | undefined;
    wNoticeSignOffText?: string | undefined;
    objNoticeQuestionnaire?: WNoticeQuestionnaire;
    wNoticeQuestionnaireID?: number | undefined;
    wSourceNoticeQuestionnaireID?: number;
    wResponseDueDate?: string | undefined;
    wRespondentTypeID?: number | undefined;
    wRespondentsControlledFunctionTypeIDs?: string | undefined;
    wRespondentsDNFBPFunctionTypeIDs?: string | undefined;
    lstNoticeQuestionnaireItems?: WNoticeQuestionnaireItems[] | undefined;
}

export class WNoticeQuestionnaireDto implements IWNoticeQuestionnaireDto {
    wNoticeQuestionnaireID?: number | undefined;
    wNoticeID?: number | undefined;
    wSourceNoticeQuestionnaireID?: number | undefined;
    wResponseDueDate?: string | undefined;
    wRespondentTypeID?: number | undefined;
    wRespondentsControlledFunctionTypeIDs?: string | undefined;
    wRespondentsDNFBPFunctionTypeIDs?: string | undefined;
    wCreatedBy?: number | undefined;
    lstNoticeQuestionnaireItems?: WNoticeQuestionnaireItemDto[] | undefined;

    constructor(data?: IWNoticeQuestionnaireDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wNoticeQuestionnaireID = _data["wNoticeQuestionnaireID"];
            this.wNoticeID = _data["wNoticeID"];
            this.wSourceNoticeQuestionnaireID = _data["wSourceNoticeQuestionnaireID"];
            this.wResponseDueDate = _data["wResponseDueDate"];
            this.wRespondentTypeID = _data["wRespondentTypeID"];
            this.wRespondentsControlledFunctionTypeIDs = _data["wRespondentsControlledFunctionTypeIDs"];
            this.wRespondentsDNFBPFunctionTypeIDs = _data["wRespondentsDNFBPFunctionTypeIDs"];
            this.wCreatedBy = _data["wCreatedBy"];
            if (Array.isArray(_data["lstNoticeQuestionnaireItems"])) {
                this.lstNoticeQuestionnaireItems = [] as any;
                for (let item of _data["lstNoticeQuestionnaireItems"])
                    this.lstNoticeQuestionnaireItems!.push(WNoticeQuestionnaireItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WNoticeQuestionnaireDto {
        data = typeof data === 'object' ? data : {};
        let result = new WNoticeQuestionnaireDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wNoticeQuestionnaireID"] = this.wNoticeQuestionnaireID;
        data["wNoticeID"] = this.wNoticeID;
        data["wSourceNoticeQuestionnaireID"] = this.wSourceNoticeQuestionnaireID;
        data["wResponseDueDate"] = this.wResponseDueDate;
        data["wRespondentTypeID"] = this.wRespondentTypeID;
        data["wRespondentsControlledFunctionTypeIDs"] = this.wRespondentsControlledFunctionTypeIDs;
        data["wRespondentsDNFBPFunctionTypeIDs"] = this.wRespondentsDNFBPFunctionTypeIDs;
        data["wCreatedBy"] = this.wCreatedBy;
        if (Array.isArray(this.lstNoticeQuestionnaireItems)) {
            data["lstNoticeQuestionnaireItems"] = [];
            for (let item of this.lstNoticeQuestionnaireItems)
                data["lstNoticeQuestionnaireItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWNoticeQuestionnaireDto {
    wNoticeQuestionnaireID?: number | undefined;
    wNoticeID?: number | undefined;
    wSourceNoticeQuestionnaireID?: number | undefined;
    wResponseDueDate?: string | undefined;
    wRespondentTypeID?: number | undefined;
    wRespondentsControlledFunctionTypeIDs?: string | undefined;
    wRespondentsDNFBPFunctionTypeIDs?: string | undefined;
    wCreatedBy?: number | undefined;
    lstNoticeQuestionnaireItems?: WNoticeQuestionnaireItemDto[] | undefined;
}

export class WNoticeQuestionnaireItemDto implements IWNoticeQuestionnaireItemDto {
    wNoticeQuestionnaireItemID?: number | undefined;
    wNoticeResponseItemID?: number | undefined;
    wFirmNoticeID?: number | undefined;
    wExplanation?: string | undefined;
    wExplanationReqdCriteriaMet?: boolean | undefined;
    wSourceNoticeQuestionnaireItemID?: number | undefined;
    wNoticeID?: number | undefined;
    wNoticeQuestionnaireID?: number | undefined;
    wNoticeQuestionNumber?: string | undefined;
    wNoticeQuestion?: string | undefined;
    wResponseAnswer?: string | undefined;
    errorMessage?: string | undefined;
    wResponseTypeID?: number | undefined;
    wListNameID?: number | undefined;
    wExplanationRequired?: number | undefined;
    wQuestionDisplayOrder?: number | undefined;
    wCreatedBy?: number | undefined;
    evaluationCriteriaMet?: number | undefined;
    wResponseMandatory?: boolean | undefined;
    responseProvided?: boolean | undefined;
    explanationProvided?: boolean | undefined;
    lstResponseCriteria?: WNoticeResponseEvaluationCriteriaDto[] | undefined;

    constructor(data?: IWNoticeQuestionnaireItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wNoticeQuestionnaireItemID = _data["wNoticeQuestionnaireItemID"];
            this.wNoticeResponseItemID = _data["wNoticeResponseItemID"];
            this.wFirmNoticeID = _data["wFirmNoticeID"];
            this.wExplanation = _data["wExplanation"];
            this.wExplanationReqdCriteriaMet = _data["wExplanationReqdCriteriaMet"];
            this.wSourceNoticeQuestionnaireItemID = _data["wSourceNoticeQuestionnaireItemID"];
            this.wNoticeID = _data["wNoticeID"];
            this.wNoticeQuestionnaireID = _data["wNoticeQuestionnaireID"];
            this.wNoticeQuestionNumber = _data["wNoticeQuestionNumber"];
            this.wNoticeQuestion = _data["wNoticeQuestion"];
            this.wResponseAnswer = _data["wResponseAnswer"];
            this.errorMessage = _data["errorMessage"];
            this.wResponseTypeID = _data["wResponseTypeID"];
            this.wListNameID = _data["wListNameID"];
            this.wExplanationRequired = _data["wExplanationRequired"];
            this.wQuestionDisplayOrder = _data["wQuestionDisplayOrder"];
            this.wCreatedBy = _data["wCreatedBy"];
            this.evaluationCriteriaMet = _data["evaluationCriteriaMet"];
            this.wResponseMandatory = _data["wResponseMandatory"];
            this.responseProvided = _data["responseProvided"];
            this.explanationProvided = _data["explanationProvided"];
            if (Array.isArray(_data["lstResponseCriteria"])) {
                this.lstResponseCriteria = [] as any;
                for (let item of _data["lstResponseCriteria"])
                    this.lstResponseCriteria!.push(WNoticeResponseEvaluationCriteriaDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WNoticeQuestionnaireItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new WNoticeQuestionnaireItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wNoticeQuestionnaireItemID"] = this.wNoticeQuestionnaireItemID;
        data["wNoticeResponseItemID"] = this.wNoticeResponseItemID;
        data["wFirmNoticeID"] = this.wFirmNoticeID;
        data["wExplanation"] = this.wExplanation;
        data["wExplanationReqdCriteriaMet"] = this.wExplanationReqdCriteriaMet;
        data["wSourceNoticeQuestionnaireItemID"] = this.wSourceNoticeQuestionnaireItemID;
        data["wNoticeID"] = this.wNoticeID;
        data["wNoticeQuestionnaireID"] = this.wNoticeQuestionnaireID;
        data["wNoticeQuestionNumber"] = this.wNoticeQuestionNumber;
        data["wNoticeQuestion"] = this.wNoticeQuestion;
        data["wResponseAnswer"] = this.wResponseAnswer;
        data["errorMessage"] = this.errorMessage;
        data["wResponseTypeID"] = this.wResponseTypeID;
        data["wListNameID"] = this.wListNameID;
        data["wExplanationRequired"] = this.wExplanationRequired;
        data["wQuestionDisplayOrder"] = this.wQuestionDisplayOrder;
        data["wCreatedBy"] = this.wCreatedBy;
        data["evaluationCriteriaMet"] = this.evaluationCriteriaMet;
        data["wResponseMandatory"] = this.wResponseMandatory;
        data["responseProvided"] = this.responseProvided;
        data["explanationProvided"] = this.explanationProvided;
        if (Array.isArray(this.lstResponseCriteria)) {
            data["lstResponseCriteria"] = [];
            for (let item of this.lstResponseCriteria)
                data["lstResponseCriteria"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWNoticeQuestionnaireItemDto {
    wNoticeQuestionnaireItemID?: number | undefined;
    wNoticeResponseItemID?: number | undefined;
    wFirmNoticeID?: number | undefined;
    wExplanation?: string | undefined;
    wExplanationReqdCriteriaMet?: boolean | undefined;
    wSourceNoticeQuestionnaireItemID?: number | undefined;
    wNoticeID?: number | undefined;
    wNoticeQuestionnaireID?: number | undefined;
    wNoticeQuestionNumber?: string | undefined;
    wNoticeQuestion?: string | undefined;
    wResponseAnswer?: string | undefined;
    errorMessage?: string | undefined;
    wResponseTypeID?: number | undefined;
    wListNameID?: number | undefined;
    wExplanationRequired?: number | undefined;
    wQuestionDisplayOrder?: number | undefined;
    wCreatedBy?: number | undefined;
    evaluationCriteriaMet?: number | undefined;
    wResponseMandatory?: boolean | undefined;
    responseProvided?: boolean | undefined;
    explanationProvided?: boolean | undefined;
    lstResponseCriteria?: WNoticeResponseEvaluationCriteriaDto[] | undefined;
}

export class WNoticeQuestionnaireItemDtoListBaseResponse implements IWNoticeQuestionnaireItemDtoListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: WNoticeQuestionnaireItemDto[] | undefined;

    constructor(data?: IWNoticeQuestionnaireItemDtoListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["response"])) {
                this.response = [] as any;
                for (let item of _data["response"])
                    this.response!.push(WNoticeQuestionnaireItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WNoticeQuestionnaireItemDtoListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WNoticeQuestionnaireItemDtoListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.response)) {
            data["response"] = [];
            for (let item of this.response)
                data["response"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWNoticeQuestionnaireItemDtoListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: WNoticeQuestionnaireItemDto[] | undefined;
}

export class WNoticeQuestionnaireItems implements IWNoticeQuestionnaireItems {
    wNoticeID?: number | undefined;
    wFirmNoticeID?: number;
    wSourceNoticeID?: number;
    wNoticeTypeID?: number;
    wNoticeTypeDesc?: string | undefined;
    wNoticeName?: string | undefined;
    wReferenceNumber?: string | undefined;
    wcmsReferenceNumber?: string | undefined;
    wIssuersReferenceNumber?: string | undefined;
    wNoticeIssuerID?: number | undefined;
    wOtherNoticeIssuer?: string | undefined;
    wNoticeIssuedDate?: string | undefined;
    wSubject?: string | undefined;
    wReferences?: string | undefined;
    wLinkToNotice?: string | undefined;
    wNotificationSentDate?: string | undefined;
    wEmailNotificationContent?: string | undefined;
    wCreatedBy?: number;
    wNoticeIssuerShortName?: string | undefined;
    wResponseRequired?: boolean;
    wNoticeEmail?: string | undefined;
    wPublishOnESS?: boolean;
    wObjectSOStatusID?: number | undefined;
    wNotes?: string | undefined;
    wNoticeSignOffText?: string | undefined;
    objNoticeQuestionnaire?: WNoticeQuestionnaire;
    wNoticeQuestionnaireID?: number | undefined;
    wSourceNoticeQuestionnaireID?: number;
    wResponseDueDate?: string | undefined;
    wRespondentTypeID?: number | undefined;
    wRespondentsControlledFunctionTypeIDs?: string | undefined;
    wRespondentsDNFBPFunctionTypeIDs?: string | undefined;
    lstNoticeQuestionnaireItems?: WNoticeQuestionnaireItems[] | undefined;
    wNoticeQuestionnaireItemID?: number | undefined;
    wSourceNoticeQuestionnaireItemID?: number;
    wNoticeQuestionNumber?: string | undefined;
    wNoticeQuestion?: string | undefined;
    wResponseTypeID?: number | undefined;
    wResponseTypeDesc?: string | undefined;
    wListNameID?: number | undefined;
    wListNameDesc?: string | undefined;
    wExplanationRequired?: number | undefined;
    wEvaluationRequirementTypeDesc?: string | undefined;
    wQuestionDisplayOrder?: number;
    wNoticeResponseItemID?: number | undefined;
    wExplanation?: string | undefined;
    wExplanationReqdCriteriaMet?: boolean | undefined;
    wResponseAnswer?: string | undefined;
    responseProvided?: boolean | undefined;
    explanationProvided?: boolean | undefined;
    evaluationCriteriaMet?: number | undefined;
    errorMessage?: string | undefined;
    wResponseMandatory?: boolean;
    lstResponseCriteria?: WNoticeResponseEvaluationCriteria[] | undefined;

    constructor(data?: IWNoticeQuestionnaireItems) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wNoticeID = _data["wNoticeID"];
            this.wFirmNoticeID = _data["wFirmNoticeID"];
            this.wSourceNoticeID = _data["wSourceNoticeID"];
            this.wNoticeTypeID = _data["wNoticeTypeID"];
            this.wNoticeTypeDesc = _data["wNoticeTypeDesc"];
            this.wNoticeName = _data["wNoticeName"];
            this.wReferenceNumber = _data["wReferenceNumber"];
            this.wcmsReferenceNumber = _data["wcmsReferenceNumber"];
            this.wIssuersReferenceNumber = _data["wIssuersReferenceNumber"];
            this.wNoticeIssuerID = _data["wNoticeIssuerID"];
            this.wOtherNoticeIssuer = _data["wOtherNoticeIssuer"];
            this.wNoticeIssuedDate = _data["wNoticeIssuedDate"];
            this.wSubject = _data["wSubject"];
            this.wReferences = _data["wReferences"];
            this.wLinkToNotice = _data["wLinkToNotice"];
            this.wNotificationSentDate = _data["wNotificationSentDate"];
            this.wEmailNotificationContent = _data["wEmailNotificationContent"];
            this.wCreatedBy = _data["wCreatedBy"];
            this.wNoticeIssuerShortName = _data["wNoticeIssuerShortName"];
            this.wResponseRequired = _data["wResponseRequired"];
            this.wNoticeEmail = _data["wNoticeEmail"];
            this.wPublishOnESS = _data["wPublishOnESS"];
            this.wObjectSOStatusID = _data["wObjectSOStatusID"];
            this.wNotes = _data["wNotes"];
            this.wNoticeSignOffText = _data["wNoticeSignOffText"];
            this.objNoticeQuestionnaire = _data["objNoticeQuestionnaire"] ? WNoticeQuestionnaire.fromJS(_data["objNoticeQuestionnaire"]) : <any>undefined;
            this.wNoticeQuestionnaireID = _data["wNoticeQuestionnaireID"];
            this.wSourceNoticeQuestionnaireID = _data["wSourceNoticeQuestionnaireID"];
            this.wResponseDueDate = _data["wResponseDueDate"];
            this.wRespondentTypeID = _data["wRespondentTypeID"];
            this.wRespondentsControlledFunctionTypeIDs = _data["wRespondentsControlledFunctionTypeIDs"];
            this.wRespondentsDNFBPFunctionTypeIDs = _data["wRespondentsDNFBPFunctionTypeIDs"];
            if (Array.isArray(_data["lstNoticeQuestionnaireItems"])) {
                this.lstNoticeQuestionnaireItems = [] as any;
                for (let item of _data["lstNoticeQuestionnaireItems"])
                    this.lstNoticeQuestionnaireItems!.push(WNoticeQuestionnaireItems.fromJS(item));
            }
            this.wNoticeQuestionnaireItemID = _data["wNoticeQuestionnaireItemID"];
            this.wSourceNoticeQuestionnaireItemID = _data["wSourceNoticeQuestionnaireItemID"];
            this.wNoticeQuestionNumber = _data["wNoticeQuestionNumber"];
            this.wNoticeQuestion = _data["wNoticeQuestion"];
            this.wResponseTypeID = _data["wResponseTypeID"];
            this.wResponseTypeDesc = _data["wResponseTypeDesc"];
            this.wListNameID = _data["wListNameID"];
            this.wListNameDesc = _data["wListNameDesc"];
            this.wExplanationRequired = _data["wExplanationRequired"];
            this.wEvaluationRequirementTypeDesc = _data["wEvaluationRequirementTypeDesc"];
            this.wQuestionDisplayOrder = _data["wQuestionDisplayOrder"];
            this.wNoticeResponseItemID = _data["wNoticeResponseItemID"];
            this.wExplanation = _data["wExplanation"];
            this.wExplanationReqdCriteriaMet = _data["wExplanationReqdCriteriaMet"];
            this.wResponseAnswer = _data["wResponseAnswer"];
            this.responseProvided = _data["responseProvided"];
            this.explanationProvided = _data["explanationProvided"];
            this.evaluationCriteriaMet = _data["evaluationCriteriaMet"];
            this.errorMessage = _data["errorMessage"];
            this.wResponseMandatory = _data["wResponseMandatory"];
            if (Array.isArray(_data["lstResponseCriteria"])) {
                this.lstResponseCriteria = [] as any;
                for (let item of _data["lstResponseCriteria"])
                    this.lstResponseCriteria!.push(WNoticeResponseEvaluationCriteria.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WNoticeQuestionnaireItems {
        data = typeof data === 'object' ? data : {};
        let result = new WNoticeQuestionnaireItems();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wNoticeID"] = this.wNoticeID;
        data["wFirmNoticeID"] = this.wFirmNoticeID;
        data["wSourceNoticeID"] = this.wSourceNoticeID;
        data["wNoticeTypeID"] = this.wNoticeTypeID;
        data["wNoticeTypeDesc"] = this.wNoticeTypeDesc;
        data["wNoticeName"] = this.wNoticeName;
        data["wReferenceNumber"] = this.wReferenceNumber;
        data["wcmsReferenceNumber"] = this.wcmsReferenceNumber;
        data["wIssuersReferenceNumber"] = this.wIssuersReferenceNumber;
        data["wNoticeIssuerID"] = this.wNoticeIssuerID;
        data["wOtherNoticeIssuer"] = this.wOtherNoticeIssuer;
        data["wNoticeIssuedDate"] = this.wNoticeIssuedDate;
        data["wSubject"] = this.wSubject;
        data["wReferences"] = this.wReferences;
        data["wLinkToNotice"] = this.wLinkToNotice;
        data["wNotificationSentDate"] = this.wNotificationSentDate;
        data["wEmailNotificationContent"] = this.wEmailNotificationContent;
        data["wCreatedBy"] = this.wCreatedBy;
        data["wNoticeIssuerShortName"] = this.wNoticeIssuerShortName;
        data["wResponseRequired"] = this.wResponseRequired;
        data["wNoticeEmail"] = this.wNoticeEmail;
        data["wPublishOnESS"] = this.wPublishOnESS;
        data["wObjectSOStatusID"] = this.wObjectSOStatusID;
        data["wNotes"] = this.wNotes;
        data["wNoticeSignOffText"] = this.wNoticeSignOffText;
        data["objNoticeQuestionnaire"] = this.objNoticeQuestionnaire ? this.objNoticeQuestionnaire.toJSON() : <any>undefined;
        data["wNoticeQuestionnaireID"] = this.wNoticeQuestionnaireID;
        data["wSourceNoticeQuestionnaireID"] = this.wSourceNoticeQuestionnaireID;
        data["wResponseDueDate"] = this.wResponseDueDate;
        data["wRespondentTypeID"] = this.wRespondentTypeID;
        data["wRespondentsControlledFunctionTypeIDs"] = this.wRespondentsControlledFunctionTypeIDs;
        data["wRespondentsDNFBPFunctionTypeIDs"] = this.wRespondentsDNFBPFunctionTypeIDs;
        if (Array.isArray(this.lstNoticeQuestionnaireItems)) {
            data["lstNoticeQuestionnaireItems"] = [];
            for (let item of this.lstNoticeQuestionnaireItems)
                data["lstNoticeQuestionnaireItems"].push(item.toJSON());
        }
        data["wNoticeQuestionnaireItemID"] = this.wNoticeQuestionnaireItemID;
        data["wSourceNoticeQuestionnaireItemID"] = this.wSourceNoticeQuestionnaireItemID;
        data["wNoticeQuestionNumber"] = this.wNoticeQuestionNumber;
        data["wNoticeQuestion"] = this.wNoticeQuestion;
        data["wResponseTypeID"] = this.wResponseTypeID;
        data["wResponseTypeDesc"] = this.wResponseTypeDesc;
        data["wListNameID"] = this.wListNameID;
        data["wListNameDesc"] = this.wListNameDesc;
        data["wExplanationRequired"] = this.wExplanationRequired;
        data["wEvaluationRequirementTypeDesc"] = this.wEvaluationRequirementTypeDesc;
        data["wQuestionDisplayOrder"] = this.wQuestionDisplayOrder;
        data["wNoticeResponseItemID"] = this.wNoticeResponseItemID;
        data["wExplanation"] = this.wExplanation;
        data["wExplanationReqdCriteriaMet"] = this.wExplanationReqdCriteriaMet;
        data["wResponseAnswer"] = this.wResponseAnswer;
        data["responseProvided"] = this.responseProvided;
        data["explanationProvided"] = this.explanationProvided;
        data["evaluationCriteriaMet"] = this.evaluationCriteriaMet;
        data["errorMessage"] = this.errorMessage;
        data["wResponseMandatory"] = this.wResponseMandatory;
        if (Array.isArray(this.lstResponseCriteria)) {
            data["lstResponseCriteria"] = [];
            for (let item of this.lstResponseCriteria)
                data["lstResponseCriteria"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWNoticeQuestionnaireItems {
    wNoticeID?: number | undefined;
    wFirmNoticeID?: number;
    wSourceNoticeID?: number;
    wNoticeTypeID?: number;
    wNoticeTypeDesc?: string | undefined;
    wNoticeName?: string | undefined;
    wReferenceNumber?: string | undefined;
    wcmsReferenceNumber?: string | undefined;
    wIssuersReferenceNumber?: string | undefined;
    wNoticeIssuerID?: number | undefined;
    wOtherNoticeIssuer?: string | undefined;
    wNoticeIssuedDate?: string | undefined;
    wSubject?: string | undefined;
    wReferences?: string | undefined;
    wLinkToNotice?: string | undefined;
    wNotificationSentDate?: string | undefined;
    wEmailNotificationContent?: string | undefined;
    wCreatedBy?: number;
    wNoticeIssuerShortName?: string | undefined;
    wResponseRequired?: boolean;
    wNoticeEmail?: string | undefined;
    wPublishOnESS?: boolean;
    wObjectSOStatusID?: number | undefined;
    wNotes?: string | undefined;
    wNoticeSignOffText?: string | undefined;
    objNoticeQuestionnaire?: WNoticeQuestionnaire;
    wNoticeQuestionnaireID?: number | undefined;
    wSourceNoticeQuestionnaireID?: number;
    wResponseDueDate?: string | undefined;
    wRespondentTypeID?: number | undefined;
    wRespondentsControlledFunctionTypeIDs?: string | undefined;
    wRespondentsDNFBPFunctionTypeIDs?: string | undefined;
    lstNoticeQuestionnaireItems?: WNoticeQuestionnaireItems[] | undefined;
    wNoticeQuestionnaireItemID?: number | undefined;
    wSourceNoticeQuestionnaireItemID?: number;
    wNoticeQuestionNumber?: string | undefined;
    wNoticeQuestion?: string | undefined;
    wResponseTypeID?: number | undefined;
    wResponseTypeDesc?: string | undefined;
    wListNameID?: number | undefined;
    wListNameDesc?: string | undefined;
    wExplanationRequired?: number | undefined;
    wEvaluationRequirementTypeDesc?: string | undefined;
    wQuestionDisplayOrder?: number;
    wNoticeResponseItemID?: number | undefined;
    wExplanation?: string | undefined;
    wExplanationReqdCriteriaMet?: boolean | undefined;
    wResponseAnswer?: string | undefined;
    responseProvided?: boolean | undefined;
    explanationProvided?: boolean | undefined;
    evaluationCriteriaMet?: number | undefined;
    errorMessage?: string | undefined;
    wResponseMandatory?: boolean;
    lstResponseCriteria?: WNoticeResponseEvaluationCriteria[] | undefined;
}

export class WNoticeResponseEvaluationCriteria implements IWNoticeResponseEvaluationCriteria {
    wNoticeID?: number | undefined;
    wFirmNoticeID?: number;
    wSourceNoticeID?: number;
    wNoticeTypeID?: number;
    wNoticeTypeDesc?: string | undefined;
    wNoticeName?: string | undefined;
    wReferenceNumber?: string | undefined;
    wcmsReferenceNumber?: string | undefined;
    wIssuersReferenceNumber?: string | undefined;
    wNoticeIssuerID?: number | undefined;
    wOtherNoticeIssuer?: string | undefined;
    wNoticeIssuedDate?: string | undefined;
    wSubject?: string | undefined;
    wReferences?: string | undefined;
    wLinkToNotice?: string | undefined;
    wNotificationSentDate?: string | undefined;
    wEmailNotificationContent?: string | undefined;
    wCreatedBy?: number;
    wNoticeIssuerShortName?: string | undefined;
    wResponseRequired?: boolean;
    wNoticeEmail?: string | undefined;
    wPublishOnESS?: boolean;
    wObjectSOStatusID?: number | undefined;
    wNotes?: string | undefined;
    wNoticeSignOffText?: string | undefined;
    objNoticeQuestionnaire?: WNoticeQuestionnaire;
    wNoticeQuestionnaireID?: number | undefined;
    wSourceNoticeQuestionnaireID?: number;
    wResponseDueDate?: string | undefined;
    wRespondentTypeID?: number | undefined;
    wRespondentsControlledFunctionTypeIDs?: string | undefined;
    wRespondentsDNFBPFunctionTypeIDs?: string | undefined;
    lstNoticeQuestionnaireItems?: WNoticeQuestionnaireItems[] | undefined;
    wNoticeQuestionnaireItemID?: number | undefined;
    wSourceNoticeQuestionnaireItemID?: number;
    wNoticeQuestionNumber?: string | undefined;
    wNoticeQuestion?: string | undefined;
    wResponseTypeID?: number | undefined;
    wResponseTypeDesc?: string | undefined;
    wListNameID?: number | undefined;
    wListNameDesc?: string | undefined;
    wExplanationRequired?: number | undefined;
    wEvaluationRequirementTypeDesc?: string | undefined;
    wQuestionDisplayOrder?: number;
    wNoticeResponseItemID?: number | undefined;
    wExplanation?: string | undefined;
    wExplanationReqdCriteriaMet?: boolean | undefined;
    wResponseAnswer?: string | undefined;
    responseProvided?: boolean | undefined;
    explanationProvided?: boolean | undefined;
    evaluationCriteriaMet?: number | undefined;
    errorMessage?: string | undefined;
    wResponseMandatory?: boolean;
    lstResponseCriteria?: WNoticeResponseEvaluationCriteria[] | undefined;
    wSourceResponseEvaluationCriteriaID?: number;
    wResponseEvaluationCriteriaID?: number | undefined;
    wEvaluationReasonTypeID?: number;
    wNoticeResponseValueID?: number | undefined;
    wResponseOperatorTypeID?: number | undefined;
    wEvaluationOperatorTypeDesc?: string | undefined;
    wResponse?: string | undefined;
    wResponseTo?: string | undefined;
    wListValueID?: number | undefined;
    listValueDesc?: string | undefined;
    dcMultiSelectValues?: { [key: string]: string; } | undefined;

    constructor(data?: IWNoticeResponseEvaluationCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wNoticeID = _data["wNoticeID"];
            this.wFirmNoticeID = _data["wFirmNoticeID"];
            this.wSourceNoticeID = _data["wSourceNoticeID"];
            this.wNoticeTypeID = _data["wNoticeTypeID"];
            this.wNoticeTypeDesc = _data["wNoticeTypeDesc"];
            this.wNoticeName = _data["wNoticeName"];
            this.wReferenceNumber = _data["wReferenceNumber"];
            this.wcmsReferenceNumber = _data["wcmsReferenceNumber"];
            this.wIssuersReferenceNumber = _data["wIssuersReferenceNumber"];
            this.wNoticeIssuerID = _data["wNoticeIssuerID"];
            this.wOtherNoticeIssuer = _data["wOtherNoticeIssuer"];
            this.wNoticeIssuedDate = _data["wNoticeIssuedDate"];
            this.wSubject = _data["wSubject"];
            this.wReferences = _data["wReferences"];
            this.wLinkToNotice = _data["wLinkToNotice"];
            this.wNotificationSentDate = _data["wNotificationSentDate"];
            this.wEmailNotificationContent = _data["wEmailNotificationContent"];
            this.wCreatedBy = _data["wCreatedBy"];
            this.wNoticeIssuerShortName = _data["wNoticeIssuerShortName"];
            this.wResponseRequired = _data["wResponseRequired"];
            this.wNoticeEmail = _data["wNoticeEmail"];
            this.wPublishOnESS = _data["wPublishOnESS"];
            this.wObjectSOStatusID = _data["wObjectSOStatusID"];
            this.wNotes = _data["wNotes"];
            this.wNoticeSignOffText = _data["wNoticeSignOffText"];
            this.objNoticeQuestionnaire = _data["objNoticeQuestionnaire"] ? WNoticeQuestionnaire.fromJS(_data["objNoticeQuestionnaire"]) : <any>undefined;
            this.wNoticeQuestionnaireID = _data["wNoticeQuestionnaireID"];
            this.wSourceNoticeQuestionnaireID = _data["wSourceNoticeQuestionnaireID"];
            this.wResponseDueDate = _data["wResponseDueDate"];
            this.wRespondentTypeID = _data["wRespondentTypeID"];
            this.wRespondentsControlledFunctionTypeIDs = _data["wRespondentsControlledFunctionTypeIDs"];
            this.wRespondentsDNFBPFunctionTypeIDs = _data["wRespondentsDNFBPFunctionTypeIDs"];
            if (Array.isArray(_data["lstNoticeQuestionnaireItems"])) {
                this.lstNoticeQuestionnaireItems = [] as any;
                for (let item of _data["lstNoticeQuestionnaireItems"])
                    this.lstNoticeQuestionnaireItems!.push(WNoticeQuestionnaireItems.fromJS(item));
            }
            this.wNoticeQuestionnaireItemID = _data["wNoticeQuestionnaireItemID"];
            this.wSourceNoticeQuestionnaireItemID = _data["wSourceNoticeQuestionnaireItemID"];
            this.wNoticeQuestionNumber = _data["wNoticeQuestionNumber"];
            this.wNoticeQuestion = _data["wNoticeQuestion"];
            this.wResponseTypeID = _data["wResponseTypeID"];
            this.wResponseTypeDesc = _data["wResponseTypeDesc"];
            this.wListNameID = _data["wListNameID"];
            this.wListNameDesc = _data["wListNameDesc"];
            this.wExplanationRequired = _data["wExplanationRequired"];
            this.wEvaluationRequirementTypeDesc = _data["wEvaluationRequirementTypeDesc"];
            this.wQuestionDisplayOrder = _data["wQuestionDisplayOrder"];
            this.wNoticeResponseItemID = _data["wNoticeResponseItemID"];
            this.wExplanation = _data["wExplanation"];
            this.wExplanationReqdCriteriaMet = _data["wExplanationReqdCriteriaMet"];
            this.wResponseAnswer = _data["wResponseAnswer"];
            this.responseProvided = _data["responseProvided"];
            this.explanationProvided = _data["explanationProvided"];
            this.evaluationCriteriaMet = _data["evaluationCriteriaMet"];
            this.errorMessage = _data["errorMessage"];
            this.wResponseMandatory = _data["wResponseMandatory"];
            if (Array.isArray(_data["lstResponseCriteria"])) {
                this.lstResponseCriteria = [] as any;
                for (let item of _data["lstResponseCriteria"])
                    this.lstResponseCriteria!.push(WNoticeResponseEvaluationCriteria.fromJS(item));
            }
            this.wSourceResponseEvaluationCriteriaID = _data["wSourceResponseEvaluationCriteriaID"];
            this.wResponseEvaluationCriteriaID = _data["wResponseEvaluationCriteriaID"];
            this.wEvaluationReasonTypeID = _data["wEvaluationReasonTypeID"];
            this.wNoticeResponseValueID = _data["wNoticeResponseValueID"];
            this.wResponseOperatorTypeID = _data["wResponseOperatorTypeID"];
            this.wEvaluationOperatorTypeDesc = _data["wEvaluationOperatorTypeDesc"];
            this.wResponse = _data["wResponse"];
            this.wResponseTo = _data["wResponseTo"];
            this.wListValueID = _data["wListValueID"];
            this.listValueDesc = _data["listValueDesc"];
            if (_data["dcMultiSelectValues"]) {
                this.dcMultiSelectValues = {} as any;
                for (let key in _data["dcMultiSelectValues"]) {
                    if (_data["dcMultiSelectValues"].hasOwnProperty(key))
                        (<any>this.dcMultiSelectValues)![key] = _data["dcMultiSelectValues"][key];
                }
            }
        }
    }

    static fromJS(data: any): WNoticeResponseEvaluationCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new WNoticeResponseEvaluationCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wNoticeID"] = this.wNoticeID;
        data["wFirmNoticeID"] = this.wFirmNoticeID;
        data["wSourceNoticeID"] = this.wSourceNoticeID;
        data["wNoticeTypeID"] = this.wNoticeTypeID;
        data["wNoticeTypeDesc"] = this.wNoticeTypeDesc;
        data["wNoticeName"] = this.wNoticeName;
        data["wReferenceNumber"] = this.wReferenceNumber;
        data["wcmsReferenceNumber"] = this.wcmsReferenceNumber;
        data["wIssuersReferenceNumber"] = this.wIssuersReferenceNumber;
        data["wNoticeIssuerID"] = this.wNoticeIssuerID;
        data["wOtherNoticeIssuer"] = this.wOtherNoticeIssuer;
        data["wNoticeIssuedDate"] = this.wNoticeIssuedDate;
        data["wSubject"] = this.wSubject;
        data["wReferences"] = this.wReferences;
        data["wLinkToNotice"] = this.wLinkToNotice;
        data["wNotificationSentDate"] = this.wNotificationSentDate;
        data["wEmailNotificationContent"] = this.wEmailNotificationContent;
        data["wCreatedBy"] = this.wCreatedBy;
        data["wNoticeIssuerShortName"] = this.wNoticeIssuerShortName;
        data["wResponseRequired"] = this.wResponseRequired;
        data["wNoticeEmail"] = this.wNoticeEmail;
        data["wPublishOnESS"] = this.wPublishOnESS;
        data["wObjectSOStatusID"] = this.wObjectSOStatusID;
        data["wNotes"] = this.wNotes;
        data["wNoticeSignOffText"] = this.wNoticeSignOffText;
        data["objNoticeQuestionnaire"] = this.objNoticeQuestionnaire ? this.objNoticeQuestionnaire.toJSON() : <any>undefined;
        data["wNoticeQuestionnaireID"] = this.wNoticeQuestionnaireID;
        data["wSourceNoticeQuestionnaireID"] = this.wSourceNoticeQuestionnaireID;
        data["wResponseDueDate"] = this.wResponseDueDate;
        data["wRespondentTypeID"] = this.wRespondentTypeID;
        data["wRespondentsControlledFunctionTypeIDs"] = this.wRespondentsControlledFunctionTypeIDs;
        data["wRespondentsDNFBPFunctionTypeIDs"] = this.wRespondentsDNFBPFunctionTypeIDs;
        if (Array.isArray(this.lstNoticeQuestionnaireItems)) {
            data["lstNoticeQuestionnaireItems"] = [];
            for (let item of this.lstNoticeQuestionnaireItems)
                data["lstNoticeQuestionnaireItems"].push(item.toJSON());
        }
        data["wNoticeQuestionnaireItemID"] = this.wNoticeQuestionnaireItemID;
        data["wSourceNoticeQuestionnaireItemID"] = this.wSourceNoticeQuestionnaireItemID;
        data["wNoticeQuestionNumber"] = this.wNoticeQuestionNumber;
        data["wNoticeQuestion"] = this.wNoticeQuestion;
        data["wResponseTypeID"] = this.wResponseTypeID;
        data["wResponseTypeDesc"] = this.wResponseTypeDesc;
        data["wListNameID"] = this.wListNameID;
        data["wListNameDesc"] = this.wListNameDesc;
        data["wExplanationRequired"] = this.wExplanationRequired;
        data["wEvaluationRequirementTypeDesc"] = this.wEvaluationRequirementTypeDesc;
        data["wQuestionDisplayOrder"] = this.wQuestionDisplayOrder;
        data["wNoticeResponseItemID"] = this.wNoticeResponseItemID;
        data["wExplanation"] = this.wExplanation;
        data["wExplanationReqdCriteriaMet"] = this.wExplanationReqdCriteriaMet;
        data["wResponseAnswer"] = this.wResponseAnswer;
        data["responseProvided"] = this.responseProvided;
        data["explanationProvided"] = this.explanationProvided;
        data["evaluationCriteriaMet"] = this.evaluationCriteriaMet;
        data["errorMessage"] = this.errorMessage;
        data["wResponseMandatory"] = this.wResponseMandatory;
        if (Array.isArray(this.lstResponseCriteria)) {
            data["lstResponseCriteria"] = [];
            for (let item of this.lstResponseCriteria)
                data["lstResponseCriteria"].push(item.toJSON());
        }
        data["wSourceResponseEvaluationCriteriaID"] = this.wSourceResponseEvaluationCriteriaID;
        data["wResponseEvaluationCriteriaID"] = this.wResponseEvaluationCriteriaID;
        data["wEvaluationReasonTypeID"] = this.wEvaluationReasonTypeID;
        data["wNoticeResponseValueID"] = this.wNoticeResponseValueID;
        data["wResponseOperatorTypeID"] = this.wResponseOperatorTypeID;
        data["wEvaluationOperatorTypeDesc"] = this.wEvaluationOperatorTypeDesc;
        data["wResponse"] = this.wResponse;
        data["wResponseTo"] = this.wResponseTo;
        data["wListValueID"] = this.wListValueID;
        data["listValueDesc"] = this.listValueDesc;
        if (this.dcMultiSelectValues) {
            data["dcMultiSelectValues"] = {};
            for (let key in this.dcMultiSelectValues) {
                if (this.dcMultiSelectValues.hasOwnProperty(key))
                    (<any>data["dcMultiSelectValues"])[key] = (<any>this.dcMultiSelectValues)[key];
            }
        }
        return data;
    }
}

export interface IWNoticeResponseEvaluationCriteria {
    wNoticeID?: number | undefined;
    wFirmNoticeID?: number;
    wSourceNoticeID?: number;
    wNoticeTypeID?: number;
    wNoticeTypeDesc?: string | undefined;
    wNoticeName?: string | undefined;
    wReferenceNumber?: string | undefined;
    wcmsReferenceNumber?: string | undefined;
    wIssuersReferenceNumber?: string | undefined;
    wNoticeIssuerID?: number | undefined;
    wOtherNoticeIssuer?: string | undefined;
    wNoticeIssuedDate?: string | undefined;
    wSubject?: string | undefined;
    wReferences?: string | undefined;
    wLinkToNotice?: string | undefined;
    wNotificationSentDate?: string | undefined;
    wEmailNotificationContent?: string | undefined;
    wCreatedBy?: number;
    wNoticeIssuerShortName?: string | undefined;
    wResponseRequired?: boolean;
    wNoticeEmail?: string | undefined;
    wPublishOnESS?: boolean;
    wObjectSOStatusID?: number | undefined;
    wNotes?: string | undefined;
    wNoticeSignOffText?: string | undefined;
    objNoticeQuestionnaire?: WNoticeQuestionnaire;
    wNoticeQuestionnaireID?: number | undefined;
    wSourceNoticeQuestionnaireID?: number;
    wResponseDueDate?: string | undefined;
    wRespondentTypeID?: number | undefined;
    wRespondentsControlledFunctionTypeIDs?: string | undefined;
    wRespondentsDNFBPFunctionTypeIDs?: string | undefined;
    lstNoticeQuestionnaireItems?: WNoticeQuestionnaireItems[] | undefined;
    wNoticeQuestionnaireItemID?: number | undefined;
    wSourceNoticeQuestionnaireItemID?: number;
    wNoticeQuestionNumber?: string | undefined;
    wNoticeQuestion?: string | undefined;
    wResponseTypeID?: number | undefined;
    wResponseTypeDesc?: string | undefined;
    wListNameID?: number | undefined;
    wListNameDesc?: string | undefined;
    wExplanationRequired?: number | undefined;
    wEvaluationRequirementTypeDesc?: string | undefined;
    wQuestionDisplayOrder?: number;
    wNoticeResponseItemID?: number | undefined;
    wExplanation?: string | undefined;
    wExplanationReqdCriteriaMet?: boolean | undefined;
    wResponseAnswer?: string | undefined;
    responseProvided?: boolean | undefined;
    explanationProvided?: boolean | undefined;
    evaluationCriteriaMet?: number | undefined;
    errorMessage?: string | undefined;
    wResponseMandatory?: boolean;
    lstResponseCriteria?: WNoticeResponseEvaluationCriteria[] | undefined;
    wSourceResponseEvaluationCriteriaID?: number;
    wResponseEvaluationCriteriaID?: number | undefined;
    wEvaluationReasonTypeID?: number;
    wNoticeResponseValueID?: number | undefined;
    wResponseOperatorTypeID?: number | undefined;
    wEvaluationOperatorTypeDesc?: string | undefined;
    wResponse?: string | undefined;
    wResponseTo?: string | undefined;
    wListValueID?: number | undefined;
    listValueDesc?: string | undefined;
    dcMultiSelectValues?: { [key: string]: string; } | undefined;
}

export class WNoticeResponseEvaluationCriteriaDto implements IWNoticeResponseEvaluationCriteriaDto {
    wResponseEvaluationCriteriaID?: number | undefined;
    wSourceResponseEvaluationCriteriaID?: number | undefined;
    wNoticeID?: number | undefined;
    wNoticeResponseValueID?: number | undefined;
    wNoticeResponseItemID?: number | undefined;
    wNoticeQuestionnaireID?: number | undefined;
    wNoticeQuestionnaireItemID?: number | undefined;
    wEvaluationReasonTypeID?: number | undefined;
    wResponseOperatorTypeID?: number | undefined;
    wResponse?: string | undefined;
    wResponseTo?: string | undefined;
    wListValueID?: number | undefined;
    wCreatedBy?: number | undefined;

    constructor(data?: IWNoticeResponseEvaluationCriteriaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wResponseEvaluationCriteriaID = _data["wResponseEvaluationCriteriaID"];
            this.wSourceResponseEvaluationCriteriaID = _data["wSourceResponseEvaluationCriteriaID"];
            this.wNoticeID = _data["wNoticeID"];
            this.wNoticeResponseValueID = _data["wNoticeResponseValueID"];
            this.wNoticeResponseItemID = _data["wNoticeResponseItemID"];
            this.wNoticeQuestionnaireID = _data["wNoticeQuestionnaireID"];
            this.wNoticeQuestionnaireItemID = _data["wNoticeQuestionnaireItemID"];
            this.wEvaluationReasonTypeID = _data["wEvaluationReasonTypeID"];
            this.wResponseOperatorTypeID = _data["wResponseOperatorTypeID"];
            this.wResponse = _data["wResponse"];
            this.wResponseTo = _data["wResponseTo"];
            this.wListValueID = _data["wListValueID"];
            this.wCreatedBy = _data["wCreatedBy"];
        }
    }

    static fromJS(data: any): WNoticeResponseEvaluationCriteriaDto {
        data = typeof data === 'object' ? data : {};
        let result = new WNoticeResponseEvaluationCriteriaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wResponseEvaluationCriteriaID"] = this.wResponseEvaluationCriteriaID;
        data["wSourceResponseEvaluationCriteriaID"] = this.wSourceResponseEvaluationCriteriaID;
        data["wNoticeID"] = this.wNoticeID;
        data["wNoticeResponseValueID"] = this.wNoticeResponseValueID;
        data["wNoticeResponseItemID"] = this.wNoticeResponseItemID;
        data["wNoticeQuestionnaireID"] = this.wNoticeQuestionnaireID;
        data["wNoticeQuestionnaireItemID"] = this.wNoticeQuestionnaireItemID;
        data["wEvaluationReasonTypeID"] = this.wEvaluationReasonTypeID;
        data["wResponseOperatorTypeID"] = this.wResponseOperatorTypeID;
        data["wResponse"] = this.wResponse;
        data["wResponseTo"] = this.wResponseTo;
        data["wListValueID"] = this.wListValueID;
        data["wCreatedBy"] = this.wCreatedBy;
        return data;
    }
}

export interface IWNoticeResponseEvaluationCriteriaDto {
    wResponseEvaluationCriteriaID?: number | undefined;
    wSourceResponseEvaluationCriteriaID?: number | undefined;
    wNoticeID?: number | undefined;
    wNoticeResponseValueID?: number | undefined;
    wNoticeResponseItemID?: number | undefined;
    wNoticeQuestionnaireID?: number | undefined;
    wNoticeQuestionnaireItemID?: number | undefined;
    wEvaluationReasonTypeID?: number | undefined;
    wResponseOperatorTypeID?: number | undefined;
    wResponse?: string | undefined;
    wResponseTo?: string | undefined;
    wListValueID?: number | undefined;
    wCreatedBy?: number | undefined;
}

export class WUserLogins implements IWUserLogins {
    qfcNum?: string | undefined;
    individualName?: string | undefined;
    aiNumber?: string | undefined;
    individualEmailAddress?: string | undefined;
    isRegistered?: boolean | undefined;
    dateCreated?: string | undefined;
    userRoleIDs?: string | undefined;
    userRoleDesc?: string | undefined;
    lastLogin?: string | undefined;
    no_Of_Days_Last_Login?: number | undefined;

    constructor(data?: IWUserLogins) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.qfcNum = _data["qfcNum"];
            this.individualName = _data["individualName"];
            this.aiNumber = _data["aiNumber"];
            this.individualEmailAddress = _data["individualEmailAddress"];
            this.isRegistered = _data["isRegistered"];
            this.dateCreated = _data["dateCreated"];
            this.userRoleIDs = _data["userRoleIDs"];
            this.userRoleDesc = _data["userRoleDesc"];
            this.lastLogin = _data["lastLogin"];
            this.no_Of_Days_Last_Login = _data["no_Of_Days_Last_Login"];
        }
    }

    static fromJS(data: any): WUserLogins {
        data = typeof data === 'object' ? data : {};
        let result = new WUserLogins();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qfcNum"] = this.qfcNum;
        data["individualName"] = this.individualName;
        data["aiNumber"] = this.aiNumber;
        data["individualEmailAddress"] = this.individualEmailAddress;
        data["isRegistered"] = this.isRegistered;
        data["dateCreated"] = this.dateCreated;
        data["userRoleIDs"] = this.userRoleIDs;
        data["userRoleDesc"] = this.userRoleDesc;
        data["lastLogin"] = this.lastLogin;
        data["no_Of_Days_Last_Login"] = this.no_Of_Days_Last_Login;
        return data;
    }
}

export interface IWUserLogins {
    qfcNum?: string | undefined;
    individualName?: string | undefined;
    aiNumber?: string | undefined;
    individualEmailAddress?: string | undefined;
    isRegistered?: boolean | undefined;
    dateCreated?: string | undefined;
    userRoleIDs?: string | undefined;
    userRoleDesc?: string | undefined;
    lastLogin?: string | undefined;
    no_Of_Days_Last_Login?: number | undefined;
}

export class WUserLoginsListBaseResponse implements IWUserLoginsListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: WUserLogins[] | undefined;

    constructor(data?: IWUserLoginsListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["response"])) {
                this.response = [] as any;
                for (let item of _data["response"])
                    this.response!.push(WUserLogins.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WUserLoginsListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WUserLoginsListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.response)) {
            data["response"] = [];
            for (let item of this.response)
                data["response"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWUserLoginsListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: WUserLogins[] | undefined;
}

export class WUserRoles implements IWUserRoles {
    wUserRoleID?: number;
    wFunctionTypeID?: number;
    waccessRequestID?: number;
    wRoleID?: number;
    wRoleStartDate?: string | undefined;
    roleValid?: number;
    wUserID?: number;
    createdBy?: number;
    wObjectID?: number | undefined;

    constructor(data?: IWUserRoles) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wUserRoleID = _data["wUserRoleID"];
            this.wFunctionTypeID = _data["wFunctionTypeID"];
            this.waccessRequestID = _data["waccessRequestID"];
            this.wRoleID = _data["wRoleID"];
            this.wRoleStartDate = _data["wRoleStartDate"];
            this.roleValid = _data["roleValid"];
            this.wUserID = _data["wUserID"];
            this.createdBy = _data["createdBy"];
            this.wObjectID = _data["wObjectID"];
        }
    }

    static fromJS(data: any): WUserRoles {
        data = typeof data === 'object' ? data : {};
        let result = new WUserRoles();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wUserRoleID"] = this.wUserRoleID;
        data["wFunctionTypeID"] = this.wFunctionTypeID;
        data["waccessRequestID"] = this.waccessRequestID;
        data["wRoleID"] = this.wRoleID;
        data["wRoleStartDate"] = this.wRoleStartDate;
        data["roleValid"] = this.roleValid;
        data["wUserID"] = this.wUserID;
        data["createdBy"] = this.createdBy;
        data["wObjectID"] = this.wObjectID;
        return data;
    }
}

export interface IWUserRoles {
    wUserRoleID?: number;
    wFunctionTypeID?: number;
    waccessRequestID?: number;
    wRoleID?: number;
    wRoleStartDate?: string | undefined;
    roleValid?: number;
    wUserID?: number;
    createdBy?: number;
    wObjectID?: number | undefined;
}

export class WUserRolesListBaseResponse implements IWUserRolesListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: WUserRoles[] | undefined;

    constructor(data?: IWUserRolesListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["response"])) {
                this.response = [] as any;
                for (let item of _data["response"])
                    this.response!.push(WUserRoles.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WUserRolesListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WUserRolesListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.response)) {
            data["response"] = [];
            for (let item of this.response)
                data["response"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWUserRolesListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: WUserRoles[] | undefined;
}

export class WUsers implements IWUsers {
    wAccessRequestID?: number;
    firmQFCNo?: string | undefined;
    firmName?: string | undefined;
    firmTypeID?: number;
    firmTypeDesc?: string | undefined;
    contactID?: number;
    individualJobTitle?: string | undefined;
    individualDateOfBirth?: string | undefined;
    individualNationality?: string | undefined;
    registrationCode?: string | undefined;
    registrationDate?: string | undefined;
    createdBy?: number;
    accountLocked?: boolean;
    isAccountExpired?: boolean;
    isLoggedIn?: boolean;
    isActiveUser?: boolean;
    isAccountExists?: boolean;
    isValidReqeust?: boolean | undefined;
    wFunctionTypeIDsList?: string | undefined;
    withdrawnFunctionTypeIDsList?: string | undefined;
    wRequestTypeID?: number;
    wRequestTypeDesc?: string | undefined;
    registrationStatus?: string | undefined;
    wUserAccountTypeID?: number;
    wUserAccountTypeDesc?: string | undefined;
    roleDesc?: string | undefined;
    wUserID?: number;
    wUserLoginID?: number | undefined;
    isRecordInsert?: boolean;
    isSEF?: boolean;
    isSessionActive?: boolean;
    passwordChangeDate?: Date | undefined;
    userPassword?: string | undefined;
    lstApplicationDetail?: ApplicationDetail[] | undefined;
    wObjectID?: number | undefined;
    wRoleStartDate?: string | undefined;
    lstWUserRoles?: WUserRoles[] | undefined;
    objectID?: number | undefined;
    userLoginName?: string | undefined;
    isActive?: boolean;
    agreedOnTerms?: boolean;
    termID?: number;
    termsAgreedDate?: string | undefined;
    createdDate?: string | undefined;
    userModified?: number;
    dateModified?: string | undefined;
    wLoginQuestionTypeID?: number;
    userQuestionAnswer?: string | undefined;
    userIPAddress?: string | undefined;
    individualName?: string | undefined;
    userSessionID?: string | undefined;
    roleId?: number | undefined;
    roleDescription?: string | undefined;
    isRoleValid?: boolean;
    individualEmailAddress?: string | undefined;
    registrationPassword?: string | undefined;
    dateOfBirth?: string | undefined;
    nationality?: string | undefined;
    isRegistered?: boolean;
    isAccountLocked?: boolean;
    operationFlage?: string | undefined;
    qfcNumber?: string | undefined;
    wRoleIDs?: string | undefined;
    wActiveUserRoles?: string | undefined;
    wActiveUserRoleIDs?: string | undefined;
    aiNumber?: string | undefined;
    workPhone?: string | undefined;
    residencePhone?: string | undefined;
    isUserAccessAuthorised?: boolean;

    constructor(data?: IWUsers) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wAccessRequestID = _data["wAccessRequestID"];
            this.firmQFCNo = _data["firmQFCNo"];
            this.firmName = _data["firmName"];
            this.firmTypeID = _data["firmTypeID"];
            this.firmTypeDesc = _data["firmTypeDesc"];
            this.contactID = _data["contactID"];
            this.individualJobTitle = _data["individualJobTitle"];
            this.individualDateOfBirth = _data["individualDateOfBirth"];
            this.individualNationality = _data["individualNationality"];
            this.registrationCode = _data["registrationCode"];
            this.registrationDate = _data["registrationDate"];
            this.createdBy = _data["createdBy"];
            this.accountLocked = _data["accountLocked"];
            this.isAccountExpired = _data["isAccountExpired"];
            this.isLoggedIn = _data["isLoggedIn"];
            this.isActiveUser = _data["isActiveUser"];
            this.isAccountExists = _data["isAccountExists"];
            this.isValidReqeust = _data["isValidReqeust"];
            this.wFunctionTypeIDsList = _data["wFunctionTypeIDsList"];
            this.withdrawnFunctionTypeIDsList = _data["withdrawnFunctionTypeIDsList"];
            this.wRequestTypeID = _data["wRequestTypeID"];
            this.wRequestTypeDesc = _data["wRequestTypeDesc"];
            this.registrationStatus = _data["registrationStatus"];
            this.wUserAccountTypeID = _data["wUserAccountTypeID"];
            this.wUserAccountTypeDesc = _data["wUserAccountTypeDesc"];
            this.roleDesc = _data["roleDesc"];
            this.wUserID = _data["wUserID"];
            this.wUserLoginID = _data["wUserLoginID"];
            this.isRecordInsert = _data["isRecordInsert"];
            this.isSEF = _data["isSEF"];
            this.isSessionActive = _data["isSessionActive"];
            this.passwordChangeDate = _data["passwordChangeDate"] ? new Date(_data["passwordChangeDate"].toString()) : <any>undefined;
            this.userPassword = _data["userPassword"];
            if (Array.isArray(_data["lstApplicationDetail"])) {
                this.lstApplicationDetail = [] as any;
                for (let item of _data["lstApplicationDetail"])
                    this.lstApplicationDetail!.push(ApplicationDetail.fromJS(item));
            }
            this.wObjectID = _data["wObjectID"];
            this.wRoleStartDate = _data["wRoleStartDate"];
            if (Array.isArray(_data["lstWUserRoles"])) {
                this.lstWUserRoles = [] as any;
                for (let item of _data["lstWUserRoles"])
                    this.lstWUserRoles!.push(WUserRoles.fromJS(item));
            }
            this.objectID = _data["objectID"];
            this.userLoginName = _data["userLoginName"];
            this.isActive = _data["isActive"];
            this.agreedOnTerms = _data["agreedOnTerms"];
            this.termID = _data["termID"];
            this.termsAgreedDate = _data["termsAgreedDate"];
            this.createdDate = _data["createdDate"];
            this.userModified = _data["userModified"];
            this.dateModified = _data["dateModified"];
            this.wLoginQuestionTypeID = _data["wLoginQuestionTypeID"];
            this.userQuestionAnswer = _data["userQuestionAnswer"];
            this.userIPAddress = _data["userIPAddress"];
            this.individualName = _data["individualName"];
            this.userSessionID = _data["userSessionID"];
            this.roleId = _data["roleId"];
            this.roleDescription = _data["roleDescription"];
            this.isRoleValid = _data["isRoleValid"];
            this.individualEmailAddress = _data["individualEmailAddress"];
            this.registrationPassword = _data["registrationPassword"];
            this.dateOfBirth = _data["dateOfBirth"];
            this.nationality = _data["nationality"];
            this.isRegistered = _data["isRegistered"];
            this.isAccountLocked = _data["isAccountLocked"];
            this.operationFlage = _data["operationFlage"];
            this.qfcNumber = _data["qfcNumber"];
            this.wRoleIDs = _data["wRoleIDs"];
            this.wActiveUserRoles = _data["wActiveUserRoles"];
            this.wActiveUserRoleIDs = _data["wActiveUserRoleIDs"];
            this.aiNumber = _data["aiNumber"];
            this.workPhone = _data["workPhone"];
            this.residencePhone = _data["residencePhone"];
            this.isUserAccessAuthorised = _data["isUserAccessAuthorised"];
        }
    }

    static fromJS(data: any): WUsers {
        data = typeof data === 'object' ? data : {};
        let result = new WUsers();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wAccessRequestID"] = this.wAccessRequestID;
        data["firmQFCNo"] = this.firmQFCNo;
        data["firmName"] = this.firmName;
        data["firmTypeID"] = this.firmTypeID;
        data["firmTypeDesc"] = this.firmTypeDesc;
        data["contactID"] = this.contactID;
        data["individualJobTitle"] = this.individualJobTitle;
        data["individualDateOfBirth"] = this.individualDateOfBirth;
        data["individualNationality"] = this.individualNationality;
        data["registrationCode"] = this.registrationCode;
        data["registrationDate"] = this.registrationDate;
        data["createdBy"] = this.createdBy;
        data["accountLocked"] = this.accountLocked;
        data["isAccountExpired"] = this.isAccountExpired;
        data["isLoggedIn"] = this.isLoggedIn;
        data["isActiveUser"] = this.isActiveUser;
        data["isAccountExists"] = this.isAccountExists;
        data["isValidReqeust"] = this.isValidReqeust;
        data["wFunctionTypeIDsList"] = this.wFunctionTypeIDsList;
        data["withdrawnFunctionTypeIDsList"] = this.withdrawnFunctionTypeIDsList;
        data["wRequestTypeID"] = this.wRequestTypeID;
        data["wRequestTypeDesc"] = this.wRequestTypeDesc;
        data["registrationStatus"] = this.registrationStatus;
        data["wUserAccountTypeID"] = this.wUserAccountTypeID;
        data["wUserAccountTypeDesc"] = this.wUserAccountTypeDesc;
        data["roleDesc"] = this.roleDesc;
        data["wUserID"] = this.wUserID;
        data["wUserLoginID"] = this.wUserLoginID;
        data["isRecordInsert"] = this.isRecordInsert;
        data["isSEF"] = this.isSEF;
        data["isSessionActive"] = this.isSessionActive;
        data["passwordChangeDate"] = this.passwordChangeDate ? this.passwordChangeDate.toISOString() : <any>undefined;
        data["userPassword"] = this.userPassword;
        if (Array.isArray(this.lstApplicationDetail)) {
            data["lstApplicationDetail"] = [];
            for (let item of this.lstApplicationDetail)
                data["lstApplicationDetail"].push(item.toJSON());
        }
        data["wObjectID"] = this.wObjectID;
        data["wRoleStartDate"] = this.wRoleStartDate;
        if (Array.isArray(this.lstWUserRoles)) {
            data["lstWUserRoles"] = [];
            for (let item of this.lstWUserRoles)
                data["lstWUserRoles"].push(item.toJSON());
        }
        data["objectID"] = this.objectID;
        data["userLoginName"] = this.userLoginName;
        data["isActive"] = this.isActive;
        data["agreedOnTerms"] = this.agreedOnTerms;
        data["termID"] = this.termID;
        data["termsAgreedDate"] = this.termsAgreedDate;
        data["createdDate"] = this.createdDate;
        data["userModified"] = this.userModified;
        data["dateModified"] = this.dateModified;
        data["wLoginQuestionTypeID"] = this.wLoginQuestionTypeID;
        data["userQuestionAnswer"] = this.userQuestionAnswer;
        data["userIPAddress"] = this.userIPAddress;
        data["individualName"] = this.individualName;
        data["userSessionID"] = this.userSessionID;
        data["roleId"] = this.roleId;
        data["roleDescription"] = this.roleDescription;
        data["isRoleValid"] = this.isRoleValid;
        data["individualEmailAddress"] = this.individualEmailAddress;
        data["registrationPassword"] = this.registrationPassword;
        data["dateOfBirth"] = this.dateOfBirth;
        data["nationality"] = this.nationality;
        data["isRegistered"] = this.isRegistered;
        data["isAccountLocked"] = this.isAccountLocked;
        data["operationFlage"] = this.operationFlage;
        data["qfcNumber"] = this.qfcNumber;
        data["wRoleIDs"] = this.wRoleIDs;
        data["wActiveUserRoles"] = this.wActiveUserRoles;
        data["wActiveUserRoleIDs"] = this.wActiveUserRoleIDs;
        data["aiNumber"] = this.aiNumber;
        data["workPhone"] = this.workPhone;
        data["residencePhone"] = this.residencePhone;
        data["isUserAccessAuthorised"] = this.isUserAccessAuthorised;
        return data;
    }
}

export interface IWUsers {
    wAccessRequestID?: number;
    firmQFCNo?: string | undefined;
    firmName?: string | undefined;
    firmTypeID?: number;
    firmTypeDesc?: string | undefined;
    contactID?: number;
    individualJobTitle?: string | undefined;
    individualDateOfBirth?: string | undefined;
    individualNationality?: string | undefined;
    registrationCode?: string | undefined;
    registrationDate?: string | undefined;
    createdBy?: number;
    accountLocked?: boolean;
    isAccountExpired?: boolean;
    isLoggedIn?: boolean;
    isActiveUser?: boolean;
    isAccountExists?: boolean;
    isValidReqeust?: boolean | undefined;
    wFunctionTypeIDsList?: string | undefined;
    withdrawnFunctionTypeIDsList?: string | undefined;
    wRequestTypeID?: number;
    wRequestTypeDesc?: string | undefined;
    registrationStatus?: string | undefined;
    wUserAccountTypeID?: number;
    wUserAccountTypeDesc?: string | undefined;
    roleDesc?: string | undefined;
    wUserID?: number;
    wUserLoginID?: number | undefined;
    isRecordInsert?: boolean;
    isSEF?: boolean;
    isSessionActive?: boolean;
    passwordChangeDate?: Date | undefined;
    userPassword?: string | undefined;
    lstApplicationDetail?: ApplicationDetail[] | undefined;
    wObjectID?: number | undefined;
    wRoleStartDate?: string | undefined;
    lstWUserRoles?: WUserRoles[] | undefined;
    objectID?: number | undefined;
    userLoginName?: string | undefined;
    isActive?: boolean;
    agreedOnTerms?: boolean;
    termID?: number;
    termsAgreedDate?: string | undefined;
    createdDate?: string | undefined;
    userModified?: number;
    dateModified?: string | undefined;
    wLoginQuestionTypeID?: number;
    userQuestionAnswer?: string | undefined;
    userIPAddress?: string | undefined;
    individualName?: string | undefined;
    userSessionID?: string | undefined;
    roleId?: number | undefined;
    roleDescription?: string | undefined;
    isRoleValid?: boolean;
    individualEmailAddress?: string | undefined;
    registrationPassword?: string | undefined;
    dateOfBirth?: string | undefined;
    nationality?: string | undefined;
    isRegistered?: boolean;
    isAccountLocked?: boolean;
    operationFlage?: string | undefined;
    qfcNumber?: string | undefined;
    wRoleIDs?: string | undefined;
    wActiveUserRoles?: string | undefined;
    wActiveUserRoleIDs?: string | undefined;
    aiNumber?: string | undefined;
    workPhone?: string | undefined;
    residencePhone?: string | undefined;
    isUserAccessAuthorised?: boolean;
}

export class WUsersDto implements IWUsersDto {
    wUserID?: number | undefined;
    wAccessRequestID?: number | undefined;
    isAccountLocked?: boolean | undefined;
    agreedOnTerms?: boolean;
    isActive?: boolean | undefined;
    roleDescription?: string | undefined;
    userQuestionAnswer?: string | undefined;
    userModified?: number | undefined;
    operationFlage?: string | undefined;
    individualName?: string | undefined;
    individualEmailAddress?: string | undefined;
    userLoginName?: string | undefined;
    userPassword?: string | undefined;
    userIPAddress?: string | undefined;
    wRoleIDs?: string | undefined;
    userSessionID?: string | undefined;
    termID?: number | undefined;
    createdBy?: number | undefined;
    roleId?: number;
    isRoleValid?: boolean;
    firmQFCNo?: any | undefined;
    qfcNumber?: any | undefined;
    firmName?: string | undefined;
    workPhone?: string | undefined;
    residencePhone?: string | undefined;
    createdDate?: string | undefined;
    dateOfBirth?: string | undefined;
    nationality?: string | undefined;
    wActiveUserRoles?: string | undefined;
    aiNumber?: string | undefined;
    wActiveUserRoleIDs?: string | undefined;
    isUserAccessAuthorised?: boolean | undefined;
    firmTypeDesc?: string | undefined;

    constructor(data?: IWUsersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wUserID = _data["wUserID"];
            this.wAccessRequestID = _data["wAccessRequestID"];
            this.isAccountLocked = _data["isAccountLocked"];
            this.agreedOnTerms = _data["agreedOnTerms"];
            this.isActive = _data["isActive"];
            this.roleDescription = _data["roleDescription"];
            this.userQuestionAnswer = _data["userQuestionAnswer"];
            this.userModified = _data["userModified"];
            this.operationFlage = _data["operationFlage"];
            this.individualName = _data["individualName"];
            this.individualEmailAddress = _data["individualEmailAddress"];
            this.userLoginName = _data["userLoginName"];
            this.userPassword = _data["userPassword"];
            this.userIPAddress = _data["userIPAddress"];
            this.wRoleIDs = _data["wRoleIDs"];
            this.userSessionID = _data["userSessionID"];
            this.termID = _data["termID"];
            this.createdBy = _data["createdBy"];
            this.roleId = _data["roleId"];
            this.isRoleValid = _data["isRoleValid"];
            this.firmQFCNo = _data["firmQFCNo"];
            this.qfcNumber = _data["qfcNumber"];
            this.firmName = _data["firmName"];
            this.workPhone = _data["workPhone"];
            this.residencePhone = _data["residencePhone"];
            this.createdDate = _data["createdDate"];
            this.dateOfBirth = _data["dateOfBirth"];
            this.nationality = _data["nationality"];
            this.wActiveUserRoles = _data["wActiveUserRoles"];
            this.aiNumber = _data["aiNumber"];
            this.wActiveUserRoleIDs = _data["wActiveUserRoleIDs"];
            this.isUserAccessAuthorised = _data["isUserAccessAuthorised"];
            this.firmTypeDesc = _data["firmTypeDesc"];
        }
    }

    static fromJS(data: any): WUsersDto {
        data = typeof data === 'object' ? data : {};
        let result = new WUsersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wUserID"] = this.wUserID;
        data["wAccessRequestID"] = this.wAccessRequestID;
        data["isAccountLocked"] = this.isAccountLocked;
        data["agreedOnTerms"] = this.agreedOnTerms;
        data["isActive"] = this.isActive;
        data["roleDescription"] = this.roleDescription;
        data["userQuestionAnswer"] = this.userQuestionAnswer;
        data["userModified"] = this.userModified;
        data["operationFlage"] = this.operationFlage;
        data["individualName"] = this.individualName;
        data["individualEmailAddress"] = this.individualEmailAddress;
        data["userLoginName"] = this.userLoginName;
        data["userPassword"] = this.userPassword;
        data["userIPAddress"] = this.userIPAddress;
        data["wRoleIDs"] = this.wRoleIDs;
        data["userSessionID"] = this.userSessionID;
        data["termID"] = this.termID;
        data["createdBy"] = this.createdBy;
        data["roleId"] = this.roleId;
        data["isRoleValid"] = this.isRoleValid;
        data["firmQFCNo"] = this.firmQFCNo;
        data["qfcNumber"] = this.qfcNumber;
        data["firmName"] = this.firmName;
        data["workPhone"] = this.workPhone;
        data["residencePhone"] = this.residencePhone;
        data["createdDate"] = this.createdDate;
        data["dateOfBirth"] = this.dateOfBirth;
        data["nationality"] = this.nationality;
        data["wActiveUserRoles"] = this.wActiveUserRoles;
        data["aiNumber"] = this.aiNumber;
        data["wActiveUserRoleIDs"] = this.wActiveUserRoleIDs;
        data["isUserAccessAuthorised"] = this.isUserAccessAuthorised;
        data["firmTypeDesc"] = this.firmTypeDesc;
        return data;
    }
}

export interface IWUsersDto {
    wUserID?: number | undefined;
    wAccessRequestID?: number | undefined;
    isAccountLocked?: boolean | undefined;
    agreedOnTerms?: boolean;
    isActive?: boolean | undefined;
    roleDescription?: string | undefined;
    userQuestionAnswer?: string | undefined;
    userModified?: number | undefined;
    operationFlage?: string | undefined;
    individualName?: string | undefined;
    individualEmailAddress?: string | undefined;
    userLoginName?: string | undefined;
    userPassword?: string | undefined;
    userIPAddress?: string | undefined;
    wRoleIDs?: string | undefined;
    userSessionID?: string | undefined;
    termID?: number | undefined;
    createdBy?: number | undefined;
    roleId?: number;
    isRoleValid?: boolean;
    firmQFCNo?: any | undefined;
    qfcNumber?: any | undefined;
    firmName?: string | undefined;
    workPhone?: string | undefined;
    residencePhone?: string | undefined;
    createdDate?: string | undefined;
    dateOfBirth?: string | undefined;
    nationality?: string | undefined;
    wActiveUserRoles?: string | undefined;
    aiNumber?: string | undefined;
    wActiveUserRoleIDs?: string | undefined;
    isUserAccessAuthorised?: boolean | undefined;
    firmTypeDesc?: string | undefined;
}

export class WUsersDtoBaseResponse implements IWUsersDtoBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: WUsersDto;

    constructor(data?: IWUsersDtoBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            this.response = _data["response"] ? WUsersDto.fromJS(_data["response"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WUsersDtoBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WUsersDtoBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWUsersDtoBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: WUsersDto;
}

export class WUsersDtoListBaseResponse implements IWUsersDtoListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: WUsersDto[] | undefined;

    constructor(data?: IWUsersDtoListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["response"])) {
                this.response = [] as any;
                for (let item of _data["response"])
                    this.response!.push(WUsersDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WUsersDtoListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WUsersDtoListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.response)) {
            data["response"] = [];
            for (let item of this.response)
                data["response"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWUsersDtoListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: WUsersDto[] | undefined;
}

export class WobjectAttachmentStatusDto implements IWobjectAttachmentStatusDto {
    wObjectAttachmentID?: number | undefined;
    wObjAttachmentStatusTypeID?: number | undefined;
    createdBy?: number | undefined;

    constructor(data?: IWobjectAttachmentStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wObjectAttachmentID = _data["wObjectAttachmentID"];
            this.wObjAttachmentStatusTypeID = _data["wObjAttachmentStatusTypeID"];
            this.createdBy = _data["createdBy"];
        }
    }

    static fromJS(data: any): WobjectAttachmentStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new WobjectAttachmentStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wObjectAttachmentID"] = this.wObjectAttachmentID;
        data["wObjAttachmentStatusTypeID"] = this.wObjAttachmentStatusTypeID;
        data["createdBy"] = this.createdBy;
        return data;
    }
}

export interface IWobjectAttachmentStatusDto {
    wObjectAttachmentID?: number | undefined;
    wObjAttachmentStatusTypeID?: number | undefined;
    createdBy?: number | undefined;
}

export class WobjectAttachmentStatusDtoBaseResponse implements IWobjectAttachmentStatusDtoBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: WobjectAttachmentStatusDto;

    constructor(data?: IWobjectAttachmentStatusDtoBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            this.response = _data["response"] ? WobjectAttachmentStatusDto.fromJS(_data["response"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WobjectAttachmentStatusDtoBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WobjectAttachmentStatusDtoBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWobjectAttachmentStatusDtoBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: WobjectAttachmentStatusDto;
}

export class XmlDocumentBaseResponse implements IXmlDocumentBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: any[] | undefined;

    constructor(data?: IXmlDocumentBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["response"])) {
                this.response = [] as any;
                for (let item of _data["response"])
                    this.response!.push(item);
            }
        }
    }

    static fromJS(data: any): XmlDocumentBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new XmlDocumentBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.response)) {
            data["response"] = [];
            for (let item of this.response)
                data["response"].push(item);
        }
        return data;
    }
}

export interface IXmlDocumentBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: any[] | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}